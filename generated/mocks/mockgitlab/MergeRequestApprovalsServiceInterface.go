// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"
	gitlab "gitlab.com/gitlab-org/api/client-go"
)

// MergeRequestApprovalsServiceInterface is an autogenerated mock type for the MergeRequestApprovalsServiceInterface type
type MergeRequestApprovalsServiceInterface struct {
	mock.Mock
}

type MergeRequestApprovalsServiceInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *MergeRequestApprovalsServiceInterface) EXPECT() *MergeRequestApprovalsServiceInterface_Expecter {
	return &MergeRequestApprovalsServiceInterface_Expecter{mock: &_m.Mock}
}

// ApproveMergeRequest provides a mock function with given fields: pid, mr, opt, options
func (_m *MergeRequestApprovalsServiceInterface) ApproveMergeRequest(pid interface{}, mr int, opt *gitlab.ApproveMergeRequestOptions, options ...gitlab.RequestOptionFunc) (*gitlab.MergeRequestApprovals, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mr, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ApproveMergeRequest")
	}

	var r0 *gitlab.MergeRequestApprovals
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ApproveMergeRequestOptions, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequestApprovals, *gitlab.Response, error)); ok {
		return rf(pid, mr, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ApproveMergeRequestOptions, ...gitlab.RequestOptionFunc) *gitlab.MergeRequestApprovals); ok {
		r0 = rf(pid, mr, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.MergeRequestApprovals)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.ApproveMergeRequestOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mr, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.ApproveMergeRequestOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mr, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestApprovalsServiceInterface_ApproveMergeRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ApproveMergeRequest'
type MergeRequestApprovalsServiceInterface_ApproveMergeRequest_Call struct {
	*mock.Call
}

// ApproveMergeRequest is a helper method to define mock.On call
//   - pid interface{}
//   - mr int
//   - opt *gitlab.ApproveMergeRequestOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestApprovalsServiceInterface_Expecter) ApproveMergeRequest(pid interface{}, mr interface{}, opt interface{}, options ...interface{}) *MergeRequestApprovalsServiceInterface_ApproveMergeRequest_Call {
	return &MergeRequestApprovalsServiceInterface_ApproveMergeRequest_Call{Call: _e.mock.On("ApproveMergeRequest",
		append([]interface{}{pid, mr, opt}, options...)...)}
}

func (_c *MergeRequestApprovalsServiceInterface_ApproveMergeRequest_Call) Run(run func(pid interface{}, mr int, opt *gitlab.ApproveMergeRequestOptions, options ...gitlab.RequestOptionFunc)) *MergeRequestApprovalsServiceInterface_ApproveMergeRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.ApproveMergeRequestOptions), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestApprovalsServiceInterface_ApproveMergeRequest_Call) Return(_a0 *gitlab.MergeRequestApprovals, _a1 *gitlab.Response, _a2 error) *MergeRequestApprovalsServiceInterface_ApproveMergeRequest_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestApprovalsServiceInterface_ApproveMergeRequest_Call) RunAndReturn(run func(interface{}, int, *gitlab.ApproveMergeRequestOptions, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequestApprovals, *gitlab.Response, error)) *MergeRequestApprovalsServiceInterface_ApproveMergeRequest_Call {
	_c.Call.Return(run)
	return _c
}

// ChangeAllowedApprovers provides a mock function with given fields: pid, mergeRequest, opt, options
func (_m *MergeRequestApprovalsServiceInterface) ChangeAllowedApprovers(pid interface{}, mergeRequest int, opt *gitlab.ChangeMergeRequestAllowedApproversOptions, options ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChangeAllowedApprovers")
	}

	var r0 *gitlab.MergeRequest
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ChangeMergeRequestAllowedApproversOptions, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ChangeMergeRequestAllowedApproversOptions, ...gitlab.RequestOptionFunc) *gitlab.MergeRequest); ok {
		r0 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.MergeRequest)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.ChangeMergeRequestAllowedApproversOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.ChangeMergeRequestAllowedApproversOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestApprovalsServiceInterface_ChangeAllowedApprovers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChangeAllowedApprovers'
type MergeRequestApprovalsServiceInterface_ChangeAllowedApprovers_Call struct {
	*mock.Call
}

// ChangeAllowedApprovers is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - opt *gitlab.ChangeMergeRequestAllowedApproversOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestApprovalsServiceInterface_Expecter) ChangeAllowedApprovers(pid interface{}, mergeRequest interface{}, opt interface{}, options ...interface{}) *MergeRequestApprovalsServiceInterface_ChangeAllowedApprovers_Call {
	return &MergeRequestApprovalsServiceInterface_ChangeAllowedApprovers_Call{Call: _e.mock.On("ChangeAllowedApprovers",
		append([]interface{}{pid, mergeRequest, opt}, options...)...)}
}

func (_c *MergeRequestApprovalsServiceInterface_ChangeAllowedApprovers_Call) Run(run func(pid interface{}, mergeRequest int, opt *gitlab.ChangeMergeRequestAllowedApproversOptions, options ...gitlab.RequestOptionFunc)) *MergeRequestApprovalsServiceInterface_ChangeAllowedApprovers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.ChangeMergeRequestAllowedApproversOptions), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestApprovalsServiceInterface_ChangeAllowedApprovers_Call) Return(_a0 *gitlab.MergeRequest, _a1 *gitlab.Response, _a2 error) *MergeRequestApprovalsServiceInterface_ChangeAllowedApprovers_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestApprovalsServiceInterface_ChangeAllowedApprovers_Call) RunAndReturn(run func(interface{}, int, *gitlab.ChangeMergeRequestAllowedApproversOptions, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error)) *MergeRequestApprovalsServiceInterface_ChangeAllowedApprovers_Call {
	_c.Call.Return(run)
	return _c
}

// ChangeApprovalConfiguration provides a mock function with given fields: pid, mergeRequest, opt, options
func (_m *MergeRequestApprovalsServiceInterface) ChangeApprovalConfiguration(pid interface{}, mergeRequest int, opt *gitlab.ChangeMergeRequestApprovalConfigurationOptions, options ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChangeApprovalConfiguration")
	}

	var r0 *gitlab.MergeRequest
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ChangeMergeRequestApprovalConfigurationOptions, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ChangeMergeRequestApprovalConfigurationOptions, ...gitlab.RequestOptionFunc) *gitlab.MergeRequest); ok {
		r0 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.MergeRequest)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.ChangeMergeRequestApprovalConfigurationOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.ChangeMergeRequestApprovalConfigurationOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestApprovalsServiceInterface_ChangeApprovalConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChangeApprovalConfiguration'
type MergeRequestApprovalsServiceInterface_ChangeApprovalConfiguration_Call struct {
	*mock.Call
}

// ChangeApprovalConfiguration is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - opt *gitlab.ChangeMergeRequestApprovalConfigurationOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestApprovalsServiceInterface_Expecter) ChangeApprovalConfiguration(pid interface{}, mergeRequest interface{}, opt interface{}, options ...interface{}) *MergeRequestApprovalsServiceInterface_ChangeApprovalConfiguration_Call {
	return &MergeRequestApprovalsServiceInterface_ChangeApprovalConfiguration_Call{Call: _e.mock.On("ChangeApprovalConfiguration",
		append([]interface{}{pid, mergeRequest, opt}, options...)...)}
}

func (_c *MergeRequestApprovalsServiceInterface_ChangeApprovalConfiguration_Call) Run(run func(pid interface{}, mergeRequest int, opt *gitlab.ChangeMergeRequestApprovalConfigurationOptions, options ...gitlab.RequestOptionFunc)) *MergeRequestApprovalsServiceInterface_ChangeApprovalConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.ChangeMergeRequestApprovalConfigurationOptions), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestApprovalsServiceInterface_ChangeApprovalConfiguration_Call) Return(_a0 *gitlab.MergeRequest, _a1 *gitlab.Response, _a2 error) *MergeRequestApprovalsServiceInterface_ChangeApprovalConfiguration_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestApprovalsServiceInterface_ChangeApprovalConfiguration_Call) RunAndReturn(run func(interface{}, int, *gitlab.ChangeMergeRequestApprovalConfigurationOptions, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error)) *MergeRequestApprovalsServiceInterface_ChangeApprovalConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// CreateApprovalRule provides a mock function with given fields: pid, mergeRequest, opt, options
func (_m *MergeRequestApprovalsServiceInterface) CreateApprovalRule(pid interface{}, mergeRequest int, opt *gitlab.CreateMergeRequestApprovalRuleOptions, options ...gitlab.RequestOptionFunc) (*gitlab.MergeRequestApprovalRule, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateApprovalRule")
	}

	var r0 *gitlab.MergeRequestApprovalRule
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.CreateMergeRequestApprovalRuleOptions, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequestApprovalRule, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.CreateMergeRequestApprovalRuleOptions, ...gitlab.RequestOptionFunc) *gitlab.MergeRequestApprovalRule); ok {
		r0 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.MergeRequestApprovalRule)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.CreateMergeRequestApprovalRuleOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.CreateMergeRequestApprovalRuleOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestApprovalsServiceInterface_CreateApprovalRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateApprovalRule'
type MergeRequestApprovalsServiceInterface_CreateApprovalRule_Call struct {
	*mock.Call
}

// CreateApprovalRule is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - opt *gitlab.CreateMergeRequestApprovalRuleOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestApprovalsServiceInterface_Expecter) CreateApprovalRule(pid interface{}, mergeRequest interface{}, opt interface{}, options ...interface{}) *MergeRequestApprovalsServiceInterface_CreateApprovalRule_Call {
	return &MergeRequestApprovalsServiceInterface_CreateApprovalRule_Call{Call: _e.mock.On("CreateApprovalRule",
		append([]interface{}{pid, mergeRequest, opt}, options...)...)}
}

func (_c *MergeRequestApprovalsServiceInterface_CreateApprovalRule_Call) Run(run func(pid interface{}, mergeRequest int, opt *gitlab.CreateMergeRequestApprovalRuleOptions, options ...gitlab.RequestOptionFunc)) *MergeRequestApprovalsServiceInterface_CreateApprovalRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.CreateMergeRequestApprovalRuleOptions), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestApprovalsServiceInterface_CreateApprovalRule_Call) Return(_a0 *gitlab.MergeRequestApprovalRule, _a1 *gitlab.Response, _a2 error) *MergeRequestApprovalsServiceInterface_CreateApprovalRule_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestApprovalsServiceInterface_CreateApprovalRule_Call) RunAndReturn(run func(interface{}, int, *gitlab.CreateMergeRequestApprovalRuleOptions, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequestApprovalRule, *gitlab.Response, error)) *MergeRequestApprovalsServiceInterface_CreateApprovalRule_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteApprovalRule provides a mock function with given fields: pid, mergeRequest, approvalRule, options
func (_m *MergeRequestApprovalsServiceInterface) DeleteApprovalRule(pid interface{}, mergeRequest int, approvalRule int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, approvalRule)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteApprovalRule")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, approvalRule, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, mergeRequest, approvalRule, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, mergeRequest, approvalRule, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MergeRequestApprovalsServiceInterface_DeleteApprovalRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteApprovalRule'
type MergeRequestApprovalsServiceInterface_DeleteApprovalRule_Call struct {
	*mock.Call
}

// DeleteApprovalRule is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - approvalRule int
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestApprovalsServiceInterface_Expecter) DeleteApprovalRule(pid interface{}, mergeRequest interface{}, approvalRule interface{}, options ...interface{}) *MergeRequestApprovalsServiceInterface_DeleteApprovalRule_Call {
	return &MergeRequestApprovalsServiceInterface_DeleteApprovalRule_Call{Call: _e.mock.On("DeleteApprovalRule",
		append([]interface{}{pid, mergeRequest, approvalRule}, options...)...)}
}

func (_c *MergeRequestApprovalsServiceInterface_DeleteApprovalRule_Call) Run(run func(pid interface{}, mergeRequest int, approvalRule int, options ...gitlab.RequestOptionFunc)) *MergeRequestApprovalsServiceInterface_DeleteApprovalRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestApprovalsServiceInterface_DeleteApprovalRule_Call) Return(_a0 *gitlab.Response, _a1 error) *MergeRequestApprovalsServiceInterface_DeleteApprovalRule_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MergeRequestApprovalsServiceInterface_DeleteApprovalRule_Call) RunAndReturn(run func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MergeRequestApprovalsServiceInterface_DeleteApprovalRule_Call {
	_c.Call.Return(run)
	return _c
}

// GetApprovalRules provides a mock function with given fields: pid, mergeRequest, options
func (_m *MergeRequestApprovalsServiceInterface) GetApprovalRules(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequestApprovalRule, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetApprovalRules")
	}

	var r0 []*gitlab.MergeRequestApprovalRule
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequestApprovalRule, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) []*gitlab.MergeRequestApprovalRule); ok {
		r0 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.MergeRequestApprovalRule)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestApprovalsServiceInterface_GetApprovalRules_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetApprovalRules'
type MergeRequestApprovalsServiceInterface_GetApprovalRules_Call struct {
	*mock.Call
}

// GetApprovalRules is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestApprovalsServiceInterface_Expecter) GetApprovalRules(pid interface{}, mergeRequest interface{}, options ...interface{}) *MergeRequestApprovalsServiceInterface_GetApprovalRules_Call {
	return &MergeRequestApprovalsServiceInterface_GetApprovalRules_Call{Call: _e.mock.On("GetApprovalRules",
		append([]interface{}{pid, mergeRequest}, options...)...)}
}

func (_c *MergeRequestApprovalsServiceInterface_GetApprovalRules_Call) Run(run func(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc)) *MergeRequestApprovalsServiceInterface_GetApprovalRules_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestApprovalsServiceInterface_GetApprovalRules_Call) Return(_a0 []*gitlab.MergeRequestApprovalRule, _a1 *gitlab.Response, _a2 error) *MergeRequestApprovalsServiceInterface_GetApprovalRules_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestApprovalsServiceInterface_GetApprovalRules_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequestApprovalRule, *gitlab.Response, error)) *MergeRequestApprovalsServiceInterface_GetApprovalRules_Call {
	_c.Call.Return(run)
	return _c
}

// GetApprovalState provides a mock function with given fields: pid, mergeRequest, options
func (_m *MergeRequestApprovalsServiceInterface) GetApprovalState(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc) (*gitlab.MergeRequestApprovalState, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetApprovalState")
	}

	var r0 *gitlab.MergeRequestApprovalState
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequestApprovalState, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.MergeRequestApprovalState); ok {
		r0 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.MergeRequestApprovalState)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestApprovalsServiceInterface_GetApprovalState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetApprovalState'
type MergeRequestApprovalsServiceInterface_GetApprovalState_Call struct {
	*mock.Call
}

// GetApprovalState is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestApprovalsServiceInterface_Expecter) GetApprovalState(pid interface{}, mergeRequest interface{}, options ...interface{}) *MergeRequestApprovalsServiceInterface_GetApprovalState_Call {
	return &MergeRequestApprovalsServiceInterface_GetApprovalState_Call{Call: _e.mock.On("GetApprovalState",
		append([]interface{}{pid, mergeRequest}, options...)...)}
}

func (_c *MergeRequestApprovalsServiceInterface_GetApprovalState_Call) Run(run func(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc)) *MergeRequestApprovalsServiceInterface_GetApprovalState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestApprovalsServiceInterface_GetApprovalState_Call) Return(_a0 *gitlab.MergeRequestApprovalState, _a1 *gitlab.Response, _a2 error) *MergeRequestApprovalsServiceInterface_GetApprovalState_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestApprovalsServiceInterface_GetApprovalState_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequestApprovalState, *gitlab.Response, error)) *MergeRequestApprovalsServiceInterface_GetApprovalState_Call {
	_c.Call.Return(run)
	return _c
}

// GetConfiguration provides a mock function with given fields: pid, mr, options
func (_m *MergeRequestApprovalsServiceInterface) GetConfiguration(pid interface{}, mr int, options ...gitlab.RequestOptionFunc) (*gitlab.MergeRequestApprovals, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mr)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetConfiguration")
	}

	var r0 *gitlab.MergeRequestApprovals
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequestApprovals, *gitlab.Response, error)); ok {
		return rf(pid, mr, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.MergeRequestApprovals); ok {
		r0 = rf(pid, mr, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.MergeRequestApprovals)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mr, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mr, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestApprovalsServiceInterface_GetConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetConfiguration'
type MergeRequestApprovalsServiceInterface_GetConfiguration_Call struct {
	*mock.Call
}

// GetConfiguration is a helper method to define mock.On call
//   - pid interface{}
//   - mr int
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestApprovalsServiceInterface_Expecter) GetConfiguration(pid interface{}, mr interface{}, options ...interface{}) *MergeRequestApprovalsServiceInterface_GetConfiguration_Call {
	return &MergeRequestApprovalsServiceInterface_GetConfiguration_Call{Call: _e.mock.On("GetConfiguration",
		append([]interface{}{pid, mr}, options...)...)}
}

func (_c *MergeRequestApprovalsServiceInterface_GetConfiguration_Call) Run(run func(pid interface{}, mr int, options ...gitlab.RequestOptionFunc)) *MergeRequestApprovalsServiceInterface_GetConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestApprovalsServiceInterface_GetConfiguration_Call) Return(_a0 *gitlab.MergeRequestApprovals, _a1 *gitlab.Response, _a2 error) *MergeRequestApprovalsServiceInterface_GetConfiguration_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestApprovalsServiceInterface_GetConfiguration_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequestApprovals, *gitlab.Response, error)) *MergeRequestApprovalsServiceInterface_GetConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// ResetApprovalsOfMergeRequest provides a mock function with given fields: pid, mr, options
func (_m *MergeRequestApprovalsServiceInterface) ResetApprovalsOfMergeRequest(pid interface{}, mr int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mr)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetApprovalsOfMergeRequest")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, mr, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, mr, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, mr, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MergeRequestApprovalsServiceInterface_ResetApprovalsOfMergeRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResetApprovalsOfMergeRequest'
type MergeRequestApprovalsServiceInterface_ResetApprovalsOfMergeRequest_Call struct {
	*mock.Call
}

// ResetApprovalsOfMergeRequest is a helper method to define mock.On call
//   - pid interface{}
//   - mr int
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestApprovalsServiceInterface_Expecter) ResetApprovalsOfMergeRequest(pid interface{}, mr interface{}, options ...interface{}) *MergeRequestApprovalsServiceInterface_ResetApprovalsOfMergeRequest_Call {
	return &MergeRequestApprovalsServiceInterface_ResetApprovalsOfMergeRequest_Call{Call: _e.mock.On("ResetApprovalsOfMergeRequest",
		append([]interface{}{pid, mr}, options...)...)}
}

func (_c *MergeRequestApprovalsServiceInterface_ResetApprovalsOfMergeRequest_Call) Run(run func(pid interface{}, mr int, options ...gitlab.RequestOptionFunc)) *MergeRequestApprovalsServiceInterface_ResetApprovalsOfMergeRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestApprovalsServiceInterface_ResetApprovalsOfMergeRequest_Call) Return(_a0 *gitlab.Response, _a1 error) *MergeRequestApprovalsServiceInterface_ResetApprovalsOfMergeRequest_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MergeRequestApprovalsServiceInterface_ResetApprovalsOfMergeRequest_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MergeRequestApprovalsServiceInterface_ResetApprovalsOfMergeRequest_Call {
	_c.Call.Return(run)
	return _c
}

// UnapproveMergeRequest provides a mock function with given fields: pid, mr, options
func (_m *MergeRequestApprovalsServiceInterface) UnapproveMergeRequest(pid interface{}, mr int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mr)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnapproveMergeRequest")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, mr, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, mr, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, mr, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MergeRequestApprovalsServiceInterface_UnapproveMergeRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnapproveMergeRequest'
type MergeRequestApprovalsServiceInterface_UnapproveMergeRequest_Call struct {
	*mock.Call
}

// UnapproveMergeRequest is a helper method to define mock.On call
//   - pid interface{}
//   - mr int
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestApprovalsServiceInterface_Expecter) UnapproveMergeRequest(pid interface{}, mr interface{}, options ...interface{}) *MergeRequestApprovalsServiceInterface_UnapproveMergeRequest_Call {
	return &MergeRequestApprovalsServiceInterface_UnapproveMergeRequest_Call{Call: _e.mock.On("UnapproveMergeRequest",
		append([]interface{}{pid, mr}, options...)...)}
}

func (_c *MergeRequestApprovalsServiceInterface_UnapproveMergeRequest_Call) Run(run func(pid interface{}, mr int, options ...gitlab.RequestOptionFunc)) *MergeRequestApprovalsServiceInterface_UnapproveMergeRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestApprovalsServiceInterface_UnapproveMergeRequest_Call) Return(_a0 *gitlab.Response, _a1 error) *MergeRequestApprovalsServiceInterface_UnapproveMergeRequest_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MergeRequestApprovalsServiceInterface_UnapproveMergeRequest_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MergeRequestApprovalsServiceInterface_UnapproveMergeRequest_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateApprovalRule provides a mock function with given fields: pid, mergeRequest, approvalRule, opt, options
func (_m *MergeRequestApprovalsServiceInterface) UpdateApprovalRule(pid interface{}, mergeRequest int, approvalRule int, opt *gitlab.UpdateMergeRequestApprovalRuleOptions, options ...gitlab.RequestOptionFunc) (*gitlab.MergeRequestApprovalRule, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, approvalRule, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateApprovalRule")
	}

	var r0 *gitlab.MergeRequestApprovalRule
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, *gitlab.UpdateMergeRequestApprovalRuleOptions, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequestApprovalRule, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, approvalRule, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, *gitlab.UpdateMergeRequestApprovalRuleOptions, ...gitlab.RequestOptionFunc) *gitlab.MergeRequestApprovalRule); ok {
		r0 = rf(pid, mergeRequest, approvalRule, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.MergeRequestApprovalRule)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, *gitlab.UpdateMergeRequestApprovalRuleOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, approvalRule, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, int, *gitlab.UpdateMergeRequestApprovalRuleOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, approvalRule, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestApprovalsServiceInterface_UpdateApprovalRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateApprovalRule'
type MergeRequestApprovalsServiceInterface_UpdateApprovalRule_Call struct {
	*mock.Call
}

// UpdateApprovalRule is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - approvalRule int
//   - opt *gitlab.UpdateMergeRequestApprovalRuleOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestApprovalsServiceInterface_Expecter) UpdateApprovalRule(pid interface{}, mergeRequest interface{}, approvalRule interface{}, opt interface{}, options ...interface{}) *MergeRequestApprovalsServiceInterface_UpdateApprovalRule_Call {
	return &MergeRequestApprovalsServiceInterface_UpdateApprovalRule_Call{Call: _e.mock.On("UpdateApprovalRule",
		append([]interface{}{pid, mergeRequest, approvalRule, opt}, options...)...)}
}

func (_c *MergeRequestApprovalsServiceInterface_UpdateApprovalRule_Call) Run(run func(pid interface{}, mergeRequest int, approvalRule int, opt *gitlab.UpdateMergeRequestApprovalRuleOptions, options ...gitlab.RequestOptionFunc)) *MergeRequestApprovalsServiceInterface_UpdateApprovalRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), args[3].(*gitlab.UpdateMergeRequestApprovalRuleOptions), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestApprovalsServiceInterface_UpdateApprovalRule_Call) Return(_a0 *gitlab.MergeRequestApprovalRule, _a1 *gitlab.Response, _a2 error) *MergeRequestApprovalsServiceInterface_UpdateApprovalRule_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestApprovalsServiceInterface_UpdateApprovalRule_Call) RunAndReturn(run func(interface{}, int, int, *gitlab.UpdateMergeRequestApprovalRuleOptions, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequestApprovalRule, *gitlab.Response, error)) *MergeRequestApprovalsServiceInterface_UpdateApprovalRule_Call {
	_c.Call.Return(run)
	return _c
}

// NewMergeRequestApprovalsServiceInterface creates a new instance of MergeRequestApprovalsServiceInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMergeRequestApprovalsServiceInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *MergeRequestApprovalsServiceInterface {
	mock := &MergeRequestApprovalsServiceInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

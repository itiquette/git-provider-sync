// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"
	gitlab "gitlab.com/gitlab-org/api/client-go"
)

// PipelinesServiceInterface is an autogenerated mock type for the PipelinesServiceInterface type
type PipelinesServiceInterface struct {
	mock.Mock
}

type PipelinesServiceInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *PipelinesServiceInterface) EXPECT() *PipelinesServiceInterface_Expecter {
	return &PipelinesServiceInterface_Expecter{mock: &_m.Mock}
}

// CancelPipelineBuild provides a mock function with given fields: pid, pipeline, options
func (_m *PipelinesServiceInterface) CancelPipelineBuild(pid interface{}, pipeline int, options ...gitlab.RequestOptionFunc) (*gitlab.Pipeline, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, pipeline)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelPipelineBuild")
	}

	var r0 *gitlab.Pipeline
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Pipeline, *gitlab.Response, error)); ok {
		return rf(pid, pipeline, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Pipeline); ok {
		r0 = rf(pid, pipeline, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Pipeline)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, pipeline, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, pipeline, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PipelinesServiceInterface_CancelPipelineBuild_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelPipelineBuild'
type PipelinesServiceInterface_CancelPipelineBuild_Call struct {
	*mock.Call
}

// CancelPipelineBuild is a helper method to define mock.On call
//   - pid interface{}
//   - pipeline int
//   - options ...gitlab.RequestOptionFunc
func (_e *PipelinesServiceInterface_Expecter) CancelPipelineBuild(pid interface{}, pipeline interface{}, options ...interface{}) *PipelinesServiceInterface_CancelPipelineBuild_Call {
	return &PipelinesServiceInterface_CancelPipelineBuild_Call{Call: _e.mock.On("CancelPipelineBuild",
		append([]interface{}{pid, pipeline}, options...)...)}
}

func (_c *PipelinesServiceInterface_CancelPipelineBuild_Call) Run(run func(pid interface{}, pipeline int, options ...gitlab.RequestOptionFunc)) *PipelinesServiceInterface_CancelPipelineBuild_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *PipelinesServiceInterface_CancelPipelineBuild_Call) Return(_a0 *gitlab.Pipeline, _a1 *gitlab.Response, _a2 error) *PipelinesServiceInterface_CancelPipelineBuild_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *PipelinesServiceInterface_CancelPipelineBuild_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Pipeline, *gitlab.Response, error)) *PipelinesServiceInterface_CancelPipelineBuild_Call {
	_c.Call.Return(run)
	return _c
}

// CreatePipeline provides a mock function with given fields: pid, opt, options
func (_m *PipelinesServiceInterface) CreatePipeline(pid interface{}, opt *gitlab.CreatePipelineOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Pipeline, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePipeline")
	}

	var r0 *gitlab.Pipeline
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.CreatePipelineOptions, ...gitlab.RequestOptionFunc) (*gitlab.Pipeline, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.CreatePipelineOptions, ...gitlab.RequestOptionFunc) *gitlab.Pipeline); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Pipeline)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.CreatePipelineOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.CreatePipelineOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PipelinesServiceInterface_CreatePipeline_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePipeline'
type PipelinesServiceInterface_CreatePipeline_Call struct {
	*mock.Call
}

// CreatePipeline is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.CreatePipelineOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *PipelinesServiceInterface_Expecter) CreatePipeline(pid interface{}, opt interface{}, options ...interface{}) *PipelinesServiceInterface_CreatePipeline_Call {
	return &PipelinesServiceInterface_CreatePipeline_Call{Call: _e.mock.On("CreatePipeline",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *PipelinesServiceInterface_CreatePipeline_Call) Run(run func(pid interface{}, opt *gitlab.CreatePipelineOptions, options ...gitlab.RequestOptionFunc)) *PipelinesServiceInterface_CreatePipeline_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.CreatePipelineOptions), variadicArgs...)
	})
	return _c
}

func (_c *PipelinesServiceInterface_CreatePipeline_Call) Return(_a0 *gitlab.Pipeline, _a1 *gitlab.Response, _a2 error) *PipelinesServiceInterface_CreatePipeline_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *PipelinesServiceInterface_CreatePipeline_Call) RunAndReturn(run func(interface{}, *gitlab.CreatePipelineOptions, ...gitlab.RequestOptionFunc) (*gitlab.Pipeline, *gitlab.Response, error)) *PipelinesServiceInterface_CreatePipeline_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePipeline provides a mock function with given fields: pid, pipeline, options
func (_m *PipelinesServiceInterface) DeletePipeline(pid interface{}, pipeline int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, pipeline)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePipeline")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, pipeline, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, pipeline, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, pipeline, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PipelinesServiceInterface_DeletePipeline_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePipeline'
type PipelinesServiceInterface_DeletePipeline_Call struct {
	*mock.Call
}

// DeletePipeline is a helper method to define mock.On call
//   - pid interface{}
//   - pipeline int
//   - options ...gitlab.RequestOptionFunc
func (_e *PipelinesServiceInterface_Expecter) DeletePipeline(pid interface{}, pipeline interface{}, options ...interface{}) *PipelinesServiceInterface_DeletePipeline_Call {
	return &PipelinesServiceInterface_DeletePipeline_Call{Call: _e.mock.On("DeletePipeline",
		append([]interface{}{pid, pipeline}, options...)...)}
}

func (_c *PipelinesServiceInterface_DeletePipeline_Call) Run(run func(pid interface{}, pipeline int, options ...gitlab.RequestOptionFunc)) *PipelinesServiceInterface_DeletePipeline_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *PipelinesServiceInterface_DeletePipeline_Call) Return(_a0 *gitlab.Response, _a1 error) *PipelinesServiceInterface_DeletePipeline_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *PipelinesServiceInterface_DeletePipeline_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *PipelinesServiceInterface_DeletePipeline_Call {
	_c.Call.Return(run)
	return _c
}

// GetLatestPipeline provides a mock function with given fields: pid, opt, options
func (_m *PipelinesServiceInterface) GetLatestPipeline(pid interface{}, opt *gitlab.GetLatestPipelineOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Pipeline, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestPipeline")
	}

	var r0 *gitlab.Pipeline
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.GetLatestPipelineOptions, ...gitlab.RequestOptionFunc) (*gitlab.Pipeline, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.GetLatestPipelineOptions, ...gitlab.RequestOptionFunc) *gitlab.Pipeline); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Pipeline)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.GetLatestPipelineOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.GetLatestPipelineOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PipelinesServiceInterface_GetLatestPipeline_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestPipeline'
type PipelinesServiceInterface_GetLatestPipeline_Call struct {
	*mock.Call
}

// GetLatestPipeline is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.GetLatestPipelineOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *PipelinesServiceInterface_Expecter) GetLatestPipeline(pid interface{}, opt interface{}, options ...interface{}) *PipelinesServiceInterface_GetLatestPipeline_Call {
	return &PipelinesServiceInterface_GetLatestPipeline_Call{Call: _e.mock.On("GetLatestPipeline",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *PipelinesServiceInterface_GetLatestPipeline_Call) Run(run func(pid interface{}, opt *gitlab.GetLatestPipelineOptions, options ...gitlab.RequestOptionFunc)) *PipelinesServiceInterface_GetLatestPipeline_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.GetLatestPipelineOptions), variadicArgs...)
	})
	return _c
}

func (_c *PipelinesServiceInterface_GetLatestPipeline_Call) Return(_a0 *gitlab.Pipeline, _a1 *gitlab.Response, _a2 error) *PipelinesServiceInterface_GetLatestPipeline_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *PipelinesServiceInterface_GetLatestPipeline_Call) RunAndReturn(run func(interface{}, *gitlab.GetLatestPipelineOptions, ...gitlab.RequestOptionFunc) (*gitlab.Pipeline, *gitlab.Response, error)) *PipelinesServiceInterface_GetLatestPipeline_Call {
	_c.Call.Return(run)
	return _c
}

// GetPipeline provides a mock function with given fields: pid, pipeline, options
func (_m *PipelinesServiceInterface) GetPipeline(pid interface{}, pipeline int, options ...gitlab.RequestOptionFunc) (*gitlab.Pipeline, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, pipeline)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPipeline")
	}

	var r0 *gitlab.Pipeline
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Pipeline, *gitlab.Response, error)); ok {
		return rf(pid, pipeline, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Pipeline); ok {
		r0 = rf(pid, pipeline, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Pipeline)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, pipeline, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, pipeline, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PipelinesServiceInterface_GetPipeline_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPipeline'
type PipelinesServiceInterface_GetPipeline_Call struct {
	*mock.Call
}

// GetPipeline is a helper method to define mock.On call
//   - pid interface{}
//   - pipeline int
//   - options ...gitlab.RequestOptionFunc
func (_e *PipelinesServiceInterface_Expecter) GetPipeline(pid interface{}, pipeline interface{}, options ...interface{}) *PipelinesServiceInterface_GetPipeline_Call {
	return &PipelinesServiceInterface_GetPipeline_Call{Call: _e.mock.On("GetPipeline",
		append([]interface{}{pid, pipeline}, options...)...)}
}

func (_c *PipelinesServiceInterface_GetPipeline_Call) Run(run func(pid interface{}, pipeline int, options ...gitlab.RequestOptionFunc)) *PipelinesServiceInterface_GetPipeline_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *PipelinesServiceInterface_GetPipeline_Call) Return(_a0 *gitlab.Pipeline, _a1 *gitlab.Response, _a2 error) *PipelinesServiceInterface_GetPipeline_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *PipelinesServiceInterface_GetPipeline_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Pipeline, *gitlab.Response, error)) *PipelinesServiceInterface_GetPipeline_Call {
	_c.Call.Return(run)
	return _c
}

// GetPipelineTestReport provides a mock function with given fields: pid, pipeline, options
func (_m *PipelinesServiceInterface) GetPipelineTestReport(pid interface{}, pipeline int, options ...gitlab.RequestOptionFunc) (*gitlab.PipelineTestReport, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, pipeline)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPipelineTestReport")
	}

	var r0 *gitlab.PipelineTestReport
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.PipelineTestReport, *gitlab.Response, error)); ok {
		return rf(pid, pipeline, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.PipelineTestReport); ok {
		r0 = rf(pid, pipeline, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.PipelineTestReport)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, pipeline, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, pipeline, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PipelinesServiceInterface_GetPipelineTestReport_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPipelineTestReport'
type PipelinesServiceInterface_GetPipelineTestReport_Call struct {
	*mock.Call
}

// GetPipelineTestReport is a helper method to define mock.On call
//   - pid interface{}
//   - pipeline int
//   - options ...gitlab.RequestOptionFunc
func (_e *PipelinesServiceInterface_Expecter) GetPipelineTestReport(pid interface{}, pipeline interface{}, options ...interface{}) *PipelinesServiceInterface_GetPipelineTestReport_Call {
	return &PipelinesServiceInterface_GetPipelineTestReport_Call{Call: _e.mock.On("GetPipelineTestReport",
		append([]interface{}{pid, pipeline}, options...)...)}
}

func (_c *PipelinesServiceInterface_GetPipelineTestReport_Call) Run(run func(pid interface{}, pipeline int, options ...gitlab.RequestOptionFunc)) *PipelinesServiceInterface_GetPipelineTestReport_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *PipelinesServiceInterface_GetPipelineTestReport_Call) Return(_a0 *gitlab.PipelineTestReport, _a1 *gitlab.Response, _a2 error) *PipelinesServiceInterface_GetPipelineTestReport_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *PipelinesServiceInterface_GetPipelineTestReport_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.PipelineTestReport, *gitlab.Response, error)) *PipelinesServiceInterface_GetPipelineTestReport_Call {
	_c.Call.Return(run)
	return _c
}

// GetPipelineVariables provides a mock function with given fields: pid, pipeline, options
func (_m *PipelinesServiceInterface) GetPipelineVariables(pid interface{}, pipeline int, options ...gitlab.RequestOptionFunc) ([]*gitlab.PipelineVariable, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, pipeline)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPipelineVariables")
	}

	var r0 []*gitlab.PipelineVariable
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) ([]*gitlab.PipelineVariable, *gitlab.Response, error)); ok {
		return rf(pid, pipeline, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) []*gitlab.PipelineVariable); ok {
		r0 = rf(pid, pipeline, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.PipelineVariable)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, pipeline, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, pipeline, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PipelinesServiceInterface_GetPipelineVariables_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPipelineVariables'
type PipelinesServiceInterface_GetPipelineVariables_Call struct {
	*mock.Call
}

// GetPipelineVariables is a helper method to define mock.On call
//   - pid interface{}
//   - pipeline int
//   - options ...gitlab.RequestOptionFunc
func (_e *PipelinesServiceInterface_Expecter) GetPipelineVariables(pid interface{}, pipeline interface{}, options ...interface{}) *PipelinesServiceInterface_GetPipelineVariables_Call {
	return &PipelinesServiceInterface_GetPipelineVariables_Call{Call: _e.mock.On("GetPipelineVariables",
		append([]interface{}{pid, pipeline}, options...)...)}
}

func (_c *PipelinesServiceInterface_GetPipelineVariables_Call) Run(run func(pid interface{}, pipeline int, options ...gitlab.RequestOptionFunc)) *PipelinesServiceInterface_GetPipelineVariables_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *PipelinesServiceInterface_GetPipelineVariables_Call) Return(_a0 []*gitlab.PipelineVariable, _a1 *gitlab.Response, _a2 error) *PipelinesServiceInterface_GetPipelineVariables_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *PipelinesServiceInterface_GetPipelineVariables_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) ([]*gitlab.PipelineVariable, *gitlab.Response, error)) *PipelinesServiceInterface_GetPipelineVariables_Call {
	_c.Call.Return(run)
	return _c
}

// ListProjectPipelines provides a mock function with given fields: pid, opt, options
func (_m *PipelinesServiceInterface) ListProjectPipelines(pid interface{}, opt *gitlab.ListProjectPipelinesOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.PipelineInfo, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListProjectPipelines")
	}

	var r0 []*gitlab.PipelineInfo
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListProjectPipelinesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.PipelineInfo, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListProjectPipelinesOptions, ...gitlab.RequestOptionFunc) []*gitlab.PipelineInfo); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.PipelineInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListProjectPipelinesOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListProjectPipelinesOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PipelinesServiceInterface_ListProjectPipelines_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListProjectPipelines'
type PipelinesServiceInterface_ListProjectPipelines_Call struct {
	*mock.Call
}

// ListProjectPipelines is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.ListProjectPipelinesOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *PipelinesServiceInterface_Expecter) ListProjectPipelines(pid interface{}, opt interface{}, options ...interface{}) *PipelinesServiceInterface_ListProjectPipelines_Call {
	return &PipelinesServiceInterface_ListProjectPipelines_Call{Call: _e.mock.On("ListProjectPipelines",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *PipelinesServiceInterface_ListProjectPipelines_Call) Run(run func(pid interface{}, opt *gitlab.ListProjectPipelinesOptions, options ...gitlab.RequestOptionFunc)) *PipelinesServiceInterface_ListProjectPipelines_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListProjectPipelinesOptions), variadicArgs...)
	})
	return _c
}

func (_c *PipelinesServiceInterface_ListProjectPipelines_Call) Return(_a0 []*gitlab.PipelineInfo, _a1 *gitlab.Response, _a2 error) *PipelinesServiceInterface_ListProjectPipelines_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *PipelinesServiceInterface_ListProjectPipelines_Call) RunAndReturn(run func(interface{}, *gitlab.ListProjectPipelinesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.PipelineInfo, *gitlab.Response, error)) *PipelinesServiceInterface_ListProjectPipelines_Call {
	_c.Call.Return(run)
	return _c
}

// RetryPipelineBuild provides a mock function with given fields: pid, pipeline, options
func (_m *PipelinesServiceInterface) RetryPipelineBuild(pid interface{}, pipeline int, options ...gitlab.RequestOptionFunc) (*gitlab.Pipeline, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, pipeline)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RetryPipelineBuild")
	}

	var r0 *gitlab.Pipeline
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Pipeline, *gitlab.Response, error)); ok {
		return rf(pid, pipeline, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Pipeline); ok {
		r0 = rf(pid, pipeline, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Pipeline)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, pipeline, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, pipeline, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PipelinesServiceInterface_RetryPipelineBuild_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RetryPipelineBuild'
type PipelinesServiceInterface_RetryPipelineBuild_Call struct {
	*mock.Call
}

// RetryPipelineBuild is a helper method to define mock.On call
//   - pid interface{}
//   - pipeline int
//   - options ...gitlab.RequestOptionFunc
func (_e *PipelinesServiceInterface_Expecter) RetryPipelineBuild(pid interface{}, pipeline interface{}, options ...interface{}) *PipelinesServiceInterface_RetryPipelineBuild_Call {
	return &PipelinesServiceInterface_RetryPipelineBuild_Call{Call: _e.mock.On("RetryPipelineBuild",
		append([]interface{}{pid, pipeline}, options...)...)}
}

func (_c *PipelinesServiceInterface_RetryPipelineBuild_Call) Run(run func(pid interface{}, pipeline int, options ...gitlab.RequestOptionFunc)) *PipelinesServiceInterface_RetryPipelineBuild_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *PipelinesServiceInterface_RetryPipelineBuild_Call) Return(_a0 *gitlab.Pipeline, _a1 *gitlab.Response, _a2 error) *PipelinesServiceInterface_RetryPipelineBuild_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *PipelinesServiceInterface_RetryPipelineBuild_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Pipeline, *gitlab.Response, error)) *PipelinesServiceInterface_RetryPipelineBuild_Call {
	_c.Call.Return(run)
	return _c
}

// UpdatePipelineMetadata provides a mock function with given fields: pid, pipeline, opt, options
func (_m *PipelinesServiceInterface) UpdatePipelineMetadata(pid interface{}, pipeline int, opt *gitlab.UpdatePipelineMetadataOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Pipeline, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, pipeline, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdatePipelineMetadata")
	}

	var r0 *gitlab.Pipeline
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.UpdatePipelineMetadataOptions, ...gitlab.RequestOptionFunc) (*gitlab.Pipeline, *gitlab.Response, error)); ok {
		return rf(pid, pipeline, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.UpdatePipelineMetadataOptions, ...gitlab.RequestOptionFunc) *gitlab.Pipeline); ok {
		r0 = rf(pid, pipeline, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Pipeline)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.UpdatePipelineMetadataOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, pipeline, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.UpdatePipelineMetadataOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, pipeline, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PipelinesServiceInterface_UpdatePipelineMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdatePipelineMetadata'
type PipelinesServiceInterface_UpdatePipelineMetadata_Call struct {
	*mock.Call
}

// UpdatePipelineMetadata is a helper method to define mock.On call
//   - pid interface{}
//   - pipeline int
//   - opt *gitlab.UpdatePipelineMetadataOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *PipelinesServiceInterface_Expecter) UpdatePipelineMetadata(pid interface{}, pipeline interface{}, opt interface{}, options ...interface{}) *PipelinesServiceInterface_UpdatePipelineMetadata_Call {
	return &PipelinesServiceInterface_UpdatePipelineMetadata_Call{Call: _e.mock.On("UpdatePipelineMetadata",
		append([]interface{}{pid, pipeline, opt}, options...)...)}
}

func (_c *PipelinesServiceInterface_UpdatePipelineMetadata_Call) Run(run func(pid interface{}, pipeline int, opt *gitlab.UpdatePipelineMetadataOptions, options ...gitlab.RequestOptionFunc)) *PipelinesServiceInterface_UpdatePipelineMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.UpdatePipelineMetadataOptions), variadicArgs...)
	})
	return _c
}

func (_c *PipelinesServiceInterface_UpdatePipelineMetadata_Call) Return(_a0 *gitlab.Pipeline, _a1 *gitlab.Response, _a2 error) *PipelinesServiceInterface_UpdatePipelineMetadata_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *PipelinesServiceInterface_UpdatePipelineMetadata_Call) RunAndReturn(run func(interface{}, int, *gitlab.UpdatePipelineMetadataOptions, ...gitlab.RequestOptionFunc) (*gitlab.Pipeline, *gitlab.Response, error)) *PipelinesServiceInterface_UpdatePipelineMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// NewPipelinesServiceInterface creates a new instance of PipelinesServiceInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPipelinesServiceInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *PipelinesServiceInterface {
	mock := &PipelinesServiceInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

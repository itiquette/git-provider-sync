// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	bytes "bytes"
	io "io"

	gitlab "gitlab.com/gitlab-org/api/client-go"

	mock "github.com/stretchr/testify/mock"
)

// GroupsServiceInterface is an autogenerated mock type for the GroupsServiceInterface type
type GroupsServiceInterface struct {
	mock.Mock
}

type GroupsServiceInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *GroupsServiceInterface) EXPECT() *GroupsServiceInterface_Expecter {
	return &GroupsServiceInterface_Expecter{mock: &_m.Mock}
}

// AddGroupHook provides a mock function with given fields: gid, opt, options
func (_m *GroupsServiceInterface) AddGroupHook(gid interface{}, opt *gitlab.AddGroupHookOptions, options ...gitlab.RequestOptionFunc) (*gitlab.GroupHook, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddGroupHook")
	}

	var r0 *gitlab.GroupHook
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.AddGroupHookOptions, ...gitlab.RequestOptionFunc) (*gitlab.GroupHook, *gitlab.Response, error)); ok {
		return rf(gid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.AddGroupHookOptions, ...gitlab.RequestOptionFunc) *gitlab.GroupHook); ok {
		r0 = rf(gid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.GroupHook)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.AddGroupHookOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.AddGroupHookOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_AddGroupHook_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddGroupHook'
type GroupsServiceInterface_AddGroupHook_Call struct {
	*mock.Call
}

// AddGroupHook is a helper method to define mock.On call
//   - gid interface{}
//   - opt *gitlab.AddGroupHookOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) AddGroupHook(gid interface{}, opt interface{}, options ...interface{}) *GroupsServiceInterface_AddGroupHook_Call {
	return &GroupsServiceInterface_AddGroupHook_Call{Call: _e.mock.On("AddGroupHook",
		append([]interface{}{gid, opt}, options...)...)}
}

func (_c *GroupsServiceInterface_AddGroupHook_Call) Run(run func(gid interface{}, opt *gitlab.AddGroupHookOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_AddGroupHook_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.AddGroupHookOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_AddGroupHook_Call) Return(_a0 *gitlab.GroupHook, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_AddGroupHook_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_AddGroupHook_Call) RunAndReturn(run func(interface{}, *gitlab.AddGroupHookOptions, ...gitlab.RequestOptionFunc) (*gitlab.GroupHook, *gitlab.Response, error)) *GroupsServiceInterface_AddGroupHook_Call {
	_c.Call.Return(run)
	return _c
}

// AddGroupLDAPLink provides a mock function with given fields: gid, opt, options
func (_m *GroupsServiceInterface) AddGroupLDAPLink(gid interface{}, opt *gitlab.AddGroupLDAPLinkOptions, options ...gitlab.RequestOptionFunc) (*gitlab.LDAPGroupLink, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddGroupLDAPLink")
	}

	var r0 *gitlab.LDAPGroupLink
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.AddGroupLDAPLinkOptions, ...gitlab.RequestOptionFunc) (*gitlab.LDAPGroupLink, *gitlab.Response, error)); ok {
		return rf(gid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.AddGroupLDAPLinkOptions, ...gitlab.RequestOptionFunc) *gitlab.LDAPGroupLink); ok {
		r0 = rf(gid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.LDAPGroupLink)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.AddGroupLDAPLinkOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.AddGroupLDAPLinkOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_AddGroupLDAPLink_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddGroupLDAPLink'
type GroupsServiceInterface_AddGroupLDAPLink_Call struct {
	*mock.Call
}

// AddGroupLDAPLink is a helper method to define mock.On call
//   - gid interface{}
//   - opt *gitlab.AddGroupLDAPLinkOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) AddGroupLDAPLink(gid interface{}, opt interface{}, options ...interface{}) *GroupsServiceInterface_AddGroupLDAPLink_Call {
	return &GroupsServiceInterface_AddGroupLDAPLink_Call{Call: _e.mock.On("AddGroupLDAPLink",
		append([]interface{}{gid, opt}, options...)...)}
}

func (_c *GroupsServiceInterface_AddGroupLDAPLink_Call) Run(run func(gid interface{}, opt *gitlab.AddGroupLDAPLinkOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_AddGroupLDAPLink_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.AddGroupLDAPLinkOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_AddGroupLDAPLink_Call) Return(_a0 *gitlab.LDAPGroupLink, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_AddGroupLDAPLink_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_AddGroupLDAPLink_Call) RunAndReturn(run func(interface{}, *gitlab.AddGroupLDAPLinkOptions, ...gitlab.RequestOptionFunc) (*gitlab.LDAPGroupLink, *gitlab.Response, error)) *GroupsServiceInterface_AddGroupLDAPLink_Call {
	_c.Call.Return(run)
	return _c
}

// AddGroupPushRule provides a mock function with given fields: gid, opt, options
func (_m *GroupsServiceInterface) AddGroupPushRule(gid interface{}, opt *gitlab.AddGroupPushRuleOptions, options ...gitlab.RequestOptionFunc) (*gitlab.GroupPushRules, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddGroupPushRule")
	}

	var r0 *gitlab.GroupPushRules
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.AddGroupPushRuleOptions, ...gitlab.RequestOptionFunc) (*gitlab.GroupPushRules, *gitlab.Response, error)); ok {
		return rf(gid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.AddGroupPushRuleOptions, ...gitlab.RequestOptionFunc) *gitlab.GroupPushRules); ok {
		r0 = rf(gid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.GroupPushRules)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.AddGroupPushRuleOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.AddGroupPushRuleOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_AddGroupPushRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddGroupPushRule'
type GroupsServiceInterface_AddGroupPushRule_Call struct {
	*mock.Call
}

// AddGroupPushRule is a helper method to define mock.On call
//   - gid interface{}
//   - opt *gitlab.AddGroupPushRuleOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) AddGroupPushRule(gid interface{}, opt interface{}, options ...interface{}) *GroupsServiceInterface_AddGroupPushRule_Call {
	return &GroupsServiceInterface_AddGroupPushRule_Call{Call: _e.mock.On("AddGroupPushRule",
		append([]interface{}{gid, opt}, options...)...)}
}

func (_c *GroupsServiceInterface_AddGroupPushRule_Call) Run(run func(gid interface{}, opt *gitlab.AddGroupPushRuleOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_AddGroupPushRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.AddGroupPushRuleOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_AddGroupPushRule_Call) Return(_a0 *gitlab.GroupPushRules, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_AddGroupPushRule_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_AddGroupPushRule_Call) RunAndReturn(run func(interface{}, *gitlab.AddGroupPushRuleOptions, ...gitlab.RequestOptionFunc) (*gitlab.GroupPushRules, *gitlab.Response, error)) *GroupsServiceInterface_AddGroupPushRule_Call {
	_c.Call.Return(run)
	return _c
}

// AddGroupSAMLLink provides a mock function with given fields: gid, opt, options
func (_m *GroupsServiceInterface) AddGroupSAMLLink(gid interface{}, opt *gitlab.AddGroupSAMLLinkOptions, options ...gitlab.RequestOptionFunc) (*gitlab.SAMLGroupLink, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddGroupSAMLLink")
	}

	var r0 *gitlab.SAMLGroupLink
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.AddGroupSAMLLinkOptions, ...gitlab.RequestOptionFunc) (*gitlab.SAMLGroupLink, *gitlab.Response, error)); ok {
		return rf(gid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.AddGroupSAMLLinkOptions, ...gitlab.RequestOptionFunc) *gitlab.SAMLGroupLink); ok {
		r0 = rf(gid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.SAMLGroupLink)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.AddGroupSAMLLinkOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.AddGroupSAMLLinkOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_AddGroupSAMLLink_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddGroupSAMLLink'
type GroupsServiceInterface_AddGroupSAMLLink_Call struct {
	*mock.Call
}

// AddGroupSAMLLink is a helper method to define mock.On call
//   - gid interface{}
//   - opt *gitlab.AddGroupSAMLLinkOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) AddGroupSAMLLink(gid interface{}, opt interface{}, options ...interface{}) *GroupsServiceInterface_AddGroupSAMLLink_Call {
	return &GroupsServiceInterface_AddGroupSAMLLink_Call{Call: _e.mock.On("AddGroupSAMLLink",
		append([]interface{}{gid, opt}, options...)...)}
}

func (_c *GroupsServiceInterface_AddGroupSAMLLink_Call) Run(run func(gid interface{}, opt *gitlab.AddGroupSAMLLinkOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_AddGroupSAMLLink_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.AddGroupSAMLLinkOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_AddGroupSAMLLink_Call) Return(_a0 *gitlab.SAMLGroupLink, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_AddGroupSAMLLink_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_AddGroupSAMLLink_Call) RunAndReturn(run func(interface{}, *gitlab.AddGroupSAMLLinkOptions, ...gitlab.RequestOptionFunc) (*gitlab.SAMLGroupLink, *gitlab.Response, error)) *GroupsServiceInterface_AddGroupSAMLLink_Call {
	_c.Call.Return(run)
	return _c
}

// CreateGroup provides a mock function with given fields: opt, options
func (_m *GroupsServiceInterface) CreateGroup(opt *gitlab.CreateGroupOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Group, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateGroup")
	}

	var r0 *gitlab.Group
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(*gitlab.CreateGroupOptions, ...gitlab.RequestOptionFunc) (*gitlab.Group, *gitlab.Response, error)); ok {
		return rf(opt, options...)
	}
	if rf, ok := ret.Get(0).(func(*gitlab.CreateGroupOptions, ...gitlab.RequestOptionFunc) *gitlab.Group); ok {
		r0 = rf(opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(*gitlab.CreateGroupOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(*gitlab.CreateGroupOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_CreateGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateGroup'
type GroupsServiceInterface_CreateGroup_Call struct {
	*mock.Call
}

// CreateGroup is a helper method to define mock.On call
//   - opt *gitlab.CreateGroupOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) CreateGroup(opt interface{}, options ...interface{}) *GroupsServiceInterface_CreateGroup_Call {
	return &GroupsServiceInterface_CreateGroup_Call{Call: _e.mock.On("CreateGroup",
		append([]interface{}{opt}, options...)...)}
}

func (_c *GroupsServiceInterface_CreateGroup_Call) Run(run func(opt *gitlab.CreateGroupOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_CreateGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(*gitlab.CreateGroupOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_CreateGroup_Call) Return(_a0 *gitlab.Group, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_CreateGroup_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_CreateGroup_Call) RunAndReturn(run func(*gitlab.CreateGroupOptions, ...gitlab.RequestOptionFunc) (*gitlab.Group, *gitlab.Response, error)) *GroupsServiceInterface_CreateGroup_Call {
	_c.Call.Return(run)
	return _c
}

// CreateServiceAccount provides a mock function with given fields: gid, opt, options
func (_m *GroupsServiceInterface) CreateServiceAccount(gid interface{}, opt *gitlab.CreateServiceAccountOptions, options ...gitlab.RequestOptionFunc) (*gitlab.GroupServiceAccount, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateServiceAccount")
	}

	var r0 *gitlab.GroupServiceAccount
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.CreateServiceAccountOptions, ...gitlab.RequestOptionFunc) (*gitlab.GroupServiceAccount, *gitlab.Response, error)); ok {
		return rf(gid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.CreateServiceAccountOptions, ...gitlab.RequestOptionFunc) *gitlab.GroupServiceAccount); ok {
		r0 = rf(gid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.GroupServiceAccount)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.CreateServiceAccountOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.CreateServiceAccountOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_CreateServiceAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateServiceAccount'
type GroupsServiceInterface_CreateServiceAccount_Call struct {
	*mock.Call
}

// CreateServiceAccount is a helper method to define mock.On call
//   - gid interface{}
//   - opt *gitlab.CreateServiceAccountOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) CreateServiceAccount(gid interface{}, opt interface{}, options ...interface{}) *GroupsServiceInterface_CreateServiceAccount_Call {
	return &GroupsServiceInterface_CreateServiceAccount_Call{Call: _e.mock.On("CreateServiceAccount",
		append([]interface{}{gid, opt}, options...)...)}
}

func (_c *GroupsServiceInterface_CreateServiceAccount_Call) Run(run func(gid interface{}, opt *gitlab.CreateServiceAccountOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_CreateServiceAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.CreateServiceAccountOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_CreateServiceAccount_Call) Return(_a0 *gitlab.GroupServiceAccount, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_CreateServiceAccount_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_CreateServiceAccount_Call) RunAndReturn(run func(interface{}, *gitlab.CreateServiceAccountOptions, ...gitlab.RequestOptionFunc) (*gitlab.GroupServiceAccount, *gitlab.Response, error)) *GroupsServiceInterface_CreateServiceAccount_Call {
	_c.Call.Return(run)
	return _c
}

// CreateServiceAccountPersonalAccessToken provides a mock function with given fields: gid, serviceAccount, opt, options
func (_m *GroupsServiceInterface) CreateServiceAccountPersonalAccessToken(gid interface{}, serviceAccount int, opt *gitlab.CreateServiceAccountPersonalAccessTokenOptions, options ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, serviceAccount, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateServiceAccountPersonalAccessToken")
	}

	var r0 *gitlab.PersonalAccessToken
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.CreateServiceAccountPersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error)); ok {
		return rf(gid, serviceAccount, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.CreateServiceAccountPersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) *gitlab.PersonalAccessToken); ok {
		r0 = rf(gid, serviceAccount, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.PersonalAccessToken)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.CreateServiceAccountPersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, serviceAccount, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.CreateServiceAccountPersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, serviceAccount, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_CreateServiceAccountPersonalAccessToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateServiceAccountPersonalAccessToken'
type GroupsServiceInterface_CreateServiceAccountPersonalAccessToken_Call struct {
	*mock.Call
}

// CreateServiceAccountPersonalAccessToken is a helper method to define mock.On call
//   - gid interface{}
//   - serviceAccount int
//   - opt *gitlab.CreateServiceAccountPersonalAccessTokenOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) CreateServiceAccountPersonalAccessToken(gid interface{}, serviceAccount interface{}, opt interface{}, options ...interface{}) *GroupsServiceInterface_CreateServiceAccountPersonalAccessToken_Call {
	return &GroupsServiceInterface_CreateServiceAccountPersonalAccessToken_Call{Call: _e.mock.On("CreateServiceAccountPersonalAccessToken",
		append([]interface{}{gid, serviceAccount, opt}, options...)...)}
}

func (_c *GroupsServiceInterface_CreateServiceAccountPersonalAccessToken_Call) Run(run func(gid interface{}, serviceAccount int, opt *gitlab.CreateServiceAccountPersonalAccessTokenOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_CreateServiceAccountPersonalAccessToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.CreateServiceAccountPersonalAccessTokenOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_CreateServiceAccountPersonalAccessToken_Call) Return(_a0 *gitlab.PersonalAccessToken, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_CreateServiceAccountPersonalAccessToken_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_CreateServiceAccountPersonalAccessToken_Call) RunAndReturn(run func(interface{}, int, *gitlab.CreateServiceAccountPersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error)) *GroupsServiceInterface_CreateServiceAccountPersonalAccessToken_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteGroup provides a mock function with given fields: gid, opt, options
func (_m *GroupsServiceInterface) DeleteGroup(gid interface{}, opt *gitlab.DeleteGroupOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGroup")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.DeleteGroupOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(gid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.DeleteGroupOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(gid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.DeleteGroupOptions, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(gid, opt, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupsServiceInterface_DeleteGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteGroup'
type GroupsServiceInterface_DeleteGroup_Call struct {
	*mock.Call
}

// DeleteGroup is a helper method to define mock.On call
//   - gid interface{}
//   - opt *gitlab.DeleteGroupOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) DeleteGroup(gid interface{}, opt interface{}, options ...interface{}) *GroupsServiceInterface_DeleteGroup_Call {
	return &GroupsServiceInterface_DeleteGroup_Call{Call: _e.mock.On("DeleteGroup",
		append([]interface{}{gid, opt}, options...)...)}
}

func (_c *GroupsServiceInterface_DeleteGroup_Call) Run(run func(gid interface{}, opt *gitlab.DeleteGroupOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_DeleteGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.DeleteGroupOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_DeleteGroup_Call) Return(_a0 *gitlab.Response, _a1 error) *GroupsServiceInterface_DeleteGroup_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GroupsServiceInterface_DeleteGroup_Call) RunAndReturn(run func(interface{}, *gitlab.DeleteGroupOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *GroupsServiceInterface_DeleteGroup_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteGroupCustomHeader provides a mock function with given fields: gid, hook, key, options
func (_m *GroupsServiceInterface) DeleteGroupCustomHeader(gid interface{}, hook int, key string, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, hook, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGroupCustomHeader")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(gid, hook, key, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(gid, hook, key, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(gid, hook, key, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupsServiceInterface_DeleteGroupCustomHeader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteGroupCustomHeader'
type GroupsServiceInterface_DeleteGroupCustomHeader_Call struct {
	*mock.Call
}

// DeleteGroupCustomHeader is a helper method to define mock.On call
//   - gid interface{}
//   - hook int
//   - key string
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) DeleteGroupCustomHeader(gid interface{}, hook interface{}, key interface{}, options ...interface{}) *GroupsServiceInterface_DeleteGroupCustomHeader_Call {
	return &GroupsServiceInterface_DeleteGroupCustomHeader_Call{Call: _e.mock.On("DeleteGroupCustomHeader",
		append([]interface{}{gid, hook, key}, options...)...)}
}

func (_c *GroupsServiceInterface_DeleteGroupCustomHeader_Call) Run(run func(gid interface{}, hook int, key string, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_DeleteGroupCustomHeader_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_DeleteGroupCustomHeader_Call) Return(_a0 *gitlab.Response, _a1 error) *GroupsServiceInterface_DeleteGroupCustomHeader_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GroupsServiceInterface_DeleteGroupCustomHeader_Call) RunAndReturn(run func(interface{}, int, string, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *GroupsServiceInterface_DeleteGroupCustomHeader_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteGroupHook provides a mock function with given fields: gid, hook, options
func (_m *GroupsServiceInterface) DeleteGroupHook(gid interface{}, hook int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, hook)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGroupHook")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(gid, hook, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(gid, hook, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(gid, hook, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupsServiceInterface_DeleteGroupHook_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteGroupHook'
type GroupsServiceInterface_DeleteGroupHook_Call struct {
	*mock.Call
}

// DeleteGroupHook is a helper method to define mock.On call
//   - gid interface{}
//   - hook int
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) DeleteGroupHook(gid interface{}, hook interface{}, options ...interface{}) *GroupsServiceInterface_DeleteGroupHook_Call {
	return &GroupsServiceInterface_DeleteGroupHook_Call{Call: _e.mock.On("DeleteGroupHook",
		append([]interface{}{gid, hook}, options...)...)}
}

func (_c *GroupsServiceInterface_DeleteGroupHook_Call) Run(run func(gid interface{}, hook int, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_DeleteGroupHook_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_DeleteGroupHook_Call) Return(_a0 *gitlab.Response, _a1 error) *GroupsServiceInterface_DeleteGroupHook_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GroupsServiceInterface_DeleteGroupHook_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *GroupsServiceInterface_DeleteGroupHook_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteGroupHookURLVariable provides a mock function with given fields: gid, hook, key, options
func (_m *GroupsServiceInterface) DeleteGroupHookURLVariable(gid interface{}, hook int, key string, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, hook, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGroupHookURLVariable")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(gid, hook, key, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(gid, hook, key, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(gid, hook, key, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupsServiceInterface_DeleteGroupHookURLVariable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteGroupHookURLVariable'
type GroupsServiceInterface_DeleteGroupHookURLVariable_Call struct {
	*mock.Call
}

// DeleteGroupHookURLVariable is a helper method to define mock.On call
//   - gid interface{}
//   - hook int
//   - key string
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) DeleteGroupHookURLVariable(gid interface{}, hook interface{}, key interface{}, options ...interface{}) *GroupsServiceInterface_DeleteGroupHookURLVariable_Call {
	return &GroupsServiceInterface_DeleteGroupHookURLVariable_Call{Call: _e.mock.On("DeleteGroupHookURLVariable",
		append([]interface{}{gid, hook, key}, options...)...)}
}

func (_c *GroupsServiceInterface_DeleteGroupHookURLVariable_Call) Run(run func(gid interface{}, hook int, key string, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_DeleteGroupHookURLVariable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_DeleteGroupHookURLVariable_Call) Return(_a0 *gitlab.Response, _a1 error) *GroupsServiceInterface_DeleteGroupHookURLVariable_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GroupsServiceInterface_DeleteGroupHookURLVariable_Call) RunAndReturn(run func(interface{}, int, string, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *GroupsServiceInterface_DeleteGroupHookURLVariable_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteGroupLDAPLink provides a mock function with given fields: gid, cn, options
func (_m *GroupsServiceInterface) DeleteGroupLDAPLink(gid interface{}, cn string, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, cn)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGroupLDAPLink")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, string, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(gid, cn, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(gid, cn, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(gid, cn, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupsServiceInterface_DeleteGroupLDAPLink_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteGroupLDAPLink'
type GroupsServiceInterface_DeleteGroupLDAPLink_Call struct {
	*mock.Call
}

// DeleteGroupLDAPLink is a helper method to define mock.On call
//   - gid interface{}
//   - cn string
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) DeleteGroupLDAPLink(gid interface{}, cn interface{}, options ...interface{}) *GroupsServiceInterface_DeleteGroupLDAPLink_Call {
	return &GroupsServiceInterface_DeleteGroupLDAPLink_Call{Call: _e.mock.On("DeleteGroupLDAPLink",
		append([]interface{}{gid, cn}, options...)...)}
}

func (_c *GroupsServiceInterface_DeleteGroupLDAPLink_Call) Run(run func(gid interface{}, cn string, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_DeleteGroupLDAPLink_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_DeleteGroupLDAPLink_Call) Return(_a0 *gitlab.Response, _a1 error) *GroupsServiceInterface_DeleteGroupLDAPLink_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GroupsServiceInterface_DeleteGroupLDAPLink_Call) RunAndReturn(run func(interface{}, string, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *GroupsServiceInterface_DeleteGroupLDAPLink_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteGroupLDAPLinkForProvider provides a mock function with given fields: gid, provider, cn, options
func (_m *GroupsServiceInterface) DeleteGroupLDAPLinkForProvider(gid interface{}, provider string, cn string, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, provider, cn)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGroupLDAPLinkForProvider")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, string, string, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(gid, provider, cn, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, string, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(gid, provider, cn, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, string, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(gid, provider, cn, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupsServiceInterface_DeleteGroupLDAPLinkForProvider_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteGroupLDAPLinkForProvider'
type GroupsServiceInterface_DeleteGroupLDAPLinkForProvider_Call struct {
	*mock.Call
}

// DeleteGroupLDAPLinkForProvider is a helper method to define mock.On call
//   - gid interface{}
//   - provider string
//   - cn string
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) DeleteGroupLDAPLinkForProvider(gid interface{}, provider interface{}, cn interface{}, options ...interface{}) *GroupsServiceInterface_DeleteGroupLDAPLinkForProvider_Call {
	return &GroupsServiceInterface_DeleteGroupLDAPLinkForProvider_Call{Call: _e.mock.On("DeleteGroupLDAPLinkForProvider",
		append([]interface{}{gid, provider, cn}, options...)...)}
}

func (_c *GroupsServiceInterface_DeleteGroupLDAPLinkForProvider_Call) Run(run func(gid interface{}, provider string, cn string, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_DeleteGroupLDAPLinkForProvider_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_DeleteGroupLDAPLinkForProvider_Call) Return(_a0 *gitlab.Response, _a1 error) *GroupsServiceInterface_DeleteGroupLDAPLinkForProvider_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GroupsServiceInterface_DeleteGroupLDAPLinkForProvider_Call) RunAndReturn(run func(interface{}, string, string, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *GroupsServiceInterface_DeleteGroupLDAPLinkForProvider_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteGroupLDAPLinkWithCNOrFilter provides a mock function with given fields: gid, opts, options
func (_m *GroupsServiceInterface) DeleteGroupLDAPLinkWithCNOrFilter(gid interface{}, opts *gitlab.DeleteGroupLDAPLinkWithCNOrFilterOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, opts)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGroupLDAPLinkWithCNOrFilter")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.DeleteGroupLDAPLinkWithCNOrFilterOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(gid, opts, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.DeleteGroupLDAPLinkWithCNOrFilterOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(gid, opts, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.DeleteGroupLDAPLinkWithCNOrFilterOptions, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(gid, opts, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupsServiceInterface_DeleteGroupLDAPLinkWithCNOrFilter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteGroupLDAPLinkWithCNOrFilter'
type GroupsServiceInterface_DeleteGroupLDAPLinkWithCNOrFilter_Call struct {
	*mock.Call
}

// DeleteGroupLDAPLinkWithCNOrFilter is a helper method to define mock.On call
//   - gid interface{}
//   - opts *gitlab.DeleteGroupLDAPLinkWithCNOrFilterOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) DeleteGroupLDAPLinkWithCNOrFilter(gid interface{}, opts interface{}, options ...interface{}) *GroupsServiceInterface_DeleteGroupLDAPLinkWithCNOrFilter_Call {
	return &GroupsServiceInterface_DeleteGroupLDAPLinkWithCNOrFilter_Call{Call: _e.mock.On("DeleteGroupLDAPLinkWithCNOrFilter",
		append([]interface{}{gid, opts}, options...)...)}
}

func (_c *GroupsServiceInterface_DeleteGroupLDAPLinkWithCNOrFilter_Call) Run(run func(gid interface{}, opts *gitlab.DeleteGroupLDAPLinkWithCNOrFilterOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_DeleteGroupLDAPLinkWithCNOrFilter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.DeleteGroupLDAPLinkWithCNOrFilterOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_DeleteGroupLDAPLinkWithCNOrFilter_Call) Return(_a0 *gitlab.Response, _a1 error) *GroupsServiceInterface_DeleteGroupLDAPLinkWithCNOrFilter_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GroupsServiceInterface_DeleteGroupLDAPLinkWithCNOrFilter_Call) RunAndReturn(run func(interface{}, *gitlab.DeleteGroupLDAPLinkWithCNOrFilterOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *GroupsServiceInterface_DeleteGroupLDAPLinkWithCNOrFilter_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteGroupPushRule provides a mock function with given fields: gid, options
func (_m *GroupsServiceInterface) DeleteGroupPushRule(gid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGroupPushRule")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(gid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(gid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(gid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupsServiceInterface_DeleteGroupPushRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteGroupPushRule'
type GroupsServiceInterface_DeleteGroupPushRule_Call struct {
	*mock.Call
}

// DeleteGroupPushRule is a helper method to define mock.On call
//   - gid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) DeleteGroupPushRule(gid interface{}, options ...interface{}) *GroupsServiceInterface_DeleteGroupPushRule_Call {
	return &GroupsServiceInterface_DeleteGroupPushRule_Call{Call: _e.mock.On("DeleteGroupPushRule",
		append([]interface{}{gid}, options...)...)}
}

func (_c *GroupsServiceInterface_DeleteGroupPushRule_Call) Run(run func(gid interface{}, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_DeleteGroupPushRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_DeleteGroupPushRule_Call) Return(_a0 *gitlab.Response, _a1 error) *GroupsServiceInterface_DeleteGroupPushRule_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GroupsServiceInterface_DeleteGroupPushRule_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *GroupsServiceInterface_DeleteGroupPushRule_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteGroupSAMLLink provides a mock function with given fields: gid, samlGroupName, options
func (_m *GroupsServiceInterface) DeleteGroupSAMLLink(gid interface{}, samlGroupName string, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, samlGroupName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGroupSAMLLink")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, string, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(gid, samlGroupName, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(gid, samlGroupName, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(gid, samlGroupName, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupsServiceInterface_DeleteGroupSAMLLink_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteGroupSAMLLink'
type GroupsServiceInterface_DeleteGroupSAMLLink_Call struct {
	*mock.Call
}

// DeleteGroupSAMLLink is a helper method to define mock.On call
//   - gid interface{}
//   - samlGroupName string
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) DeleteGroupSAMLLink(gid interface{}, samlGroupName interface{}, options ...interface{}) *GroupsServiceInterface_DeleteGroupSAMLLink_Call {
	return &GroupsServiceInterface_DeleteGroupSAMLLink_Call{Call: _e.mock.On("DeleteGroupSAMLLink",
		append([]interface{}{gid, samlGroupName}, options...)...)}
}

func (_c *GroupsServiceInterface_DeleteGroupSAMLLink_Call) Run(run func(gid interface{}, samlGroupName string, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_DeleteGroupSAMLLink_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_DeleteGroupSAMLLink_Call) Return(_a0 *gitlab.Response, _a1 error) *GroupsServiceInterface_DeleteGroupSAMLLink_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GroupsServiceInterface_DeleteGroupSAMLLink_Call) RunAndReturn(run func(interface{}, string, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *GroupsServiceInterface_DeleteGroupSAMLLink_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteServiceAccount provides a mock function with given fields: gid, serviceAccount, opt, options
func (_m *GroupsServiceInterface) DeleteServiceAccount(gid interface{}, serviceAccount int, opt *gitlab.DeleteServiceAccountOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, serviceAccount, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteServiceAccount")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.DeleteServiceAccountOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(gid, serviceAccount, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.DeleteServiceAccountOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(gid, serviceAccount, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.DeleteServiceAccountOptions, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(gid, serviceAccount, opt, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupsServiceInterface_DeleteServiceAccount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteServiceAccount'
type GroupsServiceInterface_DeleteServiceAccount_Call struct {
	*mock.Call
}

// DeleteServiceAccount is a helper method to define mock.On call
//   - gid interface{}
//   - serviceAccount int
//   - opt *gitlab.DeleteServiceAccountOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) DeleteServiceAccount(gid interface{}, serviceAccount interface{}, opt interface{}, options ...interface{}) *GroupsServiceInterface_DeleteServiceAccount_Call {
	return &GroupsServiceInterface_DeleteServiceAccount_Call{Call: _e.mock.On("DeleteServiceAccount",
		append([]interface{}{gid, serviceAccount, opt}, options...)...)}
}

func (_c *GroupsServiceInterface_DeleteServiceAccount_Call) Run(run func(gid interface{}, serviceAccount int, opt *gitlab.DeleteServiceAccountOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_DeleteServiceAccount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.DeleteServiceAccountOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_DeleteServiceAccount_Call) Return(_a0 *gitlab.Response, _a1 error) *GroupsServiceInterface_DeleteServiceAccount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GroupsServiceInterface_DeleteServiceAccount_Call) RunAndReturn(run func(interface{}, int, *gitlab.DeleteServiceAccountOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *GroupsServiceInterface_DeleteServiceAccount_Call {
	_c.Call.Return(run)
	return _c
}

// DownloadAvatar provides a mock function with given fields: gid, options
func (_m *GroupsServiceInterface) DownloadAvatar(gid interface{}, options ...gitlab.RequestOptionFunc) (*bytes.Reader, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DownloadAvatar")
	}

	var r0 *bytes.Reader
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*bytes.Reader, *gitlab.Response, error)); ok {
		return rf(gid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *bytes.Reader); ok {
		r0 = rf(gid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bytes.Reader)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_DownloadAvatar_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DownloadAvatar'
type GroupsServiceInterface_DownloadAvatar_Call struct {
	*mock.Call
}

// DownloadAvatar is a helper method to define mock.On call
//   - gid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) DownloadAvatar(gid interface{}, options ...interface{}) *GroupsServiceInterface_DownloadAvatar_Call {
	return &GroupsServiceInterface_DownloadAvatar_Call{Call: _e.mock.On("DownloadAvatar",
		append([]interface{}{gid}, options...)...)}
}

func (_c *GroupsServiceInterface_DownloadAvatar_Call) Run(run func(gid interface{}, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_DownloadAvatar_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_DownloadAvatar_Call) Return(_a0 *bytes.Reader, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_DownloadAvatar_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_DownloadAvatar_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*bytes.Reader, *gitlab.Response, error)) *GroupsServiceInterface_DownloadAvatar_Call {
	_c.Call.Return(run)
	return _c
}

// EditGroupHook provides a mock function with given fields: gid, hook, opt, options
func (_m *GroupsServiceInterface) EditGroupHook(gid interface{}, hook int, opt *gitlab.EditGroupHookOptions, options ...gitlab.RequestOptionFunc) (*gitlab.GroupHook, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, hook, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EditGroupHook")
	}

	var r0 *gitlab.GroupHook
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.EditGroupHookOptions, ...gitlab.RequestOptionFunc) (*gitlab.GroupHook, *gitlab.Response, error)); ok {
		return rf(gid, hook, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.EditGroupHookOptions, ...gitlab.RequestOptionFunc) *gitlab.GroupHook); ok {
		r0 = rf(gid, hook, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.GroupHook)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.EditGroupHookOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, hook, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.EditGroupHookOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, hook, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_EditGroupHook_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EditGroupHook'
type GroupsServiceInterface_EditGroupHook_Call struct {
	*mock.Call
}

// EditGroupHook is a helper method to define mock.On call
//   - gid interface{}
//   - hook int
//   - opt *gitlab.EditGroupHookOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) EditGroupHook(gid interface{}, hook interface{}, opt interface{}, options ...interface{}) *GroupsServiceInterface_EditGroupHook_Call {
	return &GroupsServiceInterface_EditGroupHook_Call{Call: _e.mock.On("EditGroupHook",
		append([]interface{}{gid, hook, opt}, options...)...)}
}

func (_c *GroupsServiceInterface_EditGroupHook_Call) Run(run func(gid interface{}, hook int, opt *gitlab.EditGroupHookOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_EditGroupHook_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.EditGroupHookOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_EditGroupHook_Call) Return(_a0 *gitlab.GroupHook, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_EditGroupHook_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_EditGroupHook_Call) RunAndReturn(run func(interface{}, int, *gitlab.EditGroupHookOptions, ...gitlab.RequestOptionFunc) (*gitlab.GroupHook, *gitlab.Response, error)) *GroupsServiceInterface_EditGroupHook_Call {
	_c.Call.Return(run)
	return _c
}

// EditGroupPushRule provides a mock function with given fields: gid, opt, options
func (_m *GroupsServiceInterface) EditGroupPushRule(gid interface{}, opt *gitlab.EditGroupPushRuleOptions, options ...gitlab.RequestOptionFunc) (*gitlab.GroupPushRules, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EditGroupPushRule")
	}

	var r0 *gitlab.GroupPushRules
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.EditGroupPushRuleOptions, ...gitlab.RequestOptionFunc) (*gitlab.GroupPushRules, *gitlab.Response, error)); ok {
		return rf(gid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.EditGroupPushRuleOptions, ...gitlab.RequestOptionFunc) *gitlab.GroupPushRules); ok {
		r0 = rf(gid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.GroupPushRules)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.EditGroupPushRuleOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.EditGroupPushRuleOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_EditGroupPushRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EditGroupPushRule'
type GroupsServiceInterface_EditGroupPushRule_Call struct {
	*mock.Call
}

// EditGroupPushRule is a helper method to define mock.On call
//   - gid interface{}
//   - opt *gitlab.EditGroupPushRuleOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) EditGroupPushRule(gid interface{}, opt interface{}, options ...interface{}) *GroupsServiceInterface_EditGroupPushRule_Call {
	return &GroupsServiceInterface_EditGroupPushRule_Call{Call: _e.mock.On("EditGroupPushRule",
		append([]interface{}{gid, opt}, options...)...)}
}

func (_c *GroupsServiceInterface_EditGroupPushRule_Call) Run(run func(gid interface{}, opt *gitlab.EditGroupPushRuleOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_EditGroupPushRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.EditGroupPushRuleOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_EditGroupPushRule_Call) Return(_a0 *gitlab.GroupPushRules, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_EditGroupPushRule_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_EditGroupPushRule_Call) RunAndReturn(run func(interface{}, *gitlab.EditGroupPushRuleOptions, ...gitlab.RequestOptionFunc) (*gitlab.GroupPushRules, *gitlab.Response, error)) *GroupsServiceInterface_EditGroupPushRule_Call {
	_c.Call.Return(run)
	return _c
}

// GetGroup provides a mock function with given fields: gid, opt, options
func (_m *GroupsServiceInterface) GetGroup(gid interface{}, opt *gitlab.GetGroupOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Group, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetGroup")
	}

	var r0 *gitlab.Group
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.GetGroupOptions, ...gitlab.RequestOptionFunc) (*gitlab.Group, *gitlab.Response, error)); ok {
		return rf(gid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.GetGroupOptions, ...gitlab.RequestOptionFunc) *gitlab.Group); ok {
		r0 = rf(gid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.GetGroupOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.GetGroupOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_GetGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGroup'
type GroupsServiceInterface_GetGroup_Call struct {
	*mock.Call
}

// GetGroup is a helper method to define mock.On call
//   - gid interface{}
//   - opt *gitlab.GetGroupOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) GetGroup(gid interface{}, opt interface{}, options ...interface{}) *GroupsServiceInterface_GetGroup_Call {
	return &GroupsServiceInterface_GetGroup_Call{Call: _e.mock.On("GetGroup",
		append([]interface{}{gid, opt}, options...)...)}
}

func (_c *GroupsServiceInterface_GetGroup_Call) Run(run func(gid interface{}, opt *gitlab.GetGroupOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_GetGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.GetGroupOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_GetGroup_Call) Return(_a0 *gitlab.Group, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_GetGroup_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_GetGroup_Call) RunAndReturn(run func(interface{}, *gitlab.GetGroupOptions, ...gitlab.RequestOptionFunc) (*gitlab.Group, *gitlab.Response, error)) *GroupsServiceInterface_GetGroup_Call {
	_c.Call.Return(run)
	return _c
}

// GetGroupHook provides a mock function with given fields: gid, hook, options
func (_m *GroupsServiceInterface) GetGroupHook(gid interface{}, hook int, options ...gitlab.RequestOptionFunc) (*gitlab.GroupHook, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, hook)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetGroupHook")
	}

	var r0 *gitlab.GroupHook
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.GroupHook, *gitlab.Response, error)); ok {
		return rf(gid, hook, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.GroupHook); ok {
		r0 = rf(gid, hook, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.GroupHook)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, hook, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, hook, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_GetGroupHook_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGroupHook'
type GroupsServiceInterface_GetGroupHook_Call struct {
	*mock.Call
}

// GetGroupHook is a helper method to define mock.On call
//   - gid interface{}
//   - hook int
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) GetGroupHook(gid interface{}, hook interface{}, options ...interface{}) *GroupsServiceInterface_GetGroupHook_Call {
	return &GroupsServiceInterface_GetGroupHook_Call{Call: _e.mock.On("GetGroupHook",
		append([]interface{}{gid, hook}, options...)...)}
}

func (_c *GroupsServiceInterface_GetGroupHook_Call) Run(run func(gid interface{}, hook int, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_GetGroupHook_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_GetGroupHook_Call) Return(_a0 *gitlab.GroupHook, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_GetGroupHook_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_GetGroupHook_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.GroupHook, *gitlab.Response, error)) *GroupsServiceInterface_GetGroupHook_Call {
	_c.Call.Return(run)
	return _c
}

// GetGroupPushRules provides a mock function with given fields: gid, options
func (_m *GroupsServiceInterface) GetGroupPushRules(gid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.GroupPushRules, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetGroupPushRules")
	}

	var r0 *gitlab.GroupPushRules
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.GroupPushRules, *gitlab.Response, error)); ok {
		return rf(gid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.GroupPushRules); ok {
		r0 = rf(gid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.GroupPushRules)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_GetGroupPushRules_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGroupPushRules'
type GroupsServiceInterface_GetGroupPushRules_Call struct {
	*mock.Call
}

// GetGroupPushRules is a helper method to define mock.On call
//   - gid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) GetGroupPushRules(gid interface{}, options ...interface{}) *GroupsServiceInterface_GetGroupPushRules_Call {
	return &GroupsServiceInterface_GetGroupPushRules_Call{Call: _e.mock.On("GetGroupPushRules",
		append([]interface{}{gid}, options...)...)}
}

func (_c *GroupsServiceInterface_GetGroupPushRules_Call) Run(run func(gid interface{}, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_GetGroupPushRules_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_GetGroupPushRules_Call) Return(_a0 *gitlab.GroupPushRules, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_GetGroupPushRules_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_GetGroupPushRules_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.GroupPushRules, *gitlab.Response, error)) *GroupsServiceInterface_GetGroupPushRules_Call {
	_c.Call.Return(run)
	return _c
}

// GetGroupSAMLLink provides a mock function with given fields: gid, samlGroupName, options
func (_m *GroupsServiceInterface) GetGroupSAMLLink(gid interface{}, samlGroupName string, options ...gitlab.RequestOptionFunc) (*gitlab.SAMLGroupLink, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, samlGroupName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetGroupSAMLLink")
	}

	var r0 *gitlab.SAMLGroupLink
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, ...gitlab.RequestOptionFunc) (*gitlab.SAMLGroupLink, *gitlab.Response, error)); ok {
		return rf(gid, samlGroupName, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, ...gitlab.RequestOptionFunc) *gitlab.SAMLGroupLink); ok {
		r0 = rf(gid, samlGroupName, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.SAMLGroupLink)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, samlGroupName, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, samlGroupName, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_GetGroupSAMLLink_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGroupSAMLLink'
type GroupsServiceInterface_GetGroupSAMLLink_Call struct {
	*mock.Call
}

// GetGroupSAMLLink is a helper method to define mock.On call
//   - gid interface{}
//   - samlGroupName string
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) GetGroupSAMLLink(gid interface{}, samlGroupName interface{}, options ...interface{}) *GroupsServiceInterface_GetGroupSAMLLink_Call {
	return &GroupsServiceInterface_GetGroupSAMLLink_Call{Call: _e.mock.On("GetGroupSAMLLink",
		append([]interface{}{gid, samlGroupName}, options...)...)}
}

func (_c *GroupsServiceInterface_GetGroupSAMLLink_Call) Run(run func(gid interface{}, samlGroupName string, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_GetGroupSAMLLink_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_GetGroupSAMLLink_Call) Return(_a0 *gitlab.SAMLGroupLink, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_GetGroupSAMLLink_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_GetGroupSAMLLink_Call) RunAndReturn(run func(interface{}, string, ...gitlab.RequestOptionFunc) (*gitlab.SAMLGroupLink, *gitlab.Response, error)) *GroupsServiceInterface_GetGroupSAMLLink_Call {
	_c.Call.Return(run)
	return _c
}

// ListAllGroupMembers provides a mock function with given fields: gid, opt, options
func (_m *GroupsServiceInterface) ListAllGroupMembers(gid interface{}, opt *gitlab.ListGroupMembersOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.GroupMember, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAllGroupMembers")
	}

	var r0 []*gitlab.GroupMember
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListGroupMembersOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.GroupMember, *gitlab.Response, error)); ok {
		return rf(gid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListGroupMembersOptions, ...gitlab.RequestOptionFunc) []*gitlab.GroupMember); ok {
		r0 = rf(gid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.GroupMember)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListGroupMembersOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListGroupMembersOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_ListAllGroupMembers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListAllGroupMembers'
type GroupsServiceInterface_ListAllGroupMembers_Call struct {
	*mock.Call
}

// ListAllGroupMembers is a helper method to define mock.On call
//   - gid interface{}
//   - opt *gitlab.ListGroupMembersOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) ListAllGroupMembers(gid interface{}, opt interface{}, options ...interface{}) *GroupsServiceInterface_ListAllGroupMembers_Call {
	return &GroupsServiceInterface_ListAllGroupMembers_Call{Call: _e.mock.On("ListAllGroupMembers",
		append([]interface{}{gid, opt}, options...)...)}
}

func (_c *GroupsServiceInterface_ListAllGroupMembers_Call) Run(run func(gid interface{}, opt *gitlab.ListGroupMembersOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_ListAllGroupMembers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListGroupMembersOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_ListAllGroupMembers_Call) Return(_a0 []*gitlab.GroupMember, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_ListAllGroupMembers_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_ListAllGroupMembers_Call) RunAndReturn(run func(interface{}, *gitlab.ListGroupMembersOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.GroupMember, *gitlab.Response, error)) *GroupsServiceInterface_ListAllGroupMembers_Call {
	_c.Call.Return(run)
	return _c
}

// ListBillableGroupMembers provides a mock function with given fields: gid, opt, options
func (_m *GroupsServiceInterface) ListBillableGroupMembers(gid interface{}, opt *gitlab.ListBillableGroupMembersOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.BillableGroupMember, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListBillableGroupMembers")
	}

	var r0 []*gitlab.BillableGroupMember
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListBillableGroupMembersOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.BillableGroupMember, *gitlab.Response, error)); ok {
		return rf(gid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListBillableGroupMembersOptions, ...gitlab.RequestOptionFunc) []*gitlab.BillableGroupMember); ok {
		r0 = rf(gid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.BillableGroupMember)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListBillableGroupMembersOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListBillableGroupMembersOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_ListBillableGroupMembers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListBillableGroupMembers'
type GroupsServiceInterface_ListBillableGroupMembers_Call struct {
	*mock.Call
}

// ListBillableGroupMembers is a helper method to define mock.On call
//   - gid interface{}
//   - opt *gitlab.ListBillableGroupMembersOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) ListBillableGroupMembers(gid interface{}, opt interface{}, options ...interface{}) *GroupsServiceInterface_ListBillableGroupMembers_Call {
	return &GroupsServiceInterface_ListBillableGroupMembers_Call{Call: _e.mock.On("ListBillableGroupMembers",
		append([]interface{}{gid, opt}, options...)...)}
}

func (_c *GroupsServiceInterface_ListBillableGroupMembers_Call) Run(run func(gid interface{}, opt *gitlab.ListBillableGroupMembersOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_ListBillableGroupMembers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListBillableGroupMembersOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_ListBillableGroupMembers_Call) Return(_a0 []*gitlab.BillableGroupMember, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_ListBillableGroupMembers_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_ListBillableGroupMembers_Call) RunAndReturn(run func(interface{}, *gitlab.ListBillableGroupMembersOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.BillableGroupMember, *gitlab.Response, error)) *GroupsServiceInterface_ListBillableGroupMembers_Call {
	_c.Call.Return(run)
	return _c
}

// ListDescendantGroups provides a mock function with given fields: gid, opt, options
func (_m *GroupsServiceInterface) ListDescendantGroups(gid interface{}, opt *gitlab.ListDescendantGroupsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Group, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListDescendantGroups")
	}

	var r0 []*gitlab.Group
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListDescendantGroupsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Group, *gitlab.Response, error)); ok {
		return rf(gid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListDescendantGroupsOptions, ...gitlab.RequestOptionFunc) []*gitlab.Group); ok {
		r0 = rf(gid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListDescendantGroupsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListDescendantGroupsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_ListDescendantGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListDescendantGroups'
type GroupsServiceInterface_ListDescendantGroups_Call struct {
	*mock.Call
}

// ListDescendantGroups is a helper method to define mock.On call
//   - gid interface{}
//   - opt *gitlab.ListDescendantGroupsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) ListDescendantGroups(gid interface{}, opt interface{}, options ...interface{}) *GroupsServiceInterface_ListDescendantGroups_Call {
	return &GroupsServiceInterface_ListDescendantGroups_Call{Call: _e.mock.On("ListDescendantGroups",
		append([]interface{}{gid, opt}, options...)...)}
}

func (_c *GroupsServiceInterface_ListDescendantGroups_Call) Run(run func(gid interface{}, opt *gitlab.ListDescendantGroupsOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_ListDescendantGroups_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListDescendantGroupsOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_ListDescendantGroups_Call) Return(_a0 []*gitlab.Group, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_ListDescendantGroups_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_ListDescendantGroups_Call) RunAndReturn(run func(interface{}, *gitlab.ListDescendantGroupsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Group, *gitlab.Response, error)) *GroupsServiceInterface_ListDescendantGroups_Call {
	_c.Call.Return(run)
	return _c
}

// ListGroupHooks provides a mock function with given fields: gid, opt, options
func (_m *GroupsServiceInterface) ListGroupHooks(gid interface{}, opt *gitlab.ListGroupHooksOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.GroupHook, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListGroupHooks")
	}

	var r0 []*gitlab.GroupHook
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListGroupHooksOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.GroupHook, *gitlab.Response, error)); ok {
		return rf(gid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListGroupHooksOptions, ...gitlab.RequestOptionFunc) []*gitlab.GroupHook); ok {
		r0 = rf(gid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.GroupHook)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListGroupHooksOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListGroupHooksOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_ListGroupHooks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListGroupHooks'
type GroupsServiceInterface_ListGroupHooks_Call struct {
	*mock.Call
}

// ListGroupHooks is a helper method to define mock.On call
//   - gid interface{}
//   - opt *gitlab.ListGroupHooksOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) ListGroupHooks(gid interface{}, opt interface{}, options ...interface{}) *GroupsServiceInterface_ListGroupHooks_Call {
	return &GroupsServiceInterface_ListGroupHooks_Call{Call: _e.mock.On("ListGroupHooks",
		append([]interface{}{gid, opt}, options...)...)}
}

func (_c *GroupsServiceInterface_ListGroupHooks_Call) Run(run func(gid interface{}, opt *gitlab.ListGroupHooksOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_ListGroupHooks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListGroupHooksOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_ListGroupHooks_Call) Return(_a0 []*gitlab.GroupHook, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_ListGroupHooks_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_ListGroupHooks_Call) RunAndReturn(run func(interface{}, *gitlab.ListGroupHooksOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.GroupHook, *gitlab.Response, error)) *GroupsServiceInterface_ListGroupHooks_Call {
	_c.Call.Return(run)
	return _c
}

// ListGroupLDAPLinks provides a mock function with given fields: gid, options
func (_m *GroupsServiceInterface) ListGroupLDAPLinks(gid interface{}, options ...gitlab.RequestOptionFunc) ([]*gitlab.LDAPGroupLink, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListGroupLDAPLinks")
	}

	var r0 []*gitlab.LDAPGroupLink
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) ([]*gitlab.LDAPGroupLink, *gitlab.Response, error)); ok {
		return rf(gid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) []*gitlab.LDAPGroupLink); ok {
		r0 = rf(gid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.LDAPGroupLink)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_ListGroupLDAPLinks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListGroupLDAPLinks'
type GroupsServiceInterface_ListGroupLDAPLinks_Call struct {
	*mock.Call
}

// ListGroupLDAPLinks is a helper method to define mock.On call
//   - gid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) ListGroupLDAPLinks(gid interface{}, options ...interface{}) *GroupsServiceInterface_ListGroupLDAPLinks_Call {
	return &GroupsServiceInterface_ListGroupLDAPLinks_Call{Call: _e.mock.On("ListGroupLDAPLinks",
		append([]interface{}{gid}, options...)...)}
}

func (_c *GroupsServiceInterface_ListGroupLDAPLinks_Call) Run(run func(gid interface{}, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_ListGroupLDAPLinks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_ListGroupLDAPLinks_Call) Return(_a0 []*gitlab.LDAPGroupLink, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_ListGroupLDAPLinks_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_ListGroupLDAPLinks_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) ([]*gitlab.LDAPGroupLink, *gitlab.Response, error)) *GroupsServiceInterface_ListGroupLDAPLinks_Call {
	_c.Call.Return(run)
	return _c
}

// ListGroupMembers provides a mock function with given fields: gid, opt, options
func (_m *GroupsServiceInterface) ListGroupMembers(gid interface{}, opt *gitlab.ListGroupMembersOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.GroupMember, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListGroupMembers")
	}

	var r0 []*gitlab.GroupMember
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListGroupMembersOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.GroupMember, *gitlab.Response, error)); ok {
		return rf(gid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListGroupMembersOptions, ...gitlab.RequestOptionFunc) []*gitlab.GroupMember); ok {
		r0 = rf(gid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.GroupMember)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListGroupMembersOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListGroupMembersOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_ListGroupMembers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListGroupMembers'
type GroupsServiceInterface_ListGroupMembers_Call struct {
	*mock.Call
}

// ListGroupMembers is a helper method to define mock.On call
//   - gid interface{}
//   - opt *gitlab.ListGroupMembersOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) ListGroupMembers(gid interface{}, opt interface{}, options ...interface{}) *GroupsServiceInterface_ListGroupMembers_Call {
	return &GroupsServiceInterface_ListGroupMembers_Call{Call: _e.mock.On("ListGroupMembers",
		append([]interface{}{gid, opt}, options...)...)}
}

func (_c *GroupsServiceInterface_ListGroupMembers_Call) Run(run func(gid interface{}, opt *gitlab.ListGroupMembersOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_ListGroupMembers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListGroupMembersOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_ListGroupMembers_Call) Return(_a0 []*gitlab.GroupMember, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_ListGroupMembers_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_ListGroupMembers_Call) RunAndReturn(run func(interface{}, *gitlab.ListGroupMembersOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.GroupMember, *gitlab.Response, error)) *GroupsServiceInterface_ListGroupMembers_Call {
	_c.Call.Return(run)
	return _c
}

// ListGroupProjects provides a mock function with given fields: gid, opt, options
func (_m *GroupsServiceInterface) ListGroupProjects(gid interface{}, opt *gitlab.ListGroupProjectsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListGroupProjects")
	}

	var r0 []*gitlab.Project
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListGroupProjectsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)); ok {
		return rf(gid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListGroupProjectsOptions, ...gitlab.RequestOptionFunc) []*gitlab.Project); ok {
		r0 = rf(gid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListGroupProjectsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListGroupProjectsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_ListGroupProjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListGroupProjects'
type GroupsServiceInterface_ListGroupProjects_Call struct {
	*mock.Call
}

// ListGroupProjects is a helper method to define mock.On call
//   - gid interface{}
//   - opt *gitlab.ListGroupProjectsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) ListGroupProjects(gid interface{}, opt interface{}, options ...interface{}) *GroupsServiceInterface_ListGroupProjects_Call {
	return &GroupsServiceInterface_ListGroupProjects_Call{Call: _e.mock.On("ListGroupProjects",
		append([]interface{}{gid, opt}, options...)...)}
}

func (_c *GroupsServiceInterface_ListGroupProjects_Call) Run(run func(gid interface{}, opt *gitlab.ListGroupProjectsOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_ListGroupProjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListGroupProjectsOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_ListGroupProjects_Call) Return(_a0 []*gitlab.Project, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_ListGroupProjects_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_ListGroupProjects_Call) RunAndReturn(run func(interface{}, *gitlab.ListGroupProjectsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)) *GroupsServiceInterface_ListGroupProjects_Call {
	_c.Call.Return(run)
	return _c
}

// ListGroupSAMLLinks provides a mock function with given fields: gid, options
func (_m *GroupsServiceInterface) ListGroupSAMLLinks(gid interface{}, options ...gitlab.RequestOptionFunc) ([]*gitlab.SAMLGroupLink, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListGroupSAMLLinks")
	}

	var r0 []*gitlab.SAMLGroupLink
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) ([]*gitlab.SAMLGroupLink, *gitlab.Response, error)); ok {
		return rf(gid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) []*gitlab.SAMLGroupLink); ok {
		r0 = rf(gid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.SAMLGroupLink)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_ListGroupSAMLLinks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListGroupSAMLLinks'
type GroupsServiceInterface_ListGroupSAMLLinks_Call struct {
	*mock.Call
}

// ListGroupSAMLLinks is a helper method to define mock.On call
//   - gid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) ListGroupSAMLLinks(gid interface{}, options ...interface{}) *GroupsServiceInterface_ListGroupSAMLLinks_Call {
	return &GroupsServiceInterface_ListGroupSAMLLinks_Call{Call: _e.mock.On("ListGroupSAMLLinks",
		append([]interface{}{gid}, options...)...)}
}

func (_c *GroupsServiceInterface_ListGroupSAMLLinks_Call) Run(run func(gid interface{}, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_ListGroupSAMLLinks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_ListGroupSAMLLinks_Call) Return(_a0 []*gitlab.SAMLGroupLink, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_ListGroupSAMLLinks_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_ListGroupSAMLLinks_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) ([]*gitlab.SAMLGroupLink, *gitlab.Response, error)) *GroupsServiceInterface_ListGroupSAMLLinks_Call {
	_c.Call.Return(run)
	return _c
}

// ListGroupSharedProjects provides a mock function with given fields: gid, opt, options
func (_m *GroupsServiceInterface) ListGroupSharedProjects(gid interface{}, opt *gitlab.ListGroupSharedProjectsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListGroupSharedProjects")
	}

	var r0 []*gitlab.Project
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListGroupSharedProjectsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)); ok {
		return rf(gid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListGroupSharedProjectsOptions, ...gitlab.RequestOptionFunc) []*gitlab.Project); ok {
		r0 = rf(gid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListGroupSharedProjectsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListGroupSharedProjectsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_ListGroupSharedProjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListGroupSharedProjects'
type GroupsServiceInterface_ListGroupSharedProjects_Call struct {
	*mock.Call
}

// ListGroupSharedProjects is a helper method to define mock.On call
//   - gid interface{}
//   - opt *gitlab.ListGroupSharedProjectsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) ListGroupSharedProjects(gid interface{}, opt interface{}, options ...interface{}) *GroupsServiceInterface_ListGroupSharedProjects_Call {
	return &GroupsServiceInterface_ListGroupSharedProjects_Call{Call: _e.mock.On("ListGroupSharedProjects",
		append([]interface{}{gid, opt}, options...)...)}
}

func (_c *GroupsServiceInterface_ListGroupSharedProjects_Call) Run(run func(gid interface{}, opt *gitlab.ListGroupSharedProjectsOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_ListGroupSharedProjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListGroupSharedProjectsOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_ListGroupSharedProjects_Call) Return(_a0 []*gitlab.Project, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_ListGroupSharedProjects_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_ListGroupSharedProjects_Call) RunAndReturn(run func(interface{}, *gitlab.ListGroupSharedProjectsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)) *GroupsServiceInterface_ListGroupSharedProjects_Call {
	_c.Call.Return(run)
	return _c
}

// ListGroups provides a mock function with given fields: opt, options
func (_m *GroupsServiceInterface) ListGroups(opt *gitlab.ListGroupsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Group, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListGroups")
	}

	var r0 []*gitlab.Group
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(*gitlab.ListGroupsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Group, *gitlab.Response, error)); ok {
		return rf(opt, options...)
	}
	if rf, ok := ret.Get(0).(func(*gitlab.ListGroupsOptions, ...gitlab.RequestOptionFunc) []*gitlab.Group); ok {
		r0 = rf(opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(*gitlab.ListGroupsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(*gitlab.ListGroupsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_ListGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListGroups'
type GroupsServiceInterface_ListGroups_Call struct {
	*mock.Call
}

// ListGroups is a helper method to define mock.On call
//   - opt *gitlab.ListGroupsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) ListGroups(opt interface{}, options ...interface{}) *GroupsServiceInterface_ListGroups_Call {
	return &GroupsServiceInterface_ListGroups_Call{Call: _e.mock.On("ListGroups",
		append([]interface{}{opt}, options...)...)}
}

func (_c *GroupsServiceInterface_ListGroups_Call) Run(run func(opt *gitlab.ListGroupsOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_ListGroups_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(*gitlab.ListGroupsOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_ListGroups_Call) Return(_a0 []*gitlab.Group, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_ListGroups_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_ListGroups_Call) RunAndReturn(run func(*gitlab.ListGroupsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Group, *gitlab.Response, error)) *GroupsServiceInterface_ListGroups_Call {
	_c.Call.Return(run)
	return _c
}

// ListMembershipsForBillableGroupMember provides a mock function with given fields: gid, user, opt, options
func (_m *GroupsServiceInterface) ListMembershipsForBillableGroupMember(gid interface{}, user int, opt *gitlab.ListOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.BillableUserMembership, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, user, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMembershipsForBillableGroupMember")
	}

	var r0 []*gitlab.BillableUserMembership
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.BillableUserMembership, *gitlab.Response, error)); ok {
		return rf(gid, user, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListOptions, ...gitlab.RequestOptionFunc) []*gitlab.BillableUserMembership); ok {
		r0 = rf(gid, user, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.BillableUserMembership)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.ListOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, user, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.ListOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, user, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_ListMembershipsForBillableGroupMember_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMembershipsForBillableGroupMember'
type GroupsServiceInterface_ListMembershipsForBillableGroupMember_Call struct {
	*mock.Call
}

// ListMembershipsForBillableGroupMember is a helper method to define mock.On call
//   - gid interface{}
//   - user int
//   - opt *gitlab.ListOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) ListMembershipsForBillableGroupMember(gid interface{}, user interface{}, opt interface{}, options ...interface{}) *GroupsServiceInterface_ListMembershipsForBillableGroupMember_Call {
	return &GroupsServiceInterface_ListMembershipsForBillableGroupMember_Call{Call: _e.mock.On("ListMembershipsForBillableGroupMember",
		append([]interface{}{gid, user, opt}, options...)...)}
}

func (_c *GroupsServiceInterface_ListMembershipsForBillableGroupMember_Call) Run(run func(gid interface{}, user int, opt *gitlab.ListOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_ListMembershipsForBillableGroupMember_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.ListOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_ListMembershipsForBillableGroupMember_Call) Return(_a0 []*gitlab.BillableUserMembership, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_ListMembershipsForBillableGroupMember_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_ListMembershipsForBillableGroupMember_Call) RunAndReturn(run func(interface{}, int, *gitlab.ListOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.BillableUserMembership, *gitlab.Response, error)) *GroupsServiceInterface_ListMembershipsForBillableGroupMember_Call {
	_c.Call.Return(run)
	return _c
}

// ListProvisionedUsers provides a mock function with given fields: gid, opt, options
func (_m *GroupsServiceInterface) ListProvisionedUsers(gid interface{}, opt *gitlab.ListProvisionedUsersOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.User, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListProvisionedUsers")
	}

	var r0 []*gitlab.User
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListProvisionedUsersOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.User, *gitlab.Response, error)); ok {
		return rf(gid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListProvisionedUsersOptions, ...gitlab.RequestOptionFunc) []*gitlab.User); ok {
		r0 = rf(gid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.User)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListProvisionedUsersOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListProvisionedUsersOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_ListProvisionedUsers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListProvisionedUsers'
type GroupsServiceInterface_ListProvisionedUsers_Call struct {
	*mock.Call
}

// ListProvisionedUsers is a helper method to define mock.On call
//   - gid interface{}
//   - opt *gitlab.ListProvisionedUsersOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) ListProvisionedUsers(gid interface{}, opt interface{}, options ...interface{}) *GroupsServiceInterface_ListProvisionedUsers_Call {
	return &GroupsServiceInterface_ListProvisionedUsers_Call{Call: _e.mock.On("ListProvisionedUsers",
		append([]interface{}{gid, opt}, options...)...)}
}

func (_c *GroupsServiceInterface_ListProvisionedUsers_Call) Run(run func(gid interface{}, opt *gitlab.ListProvisionedUsersOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_ListProvisionedUsers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListProvisionedUsersOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_ListProvisionedUsers_Call) Return(_a0 []*gitlab.User, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_ListProvisionedUsers_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_ListProvisionedUsers_Call) RunAndReturn(run func(interface{}, *gitlab.ListProvisionedUsersOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.User, *gitlab.Response, error)) *GroupsServiceInterface_ListProvisionedUsers_Call {
	_c.Call.Return(run)
	return _c
}

// ListServiceAccounts provides a mock function with given fields: gid, opt, options
func (_m *GroupsServiceInterface) ListServiceAccounts(gid interface{}, opt *gitlab.ListServiceAccountsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.GroupServiceAccount, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListServiceAccounts")
	}

	var r0 []*gitlab.GroupServiceAccount
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListServiceAccountsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.GroupServiceAccount, *gitlab.Response, error)); ok {
		return rf(gid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListServiceAccountsOptions, ...gitlab.RequestOptionFunc) []*gitlab.GroupServiceAccount); ok {
		r0 = rf(gid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.GroupServiceAccount)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListServiceAccountsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListServiceAccountsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_ListServiceAccounts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListServiceAccounts'
type GroupsServiceInterface_ListServiceAccounts_Call struct {
	*mock.Call
}

// ListServiceAccounts is a helper method to define mock.On call
//   - gid interface{}
//   - opt *gitlab.ListServiceAccountsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) ListServiceAccounts(gid interface{}, opt interface{}, options ...interface{}) *GroupsServiceInterface_ListServiceAccounts_Call {
	return &GroupsServiceInterface_ListServiceAccounts_Call{Call: _e.mock.On("ListServiceAccounts",
		append([]interface{}{gid, opt}, options...)...)}
}

func (_c *GroupsServiceInterface_ListServiceAccounts_Call) Run(run func(gid interface{}, opt *gitlab.ListServiceAccountsOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_ListServiceAccounts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListServiceAccountsOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_ListServiceAccounts_Call) Return(_a0 []*gitlab.GroupServiceAccount, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_ListServiceAccounts_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_ListServiceAccounts_Call) RunAndReturn(run func(interface{}, *gitlab.ListServiceAccountsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.GroupServiceAccount, *gitlab.Response, error)) *GroupsServiceInterface_ListServiceAccounts_Call {
	_c.Call.Return(run)
	return _c
}

// ListSubGroups provides a mock function with given fields: gid, opt, options
func (_m *GroupsServiceInterface) ListSubGroups(gid interface{}, opt *gitlab.ListSubGroupsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Group, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSubGroups")
	}

	var r0 []*gitlab.Group
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListSubGroupsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Group, *gitlab.Response, error)); ok {
		return rf(gid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListSubGroupsOptions, ...gitlab.RequestOptionFunc) []*gitlab.Group); ok {
		r0 = rf(gid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListSubGroupsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListSubGroupsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_ListSubGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListSubGroups'
type GroupsServiceInterface_ListSubGroups_Call struct {
	*mock.Call
}

// ListSubGroups is a helper method to define mock.On call
//   - gid interface{}
//   - opt *gitlab.ListSubGroupsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) ListSubGroups(gid interface{}, opt interface{}, options ...interface{}) *GroupsServiceInterface_ListSubGroups_Call {
	return &GroupsServiceInterface_ListSubGroups_Call{Call: _e.mock.On("ListSubGroups",
		append([]interface{}{gid, opt}, options...)...)}
}

func (_c *GroupsServiceInterface_ListSubGroups_Call) Run(run func(gid interface{}, opt *gitlab.ListSubGroupsOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_ListSubGroups_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListSubGroupsOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_ListSubGroups_Call) Return(_a0 []*gitlab.Group, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_ListSubGroups_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_ListSubGroups_Call) RunAndReturn(run func(interface{}, *gitlab.ListSubGroupsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Group, *gitlab.Response, error)) *GroupsServiceInterface_ListSubGroups_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveBillableGroupMember provides a mock function with given fields: gid, user, options
func (_m *GroupsServiceInterface) RemoveBillableGroupMember(gid interface{}, user int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveBillableGroupMember")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(gid, user, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(gid, user, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(gid, user, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupsServiceInterface_RemoveBillableGroupMember_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveBillableGroupMember'
type GroupsServiceInterface_RemoveBillableGroupMember_Call struct {
	*mock.Call
}

// RemoveBillableGroupMember is a helper method to define mock.On call
//   - gid interface{}
//   - user int
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) RemoveBillableGroupMember(gid interface{}, user interface{}, options ...interface{}) *GroupsServiceInterface_RemoveBillableGroupMember_Call {
	return &GroupsServiceInterface_RemoveBillableGroupMember_Call{Call: _e.mock.On("RemoveBillableGroupMember",
		append([]interface{}{gid, user}, options...)...)}
}

func (_c *GroupsServiceInterface_RemoveBillableGroupMember_Call) Run(run func(gid interface{}, user int, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_RemoveBillableGroupMember_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_RemoveBillableGroupMember_Call) Return(_a0 *gitlab.Response, _a1 error) *GroupsServiceInterface_RemoveBillableGroupMember_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GroupsServiceInterface_RemoveBillableGroupMember_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *GroupsServiceInterface_RemoveBillableGroupMember_Call {
	_c.Call.Return(run)
	return _c
}

// ResendGroupHookEvent provides a mock function with given fields: gid, hook, hookEventID, options
func (_m *GroupsServiceInterface) ResendGroupHookEvent(gid interface{}, hook int, hookEventID int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, hook, hookEventID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResendGroupHookEvent")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(gid, hook, hookEventID, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(gid, hook, hookEventID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(gid, hook, hookEventID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupsServiceInterface_ResendGroupHookEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResendGroupHookEvent'
type GroupsServiceInterface_ResendGroupHookEvent_Call struct {
	*mock.Call
}

// ResendGroupHookEvent is a helper method to define mock.On call
//   - gid interface{}
//   - hook int
//   - hookEventID int
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) ResendGroupHookEvent(gid interface{}, hook interface{}, hookEventID interface{}, options ...interface{}) *GroupsServiceInterface_ResendGroupHookEvent_Call {
	return &GroupsServiceInterface_ResendGroupHookEvent_Call{Call: _e.mock.On("ResendGroupHookEvent",
		append([]interface{}{gid, hook, hookEventID}, options...)...)}
}

func (_c *GroupsServiceInterface_ResendGroupHookEvent_Call) Run(run func(gid interface{}, hook int, hookEventID int, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_ResendGroupHookEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_ResendGroupHookEvent_Call) Return(_a0 *gitlab.Response, _a1 error) *GroupsServiceInterface_ResendGroupHookEvent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GroupsServiceInterface_ResendGroupHookEvent_Call) RunAndReturn(run func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *GroupsServiceInterface_ResendGroupHookEvent_Call {
	_c.Call.Return(run)
	return _c
}

// RestoreGroup provides a mock function with given fields: gid, options
func (_m *GroupsServiceInterface) RestoreGroup(gid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Group, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RestoreGroup")
	}

	var r0 *gitlab.Group
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Group, *gitlab.Response, error)); ok {
		return rf(gid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Group); ok {
		r0 = rf(gid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_RestoreGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RestoreGroup'
type GroupsServiceInterface_RestoreGroup_Call struct {
	*mock.Call
}

// RestoreGroup is a helper method to define mock.On call
//   - gid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) RestoreGroup(gid interface{}, options ...interface{}) *GroupsServiceInterface_RestoreGroup_Call {
	return &GroupsServiceInterface_RestoreGroup_Call{Call: _e.mock.On("RestoreGroup",
		append([]interface{}{gid}, options...)...)}
}

func (_c *GroupsServiceInterface_RestoreGroup_Call) Run(run func(gid interface{}, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_RestoreGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_RestoreGroup_Call) Return(_a0 *gitlab.Group, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_RestoreGroup_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_RestoreGroup_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Group, *gitlab.Response, error)) *GroupsServiceInterface_RestoreGroup_Call {
	_c.Call.Return(run)
	return _c
}

// RotateServiceAccountPersonalAccessToken provides a mock function with given fields: gid, serviceAccount, token, opt, options
func (_m *GroupsServiceInterface) RotateServiceAccountPersonalAccessToken(gid interface{}, serviceAccount int, token int, opt *gitlab.RotateServiceAccountPersonalAccessTokenOptions, options ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, serviceAccount, token, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RotateServiceAccountPersonalAccessToken")
	}

	var r0 *gitlab.PersonalAccessToken
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, *gitlab.RotateServiceAccountPersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error)); ok {
		return rf(gid, serviceAccount, token, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, *gitlab.RotateServiceAccountPersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) *gitlab.PersonalAccessToken); ok {
		r0 = rf(gid, serviceAccount, token, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.PersonalAccessToken)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, *gitlab.RotateServiceAccountPersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, serviceAccount, token, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, int, *gitlab.RotateServiceAccountPersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, serviceAccount, token, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_RotateServiceAccountPersonalAccessToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RotateServiceAccountPersonalAccessToken'
type GroupsServiceInterface_RotateServiceAccountPersonalAccessToken_Call struct {
	*mock.Call
}

// RotateServiceAccountPersonalAccessToken is a helper method to define mock.On call
//   - gid interface{}
//   - serviceAccount int
//   - token int
//   - opt *gitlab.RotateServiceAccountPersonalAccessTokenOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) RotateServiceAccountPersonalAccessToken(gid interface{}, serviceAccount interface{}, token interface{}, opt interface{}, options ...interface{}) *GroupsServiceInterface_RotateServiceAccountPersonalAccessToken_Call {
	return &GroupsServiceInterface_RotateServiceAccountPersonalAccessToken_Call{Call: _e.mock.On("RotateServiceAccountPersonalAccessToken",
		append([]interface{}{gid, serviceAccount, token, opt}, options...)...)}
}

func (_c *GroupsServiceInterface_RotateServiceAccountPersonalAccessToken_Call) Run(run func(gid interface{}, serviceAccount int, token int, opt *gitlab.RotateServiceAccountPersonalAccessTokenOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_RotateServiceAccountPersonalAccessToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), args[3].(*gitlab.RotateServiceAccountPersonalAccessTokenOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_RotateServiceAccountPersonalAccessToken_Call) Return(_a0 *gitlab.PersonalAccessToken, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_RotateServiceAccountPersonalAccessToken_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_RotateServiceAccountPersonalAccessToken_Call) RunAndReturn(run func(interface{}, int, int, *gitlab.RotateServiceAccountPersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error)) *GroupsServiceInterface_RotateServiceAccountPersonalAccessToken_Call {
	_c.Call.Return(run)
	return _c
}

// SearchGroup provides a mock function with given fields: query, options
func (_m *GroupsServiceInterface) SearchGroup(query string, options ...gitlab.RequestOptionFunc) ([]*gitlab.Group, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, query)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SearchGroup")
	}

	var r0 []*gitlab.Group
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(string, ...gitlab.RequestOptionFunc) ([]*gitlab.Group, *gitlab.Response, error)); ok {
		return rf(query, options...)
	}
	if rf, ok := ret.Get(0).(func(string, ...gitlab.RequestOptionFunc) []*gitlab.Group); ok {
		r0 = rf(query, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(string, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(query, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(string, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(query, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_SearchGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SearchGroup'
type GroupsServiceInterface_SearchGroup_Call struct {
	*mock.Call
}

// SearchGroup is a helper method to define mock.On call
//   - query string
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) SearchGroup(query interface{}, options ...interface{}) *GroupsServiceInterface_SearchGroup_Call {
	return &GroupsServiceInterface_SearchGroup_Call{Call: _e.mock.On("SearchGroup",
		append([]interface{}{query}, options...)...)}
}

func (_c *GroupsServiceInterface_SearchGroup_Call) Run(run func(query string, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_SearchGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(string), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_SearchGroup_Call) Return(_a0 []*gitlab.Group, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_SearchGroup_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_SearchGroup_Call) RunAndReturn(run func(string, ...gitlab.RequestOptionFunc) ([]*gitlab.Group, *gitlab.Response, error)) *GroupsServiceInterface_SearchGroup_Call {
	_c.Call.Return(run)
	return _c
}

// SetGroupCustomHeader provides a mock function with given fields: gid, hook, key, opt, options
func (_m *GroupsServiceInterface) SetGroupCustomHeader(gid interface{}, hook int, key string, opt *gitlab.SetHookCustomHeaderOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, hook, key, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetGroupCustomHeader")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, string, *gitlab.SetHookCustomHeaderOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(gid, hook, key, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, string, *gitlab.SetHookCustomHeaderOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(gid, hook, key, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, string, *gitlab.SetHookCustomHeaderOptions, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(gid, hook, key, opt, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupsServiceInterface_SetGroupCustomHeader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetGroupCustomHeader'
type GroupsServiceInterface_SetGroupCustomHeader_Call struct {
	*mock.Call
}

// SetGroupCustomHeader is a helper method to define mock.On call
//   - gid interface{}
//   - hook int
//   - key string
//   - opt *gitlab.SetHookCustomHeaderOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) SetGroupCustomHeader(gid interface{}, hook interface{}, key interface{}, opt interface{}, options ...interface{}) *GroupsServiceInterface_SetGroupCustomHeader_Call {
	return &GroupsServiceInterface_SetGroupCustomHeader_Call{Call: _e.mock.On("SetGroupCustomHeader",
		append([]interface{}{gid, hook, key, opt}, options...)...)}
}

func (_c *GroupsServiceInterface_SetGroupCustomHeader_Call) Run(run func(gid interface{}, hook int, key string, opt *gitlab.SetHookCustomHeaderOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_SetGroupCustomHeader_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(string), args[3].(*gitlab.SetHookCustomHeaderOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_SetGroupCustomHeader_Call) Return(_a0 *gitlab.Response, _a1 error) *GroupsServiceInterface_SetGroupCustomHeader_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GroupsServiceInterface_SetGroupCustomHeader_Call) RunAndReturn(run func(interface{}, int, string, *gitlab.SetHookCustomHeaderOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *GroupsServiceInterface_SetGroupCustomHeader_Call {
	_c.Call.Return(run)
	return _c
}

// SetGroupHookURLVariable provides a mock function with given fields: gid, hook, key, opt, options
func (_m *GroupsServiceInterface) SetGroupHookURLVariable(gid interface{}, hook int, key string, opt *gitlab.SetHookURLVariableOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, hook, key, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetGroupHookURLVariable")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, string, *gitlab.SetHookURLVariableOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(gid, hook, key, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, string, *gitlab.SetHookURLVariableOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(gid, hook, key, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, string, *gitlab.SetHookURLVariableOptions, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(gid, hook, key, opt, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupsServiceInterface_SetGroupHookURLVariable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetGroupHookURLVariable'
type GroupsServiceInterface_SetGroupHookURLVariable_Call struct {
	*mock.Call
}

// SetGroupHookURLVariable is a helper method to define mock.On call
//   - gid interface{}
//   - hook int
//   - key string
//   - opt *gitlab.SetHookURLVariableOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) SetGroupHookURLVariable(gid interface{}, hook interface{}, key interface{}, opt interface{}, options ...interface{}) *GroupsServiceInterface_SetGroupHookURLVariable_Call {
	return &GroupsServiceInterface_SetGroupHookURLVariable_Call{Call: _e.mock.On("SetGroupHookURLVariable",
		append([]interface{}{gid, hook, key, opt}, options...)...)}
}

func (_c *GroupsServiceInterface_SetGroupHookURLVariable_Call) Run(run func(gid interface{}, hook int, key string, opt *gitlab.SetHookURLVariableOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_SetGroupHookURLVariable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(string), args[3].(*gitlab.SetHookURLVariableOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_SetGroupHookURLVariable_Call) Return(_a0 *gitlab.Response, _a1 error) *GroupsServiceInterface_SetGroupHookURLVariable_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GroupsServiceInterface_SetGroupHookURLVariable_Call) RunAndReturn(run func(interface{}, int, string, *gitlab.SetHookURLVariableOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *GroupsServiceInterface_SetGroupHookURLVariable_Call {
	_c.Call.Return(run)
	return _c
}

// ShareGroupWithGroup provides a mock function with given fields: gid, opt, options
func (_m *GroupsServiceInterface) ShareGroupWithGroup(gid interface{}, opt *gitlab.ShareGroupWithGroupOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Group, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ShareGroupWithGroup")
	}

	var r0 *gitlab.Group
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ShareGroupWithGroupOptions, ...gitlab.RequestOptionFunc) (*gitlab.Group, *gitlab.Response, error)); ok {
		return rf(gid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ShareGroupWithGroupOptions, ...gitlab.RequestOptionFunc) *gitlab.Group); ok {
		r0 = rf(gid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ShareGroupWithGroupOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ShareGroupWithGroupOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_ShareGroupWithGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ShareGroupWithGroup'
type GroupsServiceInterface_ShareGroupWithGroup_Call struct {
	*mock.Call
}

// ShareGroupWithGroup is a helper method to define mock.On call
//   - gid interface{}
//   - opt *gitlab.ShareGroupWithGroupOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) ShareGroupWithGroup(gid interface{}, opt interface{}, options ...interface{}) *GroupsServiceInterface_ShareGroupWithGroup_Call {
	return &GroupsServiceInterface_ShareGroupWithGroup_Call{Call: _e.mock.On("ShareGroupWithGroup",
		append([]interface{}{gid, opt}, options...)...)}
}

func (_c *GroupsServiceInterface_ShareGroupWithGroup_Call) Run(run func(gid interface{}, opt *gitlab.ShareGroupWithGroupOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_ShareGroupWithGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ShareGroupWithGroupOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_ShareGroupWithGroup_Call) Return(_a0 *gitlab.Group, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_ShareGroupWithGroup_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_ShareGroupWithGroup_Call) RunAndReturn(run func(interface{}, *gitlab.ShareGroupWithGroupOptions, ...gitlab.RequestOptionFunc) (*gitlab.Group, *gitlab.Response, error)) *GroupsServiceInterface_ShareGroupWithGroup_Call {
	_c.Call.Return(run)
	return _c
}

// TransferGroup provides a mock function with given fields: gid, pid, options
func (_m *GroupsServiceInterface) TransferGroup(gid interface{}, pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Group, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TransferGroup")
	}

	var r0 *gitlab.Group
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Group, *gitlab.Response, error)); ok {
		return rf(gid, pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, interface{}, ...gitlab.RequestOptionFunc) *gitlab.Group); ok {
		r0 = rf(gid, pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_TransferGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TransferGroup'
type GroupsServiceInterface_TransferGroup_Call struct {
	*mock.Call
}

// TransferGroup is a helper method to define mock.On call
//   - gid interface{}
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) TransferGroup(gid interface{}, pid interface{}, options ...interface{}) *GroupsServiceInterface_TransferGroup_Call {
	return &GroupsServiceInterface_TransferGroup_Call{Call: _e.mock.On("TransferGroup",
		append([]interface{}{gid, pid}, options...)...)}
}

func (_c *GroupsServiceInterface_TransferGroup_Call) Run(run func(gid interface{}, pid interface{}, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_TransferGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_TransferGroup_Call) Return(_a0 *gitlab.Group, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_TransferGroup_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_TransferGroup_Call) RunAndReturn(run func(interface{}, interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Group, *gitlab.Response, error)) *GroupsServiceInterface_TransferGroup_Call {
	_c.Call.Return(run)
	return _c
}

// TransferSubGroup provides a mock function with given fields: gid, opt, options
func (_m *GroupsServiceInterface) TransferSubGroup(gid interface{}, opt *gitlab.TransferSubGroupOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Group, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TransferSubGroup")
	}

	var r0 *gitlab.Group
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.TransferSubGroupOptions, ...gitlab.RequestOptionFunc) (*gitlab.Group, *gitlab.Response, error)); ok {
		return rf(gid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.TransferSubGroupOptions, ...gitlab.RequestOptionFunc) *gitlab.Group); ok {
		r0 = rf(gid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.TransferSubGroupOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.TransferSubGroupOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_TransferSubGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TransferSubGroup'
type GroupsServiceInterface_TransferSubGroup_Call struct {
	*mock.Call
}

// TransferSubGroup is a helper method to define mock.On call
//   - gid interface{}
//   - opt *gitlab.TransferSubGroupOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) TransferSubGroup(gid interface{}, opt interface{}, options ...interface{}) *GroupsServiceInterface_TransferSubGroup_Call {
	return &GroupsServiceInterface_TransferSubGroup_Call{Call: _e.mock.On("TransferSubGroup",
		append([]interface{}{gid, opt}, options...)...)}
}

func (_c *GroupsServiceInterface_TransferSubGroup_Call) Run(run func(gid interface{}, opt *gitlab.TransferSubGroupOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_TransferSubGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.TransferSubGroupOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_TransferSubGroup_Call) Return(_a0 *gitlab.Group, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_TransferSubGroup_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_TransferSubGroup_Call) RunAndReturn(run func(interface{}, *gitlab.TransferSubGroupOptions, ...gitlab.RequestOptionFunc) (*gitlab.Group, *gitlab.Response, error)) *GroupsServiceInterface_TransferSubGroup_Call {
	_c.Call.Return(run)
	return _c
}

// TriggerTestGroupHook provides a mock function with given fields: pid, hook, trigger, options
func (_m *GroupsServiceInterface) TriggerTestGroupHook(pid interface{}, hook int, trigger gitlab.GroupHookTrigger, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, hook, trigger)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TriggerTestGroupHook")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, gitlab.GroupHookTrigger, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, hook, trigger, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, gitlab.GroupHookTrigger, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, hook, trigger, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, gitlab.GroupHookTrigger, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, hook, trigger, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupsServiceInterface_TriggerTestGroupHook_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TriggerTestGroupHook'
type GroupsServiceInterface_TriggerTestGroupHook_Call struct {
	*mock.Call
}

// TriggerTestGroupHook is a helper method to define mock.On call
//   - pid interface{}
//   - hook int
//   - trigger gitlab.GroupHookTrigger
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) TriggerTestGroupHook(pid interface{}, hook interface{}, trigger interface{}, options ...interface{}) *GroupsServiceInterface_TriggerTestGroupHook_Call {
	return &GroupsServiceInterface_TriggerTestGroupHook_Call{Call: _e.mock.On("TriggerTestGroupHook",
		append([]interface{}{pid, hook, trigger}, options...)...)}
}

func (_c *GroupsServiceInterface_TriggerTestGroupHook_Call) Run(run func(pid interface{}, hook int, trigger gitlab.GroupHookTrigger, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_TriggerTestGroupHook_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(gitlab.GroupHookTrigger), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_TriggerTestGroupHook_Call) Return(_a0 *gitlab.Response, _a1 error) *GroupsServiceInterface_TriggerTestGroupHook_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GroupsServiceInterface_TriggerTestGroupHook_Call) RunAndReturn(run func(interface{}, int, gitlab.GroupHookTrigger, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *GroupsServiceInterface_TriggerTestGroupHook_Call {
	_c.Call.Return(run)
	return _c
}

// UnshareGroupFromGroup provides a mock function with given fields: gid, groupID, options
func (_m *GroupsServiceInterface) UnshareGroupFromGroup(gid interface{}, groupID int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, groupID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnshareGroupFromGroup")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(gid, groupID, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(gid, groupID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(gid, groupID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GroupsServiceInterface_UnshareGroupFromGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnshareGroupFromGroup'
type GroupsServiceInterface_UnshareGroupFromGroup_Call struct {
	*mock.Call
}

// UnshareGroupFromGroup is a helper method to define mock.On call
//   - gid interface{}
//   - groupID int
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) UnshareGroupFromGroup(gid interface{}, groupID interface{}, options ...interface{}) *GroupsServiceInterface_UnshareGroupFromGroup_Call {
	return &GroupsServiceInterface_UnshareGroupFromGroup_Call{Call: _e.mock.On("UnshareGroupFromGroup",
		append([]interface{}{gid, groupID}, options...)...)}
}

func (_c *GroupsServiceInterface_UnshareGroupFromGroup_Call) Run(run func(gid interface{}, groupID int, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_UnshareGroupFromGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_UnshareGroupFromGroup_Call) Return(_a0 *gitlab.Response, _a1 error) *GroupsServiceInterface_UnshareGroupFromGroup_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *GroupsServiceInterface_UnshareGroupFromGroup_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *GroupsServiceInterface_UnshareGroupFromGroup_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateGroup provides a mock function with given fields: gid, opt, options
func (_m *GroupsServiceInterface) UpdateGroup(gid interface{}, opt *gitlab.UpdateGroupOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Group, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateGroup")
	}

	var r0 *gitlab.Group
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.UpdateGroupOptions, ...gitlab.RequestOptionFunc) (*gitlab.Group, *gitlab.Response, error)); ok {
		return rf(gid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.UpdateGroupOptions, ...gitlab.RequestOptionFunc) *gitlab.Group); ok {
		r0 = rf(gid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.UpdateGroupOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.UpdateGroupOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_UpdateGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateGroup'
type GroupsServiceInterface_UpdateGroup_Call struct {
	*mock.Call
}

// UpdateGroup is a helper method to define mock.On call
//   - gid interface{}
//   - opt *gitlab.UpdateGroupOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) UpdateGroup(gid interface{}, opt interface{}, options ...interface{}) *GroupsServiceInterface_UpdateGroup_Call {
	return &GroupsServiceInterface_UpdateGroup_Call{Call: _e.mock.On("UpdateGroup",
		append([]interface{}{gid, opt}, options...)...)}
}

func (_c *GroupsServiceInterface_UpdateGroup_Call) Run(run func(gid interface{}, opt *gitlab.UpdateGroupOptions, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_UpdateGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.UpdateGroupOptions), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_UpdateGroup_Call) Return(_a0 *gitlab.Group, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_UpdateGroup_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_UpdateGroup_Call) RunAndReturn(run func(interface{}, *gitlab.UpdateGroupOptions, ...gitlab.RequestOptionFunc) (*gitlab.Group, *gitlab.Response, error)) *GroupsServiceInterface_UpdateGroup_Call {
	_c.Call.Return(run)
	return _c
}

// UploadAvatar provides a mock function with given fields: gid, avatar, filename, options
func (_m *GroupsServiceInterface) UploadAvatar(gid interface{}, avatar io.Reader, filename string, options ...gitlab.RequestOptionFunc) (*gitlab.Group, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, avatar, filename)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UploadAvatar")
	}

	var r0 *gitlab.Group
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, io.Reader, string, ...gitlab.RequestOptionFunc) (*gitlab.Group, *gitlab.Response, error)); ok {
		return rf(gid, avatar, filename, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, io.Reader, string, ...gitlab.RequestOptionFunc) *gitlab.Group); ok {
		r0 = rf(gid, avatar, filename, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Group)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, io.Reader, string, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, avatar, filename, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, io.Reader, string, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, avatar, filename, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GroupsServiceInterface_UploadAvatar_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UploadAvatar'
type GroupsServiceInterface_UploadAvatar_Call struct {
	*mock.Call
}

// UploadAvatar is a helper method to define mock.On call
//   - gid interface{}
//   - avatar io.Reader
//   - filename string
//   - options ...gitlab.RequestOptionFunc
func (_e *GroupsServiceInterface_Expecter) UploadAvatar(gid interface{}, avatar interface{}, filename interface{}, options ...interface{}) *GroupsServiceInterface_UploadAvatar_Call {
	return &GroupsServiceInterface_UploadAvatar_Call{Call: _e.mock.On("UploadAvatar",
		append([]interface{}{gid, avatar, filename}, options...)...)}
}

func (_c *GroupsServiceInterface_UploadAvatar_Call) Run(run func(gid interface{}, avatar io.Reader, filename string, options ...gitlab.RequestOptionFunc)) *GroupsServiceInterface_UploadAvatar_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(io.Reader), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *GroupsServiceInterface_UploadAvatar_Call) Return(_a0 *gitlab.Group, _a1 *gitlab.Response, _a2 error) *GroupsServiceInterface_UploadAvatar_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *GroupsServiceInterface_UploadAvatar_Call) RunAndReturn(run func(interface{}, io.Reader, string, ...gitlab.RequestOptionFunc) (*gitlab.Group, *gitlab.Response, error)) *GroupsServiceInterface_UploadAvatar_Call {
	_c.Call.Return(run)
	return _c
}

// NewGroupsServiceInterface creates a new instance of GroupsServiceInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewGroupsServiceInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *GroupsServiceInterface {
	mock := &GroupsServiceInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

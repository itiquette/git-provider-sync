// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"
	gitlab "gitlab.com/gitlab-org/api/client-go"
)

// ContainerRegistryServiceInterface is an autogenerated mock type for the ContainerRegistryServiceInterface type
type ContainerRegistryServiceInterface struct {
	mock.Mock
}

type ContainerRegistryServiceInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *ContainerRegistryServiceInterface) EXPECT() *ContainerRegistryServiceInterface_Expecter {
	return &ContainerRegistryServiceInterface_Expecter{mock: &_m.Mock}
}

// DeleteRegistryRepository provides a mock function with given fields: pid, repository, options
func (_m *ContainerRegistryServiceInterface) DeleteRegistryRepository(pid interface{}, repository int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, repository)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRegistryRepository")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, repository, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, repository, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, repository, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ContainerRegistryServiceInterface_DeleteRegistryRepository_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRegistryRepository'
type ContainerRegistryServiceInterface_DeleteRegistryRepository_Call struct {
	*mock.Call
}

// DeleteRegistryRepository is a helper method to define mock.On call
//   - pid interface{}
//   - repository int
//   - options ...gitlab.RequestOptionFunc
func (_e *ContainerRegistryServiceInterface_Expecter) DeleteRegistryRepository(pid interface{}, repository interface{}, options ...interface{}) *ContainerRegistryServiceInterface_DeleteRegistryRepository_Call {
	return &ContainerRegistryServiceInterface_DeleteRegistryRepository_Call{Call: _e.mock.On("DeleteRegistryRepository",
		append([]interface{}{pid, repository}, options...)...)}
}

func (_c *ContainerRegistryServiceInterface_DeleteRegistryRepository_Call) Run(run func(pid interface{}, repository int, options ...gitlab.RequestOptionFunc)) *ContainerRegistryServiceInterface_DeleteRegistryRepository_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *ContainerRegistryServiceInterface_DeleteRegistryRepository_Call) Return(_a0 *gitlab.Response, _a1 error) *ContainerRegistryServiceInterface_DeleteRegistryRepository_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ContainerRegistryServiceInterface_DeleteRegistryRepository_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ContainerRegistryServiceInterface_DeleteRegistryRepository_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRegistryRepositoryTag provides a mock function with given fields: pid, repository, tagName, options
func (_m *ContainerRegistryServiceInterface) DeleteRegistryRepositoryTag(pid interface{}, repository int, tagName string, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, repository, tagName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRegistryRepositoryTag")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, repository, tagName, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, repository, tagName, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, repository, tagName, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ContainerRegistryServiceInterface_DeleteRegistryRepositoryTag_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRegistryRepositoryTag'
type ContainerRegistryServiceInterface_DeleteRegistryRepositoryTag_Call struct {
	*mock.Call
}

// DeleteRegistryRepositoryTag is a helper method to define mock.On call
//   - pid interface{}
//   - repository int
//   - tagName string
//   - options ...gitlab.RequestOptionFunc
func (_e *ContainerRegistryServiceInterface_Expecter) DeleteRegistryRepositoryTag(pid interface{}, repository interface{}, tagName interface{}, options ...interface{}) *ContainerRegistryServiceInterface_DeleteRegistryRepositoryTag_Call {
	return &ContainerRegistryServiceInterface_DeleteRegistryRepositoryTag_Call{Call: _e.mock.On("DeleteRegistryRepositoryTag",
		append([]interface{}{pid, repository, tagName}, options...)...)}
}

func (_c *ContainerRegistryServiceInterface_DeleteRegistryRepositoryTag_Call) Run(run func(pid interface{}, repository int, tagName string, options ...gitlab.RequestOptionFunc)) *ContainerRegistryServiceInterface_DeleteRegistryRepositoryTag_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *ContainerRegistryServiceInterface_DeleteRegistryRepositoryTag_Call) Return(_a0 *gitlab.Response, _a1 error) *ContainerRegistryServiceInterface_DeleteRegistryRepositoryTag_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ContainerRegistryServiceInterface_DeleteRegistryRepositoryTag_Call) RunAndReturn(run func(interface{}, int, string, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ContainerRegistryServiceInterface_DeleteRegistryRepositoryTag_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRegistryRepositoryTags provides a mock function with given fields: pid, repository, opt, options
func (_m *ContainerRegistryServiceInterface) DeleteRegistryRepositoryTags(pid interface{}, repository int, opt *gitlab.DeleteRegistryRepositoryTagsOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, repository, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRegistryRepositoryTags")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.DeleteRegistryRepositoryTagsOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, repository, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.DeleteRegistryRepositoryTagsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, repository, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.DeleteRegistryRepositoryTagsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, repository, opt, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ContainerRegistryServiceInterface_DeleteRegistryRepositoryTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRegistryRepositoryTags'
type ContainerRegistryServiceInterface_DeleteRegistryRepositoryTags_Call struct {
	*mock.Call
}

// DeleteRegistryRepositoryTags is a helper method to define mock.On call
//   - pid interface{}
//   - repository int
//   - opt *gitlab.DeleteRegistryRepositoryTagsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ContainerRegistryServiceInterface_Expecter) DeleteRegistryRepositoryTags(pid interface{}, repository interface{}, opt interface{}, options ...interface{}) *ContainerRegistryServiceInterface_DeleteRegistryRepositoryTags_Call {
	return &ContainerRegistryServiceInterface_DeleteRegistryRepositoryTags_Call{Call: _e.mock.On("DeleteRegistryRepositoryTags",
		append([]interface{}{pid, repository, opt}, options...)...)}
}

func (_c *ContainerRegistryServiceInterface_DeleteRegistryRepositoryTags_Call) Run(run func(pid interface{}, repository int, opt *gitlab.DeleteRegistryRepositoryTagsOptions, options ...gitlab.RequestOptionFunc)) *ContainerRegistryServiceInterface_DeleteRegistryRepositoryTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.DeleteRegistryRepositoryTagsOptions), variadicArgs...)
	})
	return _c
}

func (_c *ContainerRegistryServiceInterface_DeleteRegistryRepositoryTags_Call) Return(_a0 *gitlab.Response, _a1 error) *ContainerRegistryServiceInterface_DeleteRegistryRepositoryTags_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ContainerRegistryServiceInterface_DeleteRegistryRepositoryTags_Call) RunAndReturn(run func(interface{}, int, *gitlab.DeleteRegistryRepositoryTagsOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ContainerRegistryServiceInterface_DeleteRegistryRepositoryTags_Call {
	_c.Call.Return(run)
	return _c
}

// GetRegistryRepositoryTagDetail provides a mock function with given fields: pid, repository, tagName, options
func (_m *ContainerRegistryServiceInterface) GetRegistryRepositoryTagDetail(pid interface{}, repository int, tagName string, options ...gitlab.RequestOptionFunc) (*gitlab.RegistryRepositoryTag, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, repository, tagName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRegistryRepositoryTagDetail")
	}

	var r0 *gitlab.RegistryRepositoryTag
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) (*gitlab.RegistryRepositoryTag, *gitlab.Response, error)); ok {
		return rf(pid, repository, tagName, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) *gitlab.RegistryRepositoryTag); ok {
		r0 = rf(pid, repository, tagName, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.RegistryRepositoryTag)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, repository, tagName, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, repository, tagName, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ContainerRegistryServiceInterface_GetRegistryRepositoryTagDetail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRegistryRepositoryTagDetail'
type ContainerRegistryServiceInterface_GetRegistryRepositoryTagDetail_Call struct {
	*mock.Call
}

// GetRegistryRepositoryTagDetail is a helper method to define mock.On call
//   - pid interface{}
//   - repository int
//   - tagName string
//   - options ...gitlab.RequestOptionFunc
func (_e *ContainerRegistryServiceInterface_Expecter) GetRegistryRepositoryTagDetail(pid interface{}, repository interface{}, tagName interface{}, options ...interface{}) *ContainerRegistryServiceInterface_GetRegistryRepositoryTagDetail_Call {
	return &ContainerRegistryServiceInterface_GetRegistryRepositoryTagDetail_Call{Call: _e.mock.On("GetRegistryRepositoryTagDetail",
		append([]interface{}{pid, repository, tagName}, options...)...)}
}

func (_c *ContainerRegistryServiceInterface_GetRegistryRepositoryTagDetail_Call) Run(run func(pid interface{}, repository int, tagName string, options ...gitlab.RequestOptionFunc)) *ContainerRegistryServiceInterface_GetRegistryRepositoryTagDetail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *ContainerRegistryServiceInterface_GetRegistryRepositoryTagDetail_Call) Return(_a0 *gitlab.RegistryRepositoryTag, _a1 *gitlab.Response, _a2 error) *ContainerRegistryServiceInterface_GetRegistryRepositoryTagDetail_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ContainerRegistryServiceInterface_GetRegistryRepositoryTagDetail_Call) RunAndReturn(run func(interface{}, int, string, ...gitlab.RequestOptionFunc) (*gitlab.RegistryRepositoryTag, *gitlab.Response, error)) *ContainerRegistryServiceInterface_GetRegistryRepositoryTagDetail_Call {
	_c.Call.Return(run)
	return _c
}

// GetSingleRegistryRepository provides a mock function with given fields: pid, opt, options
func (_m *ContainerRegistryServiceInterface) GetSingleRegistryRepository(pid interface{}, opt *gitlab.GetSingleRegistryRepositoryOptions, options ...gitlab.RequestOptionFunc) (*gitlab.RegistryRepository, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSingleRegistryRepository")
	}

	var r0 *gitlab.RegistryRepository
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.GetSingleRegistryRepositoryOptions, ...gitlab.RequestOptionFunc) (*gitlab.RegistryRepository, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.GetSingleRegistryRepositoryOptions, ...gitlab.RequestOptionFunc) *gitlab.RegistryRepository); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.RegistryRepository)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.GetSingleRegistryRepositoryOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.GetSingleRegistryRepositoryOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ContainerRegistryServiceInterface_GetSingleRegistryRepository_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSingleRegistryRepository'
type ContainerRegistryServiceInterface_GetSingleRegistryRepository_Call struct {
	*mock.Call
}

// GetSingleRegistryRepository is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.GetSingleRegistryRepositoryOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ContainerRegistryServiceInterface_Expecter) GetSingleRegistryRepository(pid interface{}, opt interface{}, options ...interface{}) *ContainerRegistryServiceInterface_GetSingleRegistryRepository_Call {
	return &ContainerRegistryServiceInterface_GetSingleRegistryRepository_Call{Call: _e.mock.On("GetSingleRegistryRepository",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ContainerRegistryServiceInterface_GetSingleRegistryRepository_Call) Run(run func(pid interface{}, opt *gitlab.GetSingleRegistryRepositoryOptions, options ...gitlab.RequestOptionFunc)) *ContainerRegistryServiceInterface_GetSingleRegistryRepository_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.GetSingleRegistryRepositoryOptions), variadicArgs...)
	})
	return _c
}

func (_c *ContainerRegistryServiceInterface_GetSingleRegistryRepository_Call) Return(_a0 *gitlab.RegistryRepository, _a1 *gitlab.Response, _a2 error) *ContainerRegistryServiceInterface_GetSingleRegistryRepository_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ContainerRegistryServiceInterface_GetSingleRegistryRepository_Call) RunAndReturn(run func(interface{}, *gitlab.GetSingleRegistryRepositoryOptions, ...gitlab.RequestOptionFunc) (*gitlab.RegistryRepository, *gitlab.Response, error)) *ContainerRegistryServiceInterface_GetSingleRegistryRepository_Call {
	_c.Call.Return(run)
	return _c
}

// ListGroupRegistryRepositories provides a mock function with given fields: gid, opt, options
func (_m *ContainerRegistryServiceInterface) ListGroupRegistryRepositories(gid interface{}, opt *gitlab.ListRegistryRepositoriesOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.RegistryRepository, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListGroupRegistryRepositories")
	}

	var r0 []*gitlab.RegistryRepository
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListRegistryRepositoriesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.RegistryRepository, *gitlab.Response, error)); ok {
		return rf(gid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListRegistryRepositoriesOptions, ...gitlab.RequestOptionFunc) []*gitlab.RegistryRepository); ok {
		r0 = rf(gid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.RegistryRepository)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListRegistryRepositoriesOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListRegistryRepositoriesOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ContainerRegistryServiceInterface_ListGroupRegistryRepositories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListGroupRegistryRepositories'
type ContainerRegistryServiceInterface_ListGroupRegistryRepositories_Call struct {
	*mock.Call
}

// ListGroupRegistryRepositories is a helper method to define mock.On call
//   - gid interface{}
//   - opt *gitlab.ListRegistryRepositoriesOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ContainerRegistryServiceInterface_Expecter) ListGroupRegistryRepositories(gid interface{}, opt interface{}, options ...interface{}) *ContainerRegistryServiceInterface_ListGroupRegistryRepositories_Call {
	return &ContainerRegistryServiceInterface_ListGroupRegistryRepositories_Call{Call: _e.mock.On("ListGroupRegistryRepositories",
		append([]interface{}{gid, opt}, options...)...)}
}

func (_c *ContainerRegistryServiceInterface_ListGroupRegistryRepositories_Call) Run(run func(gid interface{}, opt *gitlab.ListRegistryRepositoriesOptions, options ...gitlab.RequestOptionFunc)) *ContainerRegistryServiceInterface_ListGroupRegistryRepositories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListRegistryRepositoriesOptions), variadicArgs...)
	})
	return _c
}

func (_c *ContainerRegistryServiceInterface_ListGroupRegistryRepositories_Call) Return(_a0 []*gitlab.RegistryRepository, _a1 *gitlab.Response, _a2 error) *ContainerRegistryServiceInterface_ListGroupRegistryRepositories_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ContainerRegistryServiceInterface_ListGroupRegistryRepositories_Call) RunAndReturn(run func(interface{}, *gitlab.ListRegistryRepositoriesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.RegistryRepository, *gitlab.Response, error)) *ContainerRegistryServiceInterface_ListGroupRegistryRepositories_Call {
	_c.Call.Return(run)
	return _c
}

// ListProjectRegistryRepositories provides a mock function with given fields: pid, opt, options
func (_m *ContainerRegistryServiceInterface) ListProjectRegistryRepositories(pid interface{}, opt *gitlab.ListRegistryRepositoriesOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.RegistryRepository, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListProjectRegistryRepositories")
	}

	var r0 []*gitlab.RegistryRepository
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListRegistryRepositoriesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.RegistryRepository, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListRegistryRepositoriesOptions, ...gitlab.RequestOptionFunc) []*gitlab.RegistryRepository); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.RegistryRepository)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListRegistryRepositoriesOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListRegistryRepositoriesOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ContainerRegistryServiceInterface_ListProjectRegistryRepositories_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListProjectRegistryRepositories'
type ContainerRegistryServiceInterface_ListProjectRegistryRepositories_Call struct {
	*mock.Call
}

// ListProjectRegistryRepositories is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.ListRegistryRepositoriesOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ContainerRegistryServiceInterface_Expecter) ListProjectRegistryRepositories(pid interface{}, opt interface{}, options ...interface{}) *ContainerRegistryServiceInterface_ListProjectRegistryRepositories_Call {
	return &ContainerRegistryServiceInterface_ListProjectRegistryRepositories_Call{Call: _e.mock.On("ListProjectRegistryRepositories",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ContainerRegistryServiceInterface_ListProjectRegistryRepositories_Call) Run(run func(pid interface{}, opt *gitlab.ListRegistryRepositoriesOptions, options ...gitlab.RequestOptionFunc)) *ContainerRegistryServiceInterface_ListProjectRegistryRepositories_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListRegistryRepositoriesOptions), variadicArgs...)
	})
	return _c
}

func (_c *ContainerRegistryServiceInterface_ListProjectRegistryRepositories_Call) Return(_a0 []*gitlab.RegistryRepository, _a1 *gitlab.Response, _a2 error) *ContainerRegistryServiceInterface_ListProjectRegistryRepositories_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ContainerRegistryServiceInterface_ListProjectRegistryRepositories_Call) RunAndReturn(run func(interface{}, *gitlab.ListRegistryRepositoriesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.RegistryRepository, *gitlab.Response, error)) *ContainerRegistryServiceInterface_ListProjectRegistryRepositories_Call {
	_c.Call.Return(run)
	return _c
}

// ListRegistryRepositoryTags provides a mock function with given fields: pid, repository, opt, options
func (_m *ContainerRegistryServiceInterface) ListRegistryRepositoryTags(pid interface{}, repository int, opt *gitlab.ListRegistryRepositoryTagsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.RegistryRepositoryTag, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, repository, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRegistryRepositoryTags")
	}

	var r0 []*gitlab.RegistryRepositoryTag
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListRegistryRepositoryTagsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.RegistryRepositoryTag, *gitlab.Response, error)); ok {
		return rf(pid, repository, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListRegistryRepositoryTagsOptions, ...gitlab.RequestOptionFunc) []*gitlab.RegistryRepositoryTag); ok {
		r0 = rf(pid, repository, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.RegistryRepositoryTag)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.ListRegistryRepositoryTagsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, repository, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.ListRegistryRepositoryTagsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, repository, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ContainerRegistryServiceInterface_ListRegistryRepositoryTags_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRegistryRepositoryTags'
type ContainerRegistryServiceInterface_ListRegistryRepositoryTags_Call struct {
	*mock.Call
}

// ListRegistryRepositoryTags is a helper method to define mock.On call
//   - pid interface{}
//   - repository int
//   - opt *gitlab.ListRegistryRepositoryTagsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ContainerRegistryServiceInterface_Expecter) ListRegistryRepositoryTags(pid interface{}, repository interface{}, opt interface{}, options ...interface{}) *ContainerRegistryServiceInterface_ListRegistryRepositoryTags_Call {
	return &ContainerRegistryServiceInterface_ListRegistryRepositoryTags_Call{Call: _e.mock.On("ListRegistryRepositoryTags",
		append([]interface{}{pid, repository, opt}, options...)...)}
}

func (_c *ContainerRegistryServiceInterface_ListRegistryRepositoryTags_Call) Run(run func(pid interface{}, repository int, opt *gitlab.ListRegistryRepositoryTagsOptions, options ...gitlab.RequestOptionFunc)) *ContainerRegistryServiceInterface_ListRegistryRepositoryTags_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.ListRegistryRepositoryTagsOptions), variadicArgs...)
	})
	return _c
}

func (_c *ContainerRegistryServiceInterface_ListRegistryRepositoryTags_Call) Return(_a0 []*gitlab.RegistryRepositoryTag, _a1 *gitlab.Response, _a2 error) *ContainerRegistryServiceInterface_ListRegistryRepositoryTags_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ContainerRegistryServiceInterface_ListRegistryRepositoryTags_Call) RunAndReturn(run func(interface{}, int, *gitlab.ListRegistryRepositoryTagsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.RegistryRepositoryTag, *gitlab.Response, error)) *ContainerRegistryServiceInterface_ListRegistryRepositoryTags_Call {
	_c.Call.Return(run)
	return _c
}

// NewContainerRegistryServiceInterface creates a new instance of ContainerRegistryServiceInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewContainerRegistryServiceInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *ContainerRegistryServiceInterface {
	mock := &ContainerRegistryServiceInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

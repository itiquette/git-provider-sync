// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"
	gitlab "gitlab.com/gitlab-org/api/client-go"
)

// PipelineSchedulesServiceInterface is an autogenerated mock type for the PipelineSchedulesServiceInterface type
type PipelineSchedulesServiceInterface struct {
	mock.Mock
}

type PipelineSchedulesServiceInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *PipelineSchedulesServiceInterface) EXPECT() *PipelineSchedulesServiceInterface_Expecter {
	return &PipelineSchedulesServiceInterface_Expecter{mock: &_m.Mock}
}

// CreatePipelineSchedule provides a mock function with given fields: pid, opt, options
func (_m *PipelineSchedulesServiceInterface) CreatePipelineSchedule(pid interface{}, opt *gitlab.CreatePipelineScheduleOptions, options ...gitlab.RequestOptionFunc) (*gitlab.PipelineSchedule, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePipelineSchedule")
	}

	var r0 *gitlab.PipelineSchedule
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.CreatePipelineScheduleOptions, ...gitlab.RequestOptionFunc) (*gitlab.PipelineSchedule, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.CreatePipelineScheduleOptions, ...gitlab.RequestOptionFunc) *gitlab.PipelineSchedule); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.PipelineSchedule)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.CreatePipelineScheduleOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.CreatePipelineScheduleOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PipelineSchedulesServiceInterface_CreatePipelineSchedule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePipelineSchedule'
type PipelineSchedulesServiceInterface_CreatePipelineSchedule_Call struct {
	*mock.Call
}

// CreatePipelineSchedule is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.CreatePipelineScheduleOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *PipelineSchedulesServiceInterface_Expecter) CreatePipelineSchedule(pid interface{}, opt interface{}, options ...interface{}) *PipelineSchedulesServiceInterface_CreatePipelineSchedule_Call {
	return &PipelineSchedulesServiceInterface_CreatePipelineSchedule_Call{Call: _e.mock.On("CreatePipelineSchedule",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *PipelineSchedulesServiceInterface_CreatePipelineSchedule_Call) Run(run func(pid interface{}, opt *gitlab.CreatePipelineScheduleOptions, options ...gitlab.RequestOptionFunc)) *PipelineSchedulesServiceInterface_CreatePipelineSchedule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.CreatePipelineScheduleOptions), variadicArgs...)
	})
	return _c
}

func (_c *PipelineSchedulesServiceInterface_CreatePipelineSchedule_Call) Return(_a0 *gitlab.PipelineSchedule, _a1 *gitlab.Response, _a2 error) *PipelineSchedulesServiceInterface_CreatePipelineSchedule_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *PipelineSchedulesServiceInterface_CreatePipelineSchedule_Call) RunAndReturn(run func(interface{}, *gitlab.CreatePipelineScheduleOptions, ...gitlab.RequestOptionFunc) (*gitlab.PipelineSchedule, *gitlab.Response, error)) *PipelineSchedulesServiceInterface_CreatePipelineSchedule_Call {
	_c.Call.Return(run)
	return _c
}

// CreatePipelineScheduleVariable provides a mock function with given fields: pid, schedule, opt, options
func (_m *PipelineSchedulesServiceInterface) CreatePipelineScheduleVariable(pid interface{}, schedule int, opt *gitlab.CreatePipelineScheduleVariableOptions, options ...gitlab.RequestOptionFunc) (*gitlab.PipelineVariable, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, schedule, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePipelineScheduleVariable")
	}

	var r0 *gitlab.PipelineVariable
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.CreatePipelineScheduleVariableOptions, ...gitlab.RequestOptionFunc) (*gitlab.PipelineVariable, *gitlab.Response, error)); ok {
		return rf(pid, schedule, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.CreatePipelineScheduleVariableOptions, ...gitlab.RequestOptionFunc) *gitlab.PipelineVariable); ok {
		r0 = rf(pid, schedule, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.PipelineVariable)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.CreatePipelineScheduleVariableOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, schedule, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.CreatePipelineScheduleVariableOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, schedule, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PipelineSchedulesServiceInterface_CreatePipelineScheduleVariable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePipelineScheduleVariable'
type PipelineSchedulesServiceInterface_CreatePipelineScheduleVariable_Call struct {
	*mock.Call
}

// CreatePipelineScheduleVariable is a helper method to define mock.On call
//   - pid interface{}
//   - schedule int
//   - opt *gitlab.CreatePipelineScheduleVariableOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *PipelineSchedulesServiceInterface_Expecter) CreatePipelineScheduleVariable(pid interface{}, schedule interface{}, opt interface{}, options ...interface{}) *PipelineSchedulesServiceInterface_CreatePipelineScheduleVariable_Call {
	return &PipelineSchedulesServiceInterface_CreatePipelineScheduleVariable_Call{Call: _e.mock.On("CreatePipelineScheduleVariable",
		append([]interface{}{pid, schedule, opt}, options...)...)}
}

func (_c *PipelineSchedulesServiceInterface_CreatePipelineScheduleVariable_Call) Run(run func(pid interface{}, schedule int, opt *gitlab.CreatePipelineScheduleVariableOptions, options ...gitlab.RequestOptionFunc)) *PipelineSchedulesServiceInterface_CreatePipelineScheduleVariable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.CreatePipelineScheduleVariableOptions), variadicArgs...)
	})
	return _c
}

func (_c *PipelineSchedulesServiceInterface_CreatePipelineScheduleVariable_Call) Return(_a0 *gitlab.PipelineVariable, _a1 *gitlab.Response, _a2 error) *PipelineSchedulesServiceInterface_CreatePipelineScheduleVariable_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *PipelineSchedulesServiceInterface_CreatePipelineScheduleVariable_Call) RunAndReturn(run func(interface{}, int, *gitlab.CreatePipelineScheduleVariableOptions, ...gitlab.RequestOptionFunc) (*gitlab.PipelineVariable, *gitlab.Response, error)) *PipelineSchedulesServiceInterface_CreatePipelineScheduleVariable_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePipelineSchedule provides a mock function with given fields: pid, schedule, options
func (_m *PipelineSchedulesServiceInterface) DeletePipelineSchedule(pid interface{}, schedule int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, schedule)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePipelineSchedule")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, schedule, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, schedule, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, schedule, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PipelineSchedulesServiceInterface_DeletePipelineSchedule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePipelineSchedule'
type PipelineSchedulesServiceInterface_DeletePipelineSchedule_Call struct {
	*mock.Call
}

// DeletePipelineSchedule is a helper method to define mock.On call
//   - pid interface{}
//   - schedule int
//   - options ...gitlab.RequestOptionFunc
func (_e *PipelineSchedulesServiceInterface_Expecter) DeletePipelineSchedule(pid interface{}, schedule interface{}, options ...interface{}) *PipelineSchedulesServiceInterface_DeletePipelineSchedule_Call {
	return &PipelineSchedulesServiceInterface_DeletePipelineSchedule_Call{Call: _e.mock.On("DeletePipelineSchedule",
		append([]interface{}{pid, schedule}, options...)...)}
}

func (_c *PipelineSchedulesServiceInterface_DeletePipelineSchedule_Call) Run(run func(pid interface{}, schedule int, options ...gitlab.RequestOptionFunc)) *PipelineSchedulesServiceInterface_DeletePipelineSchedule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *PipelineSchedulesServiceInterface_DeletePipelineSchedule_Call) Return(_a0 *gitlab.Response, _a1 error) *PipelineSchedulesServiceInterface_DeletePipelineSchedule_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *PipelineSchedulesServiceInterface_DeletePipelineSchedule_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *PipelineSchedulesServiceInterface_DeletePipelineSchedule_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePipelineScheduleVariable provides a mock function with given fields: pid, schedule, key, options
func (_m *PipelineSchedulesServiceInterface) DeletePipelineScheduleVariable(pid interface{}, schedule int, key string, options ...gitlab.RequestOptionFunc) (*gitlab.PipelineVariable, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, schedule, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePipelineScheduleVariable")
	}

	var r0 *gitlab.PipelineVariable
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) (*gitlab.PipelineVariable, *gitlab.Response, error)); ok {
		return rf(pid, schedule, key, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) *gitlab.PipelineVariable); ok {
		r0 = rf(pid, schedule, key, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.PipelineVariable)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, schedule, key, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, schedule, key, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PipelineSchedulesServiceInterface_DeletePipelineScheduleVariable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePipelineScheduleVariable'
type PipelineSchedulesServiceInterface_DeletePipelineScheduleVariable_Call struct {
	*mock.Call
}

// DeletePipelineScheduleVariable is a helper method to define mock.On call
//   - pid interface{}
//   - schedule int
//   - key string
//   - options ...gitlab.RequestOptionFunc
func (_e *PipelineSchedulesServiceInterface_Expecter) DeletePipelineScheduleVariable(pid interface{}, schedule interface{}, key interface{}, options ...interface{}) *PipelineSchedulesServiceInterface_DeletePipelineScheduleVariable_Call {
	return &PipelineSchedulesServiceInterface_DeletePipelineScheduleVariable_Call{Call: _e.mock.On("DeletePipelineScheduleVariable",
		append([]interface{}{pid, schedule, key}, options...)...)}
}

func (_c *PipelineSchedulesServiceInterface_DeletePipelineScheduleVariable_Call) Run(run func(pid interface{}, schedule int, key string, options ...gitlab.RequestOptionFunc)) *PipelineSchedulesServiceInterface_DeletePipelineScheduleVariable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *PipelineSchedulesServiceInterface_DeletePipelineScheduleVariable_Call) Return(_a0 *gitlab.PipelineVariable, _a1 *gitlab.Response, _a2 error) *PipelineSchedulesServiceInterface_DeletePipelineScheduleVariable_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *PipelineSchedulesServiceInterface_DeletePipelineScheduleVariable_Call) RunAndReturn(run func(interface{}, int, string, ...gitlab.RequestOptionFunc) (*gitlab.PipelineVariable, *gitlab.Response, error)) *PipelineSchedulesServiceInterface_DeletePipelineScheduleVariable_Call {
	_c.Call.Return(run)
	return _c
}

// EditPipelineSchedule provides a mock function with given fields: pid, schedule, opt, options
func (_m *PipelineSchedulesServiceInterface) EditPipelineSchedule(pid interface{}, schedule int, opt *gitlab.EditPipelineScheduleOptions, options ...gitlab.RequestOptionFunc) (*gitlab.PipelineSchedule, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, schedule, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EditPipelineSchedule")
	}

	var r0 *gitlab.PipelineSchedule
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.EditPipelineScheduleOptions, ...gitlab.RequestOptionFunc) (*gitlab.PipelineSchedule, *gitlab.Response, error)); ok {
		return rf(pid, schedule, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.EditPipelineScheduleOptions, ...gitlab.RequestOptionFunc) *gitlab.PipelineSchedule); ok {
		r0 = rf(pid, schedule, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.PipelineSchedule)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.EditPipelineScheduleOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, schedule, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.EditPipelineScheduleOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, schedule, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PipelineSchedulesServiceInterface_EditPipelineSchedule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EditPipelineSchedule'
type PipelineSchedulesServiceInterface_EditPipelineSchedule_Call struct {
	*mock.Call
}

// EditPipelineSchedule is a helper method to define mock.On call
//   - pid interface{}
//   - schedule int
//   - opt *gitlab.EditPipelineScheduleOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *PipelineSchedulesServiceInterface_Expecter) EditPipelineSchedule(pid interface{}, schedule interface{}, opt interface{}, options ...interface{}) *PipelineSchedulesServiceInterface_EditPipelineSchedule_Call {
	return &PipelineSchedulesServiceInterface_EditPipelineSchedule_Call{Call: _e.mock.On("EditPipelineSchedule",
		append([]interface{}{pid, schedule, opt}, options...)...)}
}

func (_c *PipelineSchedulesServiceInterface_EditPipelineSchedule_Call) Run(run func(pid interface{}, schedule int, opt *gitlab.EditPipelineScheduleOptions, options ...gitlab.RequestOptionFunc)) *PipelineSchedulesServiceInterface_EditPipelineSchedule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.EditPipelineScheduleOptions), variadicArgs...)
	})
	return _c
}

func (_c *PipelineSchedulesServiceInterface_EditPipelineSchedule_Call) Return(_a0 *gitlab.PipelineSchedule, _a1 *gitlab.Response, _a2 error) *PipelineSchedulesServiceInterface_EditPipelineSchedule_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *PipelineSchedulesServiceInterface_EditPipelineSchedule_Call) RunAndReturn(run func(interface{}, int, *gitlab.EditPipelineScheduleOptions, ...gitlab.RequestOptionFunc) (*gitlab.PipelineSchedule, *gitlab.Response, error)) *PipelineSchedulesServiceInterface_EditPipelineSchedule_Call {
	_c.Call.Return(run)
	return _c
}

// EditPipelineScheduleVariable provides a mock function with given fields: pid, schedule, key, opt, options
func (_m *PipelineSchedulesServiceInterface) EditPipelineScheduleVariable(pid interface{}, schedule int, key string, opt *gitlab.EditPipelineScheduleVariableOptions, options ...gitlab.RequestOptionFunc) (*gitlab.PipelineVariable, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, schedule, key, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EditPipelineScheduleVariable")
	}

	var r0 *gitlab.PipelineVariable
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, string, *gitlab.EditPipelineScheduleVariableOptions, ...gitlab.RequestOptionFunc) (*gitlab.PipelineVariable, *gitlab.Response, error)); ok {
		return rf(pid, schedule, key, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, string, *gitlab.EditPipelineScheduleVariableOptions, ...gitlab.RequestOptionFunc) *gitlab.PipelineVariable); ok {
		r0 = rf(pid, schedule, key, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.PipelineVariable)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, string, *gitlab.EditPipelineScheduleVariableOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, schedule, key, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, string, *gitlab.EditPipelineScheduleVariableOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, schedule, key, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PipelineSchedulesServiceInterface_EditPipelineScheduleVariable_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EditPipelineScheduleVariable'
type PipelineSchedulesServiceInterface_EditPipelineScheduleVariable_Call struct {
	*mock.Call
}

// EditPipelineScheduleVariable is a helper method to define mock.On call
//   - pid interface{}
//   - schedule int
//   - key string
//   - opt *gitlab.EditPipelineScheduleVariableOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *PipelineSchedulesServiceInterface_Expecter) EditPipelineScheduleVariable(pid interface{}, schedule interface{}, key interface{}, opt interface{}, options ...interface{}) *PipelineSchedulesServiceInterface_EditPipelineScheduleVariable_Call {
	return &PipelineSchedulesServiceInterface_EditPipelineScheduleVariable_Call{Call: _e.mock.On("EditPipelineScheduleVariable",
		append([]interface{}{pid, schedule, key, opt}, options...)...)}
}

func (_c *PipelineSchedulesServiceInterface_EditPipelineScheduleVariable_Call) Run(run func(pid interface{}, schedule int, key string, opt *gitlab.EditPipelineScheduleVariableOptions, options ...gitlab.RequestOptionFunc)) *PipelineSchedulesServiceInterface_EditPipelineScheduleVariable_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(string), args[3].(*gitlab.EditPipelineScheduleVariableOptions), variadicArgs...)
	})
	return _c
}

func (_c *PipelineSchedulesServiceInterface_EditPipelineScheduleVariable_Call) Return(_a0 *gitlab.PipelineVariable, _a1 *gitlab.Response, _a2 error) *PipelineSchedulesServiceInterface_EditPipelineScheduleVariable_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *PipelineSchedulesServiceInterface_EditPipelineScheduleVariable_Call) RunAndReturn(run func(interface{}, int, string, *gitlab.EditPipelineScheduleVariableOptions, ...gitlab.RequestOptionFunc) (*gitlab.PipelineVariable, *gitlab.Response, error)) *PipelineSchedulesServiceInterface_EditPipelineScheduleVariable_Call {
	_c.Call.Return(run)
	return _c
}

// GetPipelineSchedule provides a mock function with given fields: pid, schedule, options
func (_m *PipelineSchedulesServiceInterface) GetPipelineSchedule(pid interface{}, schedule int, options ...gitlab.RequestOptionFunc) (*gitlab.PipelineSchedule, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, schedule)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPipelineSchedule")
	}

	var r0 *gitlab.PipelineSchedule
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.PipelineSchedule, *gitlab.Response, error)); ok {
		return rf(pid, schedule, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.PipelineSchedule); ok {
		r0 = rf(pid, schedule, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.PipelineSchedule)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, schedule, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, schedule, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PipelineSchedulesServiceInterface_GetPipelineSchedule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPipelineSchedule'
type PipelineSchedulesServiceInterface_GetPipelineSchedule_Call struct {
	*mock.Call
}

// GetPipelineSchedule is a helper method to define mock.On call
//   - pid interface{}
//   - schedule int
//   - options ...gitlab.RequestOptionFunc
func (_e *PipelineSchedulesServiceInterface_Expecter) GetPipelineSchedule(pid interface{}, schedule interface{}, options ...interface{}) *PipelineSchedulesServiceInterface_GetPipelineSchedule_Call {
	return &PipelineSchedulesServiceInterface_GetPipelineSchedule_Call{Call: _e.mock.On("GetPipelineSchedule",
		append([]interface{}{pid, schedule}, options...)...)}
}

func (_c *PipelineSchedulesServiceInterface_GetPipelineSchedule_Call) Run(run func(pid interface{}, schedule int, options ...gitlab.RequestOptionFunc)) *PipelineSchedulesServiceInterface_GetPipelineSchedule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *PipelineSchedulesServiceInterface_GetPipelineSchedule_Call) Return(_a0 *gitlab.PipelineSchedule, _a1 *gitlab.Response, _a2 error) *PipelineSchedulesServiceInterface_GetPipelineSchedule_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *PipelineSchedulesServiceInterface_GetPipelineSchedule_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.PipelineSchedule, *gitlab.Response, error)) *PipelineSchedulesServiceInterface_GetPipelineSchedule_Call {
	_c.Call.Return(run)
	return _c
}

// ListPipelineSchedules provides a mock function with given fields: pid, opt, options
func (_m *PipelineSchedulesServiceInterface) ListPipelineSchedules(pid interface{}, opt *gitlab.ListPipelineSchedulesOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.PipelineSchedule, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPipelineSchedules")
	}

	var r0 []*gitlab.PipelineSchedule
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListPipelineSchedulesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.PipelineSchedule, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListPipelineSchedulesOptions, ...gitlab.RequestOptionFunc) []*gitlab.PipelineSchedule); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.PipelineSchedule)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListPipelineSchedulesOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListPipelineSchedulesOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PipelineSchedulesServiceInterface_ListPipelineSchedules_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPipelineSchedules'
type PipelineSchedulesServiceInterface_ListPipelineSchedules_Call struct {
	*mock.Call
}

// ListPipelineSchedules is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.ListPipelineSchedulesOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *PipelineSchedulesServiceInterface_Expecter) ListPipelineSchedules(pid interface{}, opt interface{}, options ...interface{}) *PipelineSchedulesServiceInterface_ListPipelineSchedules_Call {
	return &PipelineSchedulesServiceInterface_ListPipelineSchedules_Call{Call: _e.mock.On("ListPipelineSchedules",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *PipelineSchedulesServiceInterface_ListPipelineSchedules_Call) Run(run func(pid interface{}, opt *gitlab.ListPipelineSchedulesOptions, options ...gitlab.RequestOptionFunc)) *PipelineSchedulesServiceInterface_ListPipelineSchedules_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListPipelineSchedulesOptions), variadicArgs...)
	})
	return _c
}

func (_c *PipelineSchedulesServiceInterface_ListPipelineSchedules_Call) Return(_a0 []*gitlab.PipelineSchedule, _a1 *gitlab.Response, _a2 error) *PipelineSchedulesServiceInterface_ListPipelineSchedules_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *PipelineSchedulesServiceInterface_ListPipelineSchedules_Call) RunAndReturn(run func(interface{}, *gitlab.ListPipelineSchedulesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.PipelineSchedule, *gitlab.Response, error)) *PipelineSchedulesServiceInterface_ListPipelineSchedules_Call {
	_c.Call.Return(run)
	return _c
}

// ListPipelinesTriggeredBySchedule provides a mock function with given fields: pid, schedule, opt, options
func (_m *PipelineSchedulesServiceInterface) ListPipelinesTriggeredBySchedule(pid interface{}, schedule int, opt *gitlab.ListPipelinesTriggeredByScheduleOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Pipeline, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, schedule, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPipelinesTriggeredBySchedule")
	}

	var r0 []*gitlab.Pipeline
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListPipelinesTriggeredByScheduleOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Pipeline, *gitlab.Response, error)); ok {
		return rf(pid, schedule, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListPipelinesTriggeredByScheduleOptions, ...gitlab.RequestOptionFunc) []*gitlab.Pipeline); ok {
		r0 = rf(pid, schedule, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Pipeline)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.ListPipelinesTriggeredByScheduleOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, schedule, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.ListPipelinesTriggeredByScheduleOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, schedule, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PipelineSchedulesServiceInterface_ListPipelinesTriggeredBySchedule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPipelinesTriggeredBySchedule'
type PipelineSchedulesServiceInterface_ListPipelinesTriggeredBySchedule_Call struct {
	*mock.Call
}

// ListPipelinesTriggeredBySchedule is a helper method to define mock.On call
//   - pid interface{}
//   - schedule int
//   - opt *gitlab.ListPipelinesTriggeredByScheduleOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *PipelineSchedulesServiceInterface_Expecter) ListPipelinesTriggeredBySchedule(pid interface{}, schedule interface{}, opt interface{}, options ...interface{}) *PipelineSchedulesServiceInterface_ListPipelinesTriggeredBySchedule_Call {
	return &PipelineSchedulesServiceInterface_ListPipelinesTriggeredBySchedule_Call{Call: _e.mock.On("ListPipelinesTriggeredBySchedule",
		append([]interface{}{pid, schedule, opt}, options...)...)}
}

func (_c *PipelineSchedulesServiceInterface_ListPipelinesTriggeredBySchedule_Call) Run(run func(pid interface{}, schedule int, opt *gitlab.ListPipelinesTriggeredByScheduleOptions, options ...gitlab.RequestOptionFunc)) *PipelineSchedulesServiceInterface_ListPipelinesTriggeredBySchedule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.ListPipelinesTriggeredByScheduleOptions), variadicArgs...)
	})
	return _c
}

func (_c *PipelineSchedulesServiceInterface_ListPipelinesTriggeredBySchedule_Call) Return(_a0 []*gitlab.Pipeline, _a1 *gitlab.Response, _a2 error) *PipelineSchedulesServiceInterface_ListPipelinesTriggeredBySchedule_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *PipelineSchedulesServiceInterface_ListPipelinesTriggeredBySchedule_Call) RunAndReturn(run func(interface{}, int, *gitlab.ListPipelinesTriggeredByScheduleOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Pipeline, *gitlab.Response, error)) *PipelineSchedulesServiceInterface_ListPipelinesTriggeredBySchedule_Call {
	_c.Call.Return(run)
	return _c
}

// RunPipelineSchedule provides a mock function with given fields: pid, schedule, options
func (_m *PipelineSchedulesServiceInterface) RunPipelineSchedule(pid interface{}, schedule int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, schedule)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RunPipelineSchedule")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, schedule, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, schedule, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, schedule, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PipelineSchedulesServiceInterface_RunPipelineSchedule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RunPipelineSchedule'
type PipelineSchedulesServiceInterface_RunPipelineSchedule_Call struct {
	*mock.Call
}

// RunPipelineSchedule is a helper method to define mock.On call
//   - pid interface{}
//   - schedule int
//   - options ...gitlab.RequestOptionFunc
func (_e *PipelineSchedulesServiceInterface_Expecter) RunPipelineSchedule(pid interface{}, schedule interface{}, options ...interface{}) *PipelineSchedulesServiceInterface_RunPipelineSchedule_Call {
	return &PipelineSchedulesServiceInterface_RunPipelineSchedule_Call{Call: _e.mock.On("RunPipelineSchedule",
		append([]interface{}{pid, schedule}, options...)...)}
}

func (_c *PipelineSchedulesServiceInterface_RunPipelineSchedule_Call) Run(run func(pid interface{}, schedule int, options ...gitlab.RequestOptionFunc)) *PipelineSchedulesServiceInterface_RunPipelineSchedule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *PipelineSchedulesServiceInterface_RunPipelineSchedule_Call) Return(_a0 *gitlab.Response, _a1 error) *PipelineSchedulesServiceInterface_RunPipelineSchedule_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *PipelineSchedulesServiceInterface_RunPipelineSchedule_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *PipelineSchedulesServiceInterface_RunPipelineSchedule_Call {
	_c.Call.Return(run)
	return _c
}

// TakeOwnershipOfPipelineSchedule provides a mock function with given fields: pid, schedule, options
func (_m *PipelineSchedulesServiceInterface) TakeOwnershipOfPipelineSchedule(pid interface{}, schedule int, options ...gitlab.RequestOptionFunc) (*gitlab.PipelineSchedule, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, schedule)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TakeOwnershipOfPipelineSchedule")
	}

	var r0 *gitlab.PipelineSchedule
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.PipelineSchedule, *gitlab.Response, error)); ok {
		return rf(pid, schedule, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.PipelineSchedule); ok {
		r0 = rf(pid, schedule, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.PipelineSchedule)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, schedule, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, schedule, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PipelineSchedulesServiceInterface_TakeOwnershipOfPipelineSchedule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TakeOwnershipOfPipelineSchedule'
type PipelineSchedulesServiceInterface_TakeOwnershipOfPipelineSchedule_Call struct {
	*mock.Call
}

// TakeOwnershipOfPipelineSchedule is a helper method to define mock.On call
//   - pid interface{}
//   - schedule int
//   - options ...gitlab.RequestOptionFunc
func (_e *PipelineSchedulesServiceInterface_Expecter) TakeOwnershipOfPipelineSchedule(pid interface{}, schedule interface{}, options ...interface{}) *PipelineSchedulesServiceInterface_TakeOwnershipOfPipelineSchedule_Call {
	return &PipelineSchedulesServiceInterface_TakeOwnershipOfPipelineSchedule_Call{Call: _e.mock.On("TakeOwnershipOfPipelineSchedule",
		append([]interface{}{pid, schedule}, options...)...)}
}

func (_c *PipelineSchedulesServiceInterface_TakeOwnershipOfPipelineSchedule_Call) Run(run func(pid interface{}, schedule int, options ...gitlab.RequestOptionFunc)) *PipelineSchedulesServiceInterface_TakeOwnershipOfPipelineSchedule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *PipelineSchedulesServiceInterface_TakeOwnershipOfPipelineSchedule_Call) Return(_a0 *gitlab.PipelineSchedule, _a1 *gitlab.Response, _a2 error) *PipelineSchedulesServiceInterface_TakeOwnershipOfPipelineSchedule_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *PipelineSchedulesServiceInterface_TakeOwnershipOfPipelineSchedule_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.PipelineSchedule, *gitlab.Response, error)) *PipelineSchedulesServiceInterface_TakeOwnershipOfPipelineSchedule_Call {
	_c.Call.Return(run)
	return _c
}

// NewPipelineSchedulesServiceInterface creates a new instance of PipelineSchedulesServiceInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPipelineSchedulesServiceInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *PipelineSchedulesServiceInterface {
	mock := &PipelineSchedulesServiceInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

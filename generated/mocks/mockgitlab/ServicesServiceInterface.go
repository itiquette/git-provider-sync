// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"
	gitlab "gitlab.com/gitlab-org/api/client-go"
)

// ServicesServiceInterface is an autogenerated mock type for the ServicesServiceInterface type
type ServicesServiceInterface struct {
	mock.Mock
}

type ServicesServiceInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *ServicesServiceInterface) EXPECT() *ServicesServiceInterface_Expecter {
	return &ServicesServiceInterface_Expecter{mock: &_m.Mock}
}

// DeleteCustomIssueTrackerService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) DeleteCustomIssueTrackerService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCustomIssueTrackerService")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServicesServiceInterface_DeleteCustomIssueTrackerService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteCustomIssueTrackerService'
type ServicesServiceInterface_DeleteCustomIssueTrackerService_Call struct {
	*mock.Call
}

// DeleteCustomIssueTrackerService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) DeleteCustomIssueTrackerService(pid interface{}, options ...interface{}) *ServicesServiceInterface_DeleteCustomIssueTrackerService_Call {
	return &ServicesServiceInterface_DeleteCustomIssueTrackerService_Call{Call: _e.mock.On("DeleteCustomIssueTrackerService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_DeleteCustomIssueTrackerService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_DeleteCustomIssueTrackerService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_DeleteCustomIssueTrackerService_Call) Return(_a0 *gitlab.Response, _a1 error) *ServicesServiceInterface_DeleteCustomIssueTrackerService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServicesServiceInterface_DeleteCustomIssueTrackerService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ServicesServiceInterface_DeleteCustomIssueTrackerService_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteDataDogService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) DeleteDataDogService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDataDogService")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServicesServiceInterface_DeleteDataDogService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteDataDogService'
type ServicesServiceInterface_DeleteDataDogService_Call struct {
	*mock.Call
}

// DeleteDataDogService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) DeleteDataDogService(pid interface{}, options ...interface{}) *ServicesServiceInterface_DeleteDataDogService_Call {
	return &ServicesServiceInterface_DeleteDataDogService_Call{Call: _e.mock.On("DeleteDataDogService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_DeleteDataDogService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_DeleteDataDogService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_DeleteDataDogService_Call) Return(_a0 *gitlab.Response, _a1 error) *ServicesServiceInterface_DeleteDataDogService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServicesServiceInterface_DeleteDataDogService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ServicesServiceInterface_DeleteDataDogService_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteDiscordService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) DeleteDiscordService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDiscordService")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServicesServiceInterface_DeleteDiscordService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteDiscordService'
type ServicesServiceInterface_DeleteDiscordService_Call struct {
	*mock.Call
}

// DeleteDiscordService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) DeleteDiscordService(pid interface{}, options ...interface{}) *ServicesServiceInterface_DeleteDiscordService_Call {
	return &ServicesServiceInterface_DeleteDiscordService_Call{Call: _e.mock.On("DeleteDiscordService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_DeleteDiscordService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_DeleteDiscordService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_DeleteDiscordService_Call) Return(_a0 *gitlab.Response, _a1 error) *ServicesServiceInterface_DeleteDiscordService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServicesServiceInterface_DeleteDiscordService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ServicesServiceInterface_DeleteDiscordService_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteDroneCIService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) DeleteDroneCIService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteDroneCIService")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServicesServiceInterface_DeleteDroneCIService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteDroneCIService'
type ServicesServiceInterface_DeleteDroneCIService_Call struct {
	*mock.Call
}

// DeleteDroneCIService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) DeleteDroneCIService(pid interface{}, options ...interface{}) *ServicesServiceInterface_DeleteDroneCIService_Call {
	return &ServicesServiceInterface_DeleteDroneCIService_Call{Call: _e.mock.On("DeleteDroneCIService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_DeleteDroneCIService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_DeleteDroneCIService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_DeleteDroneCIService_Call) Return(_a0 *gitlab.Response, _a1 error) *ServicesServiceInterface_DeleteDroneCIService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServicesServiceInterface_DeleteDroneCIService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ServicesServiceInterface_DeleteDroneCIService_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteEmailsOnPushService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) DeleteEmailsOnPushService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEmailsOnPushService")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServicesServiceInterface_DeleteEmailsOnPushService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteEmailsOnPushService'
type ServicesServiceInterface_DeleteEmailsOnPushService_Call struct {
	*mock.Call
}

// DeleteEmailsOnPushService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) DeleteEmailsOnPushService(pid interface{}, options ...interface{}) *ServicesServiceInterface_DeleteEmailsOnPushService_Call {
	return &ServicesServiceInterface_DeleteEmailsOnPushService_Call{Call: _e.mock.On("DeleteEmailsOnPushService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_DeleteEmailsOnPushService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_DeleteEmailsOnPushService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_DeleteEmailsOnPushService_Call) Return(_a0 *gitlab.Response, _a1 error) *ServicesServiceInterface_DeleteEmailsOnPushService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServicesServiceInterface_DeleteEmailsOnPushService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ServicesServiceInterface_DeleteEmailsOnPushService_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteExternalWikiService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) DeleteExternalWikiService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteExternalWikiService")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServicesServiceInterface_DeleteExternalWikiService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteExternalWikiService'
type ServicesServiceInterface_DeleteExternalWikiService_Call struct {
	*mock.Call
}

// DeleteExternalWikiService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) DeleteExternalWikiService(pid interface{}, options ...interface{}) *ServicesServiceInterface_DeleteExternalWikiService_Call {
	return &ServicesServiceInterface_DeleteExternalWikiService_Call{Call: _e.mock.On("DeleteExternalWikiService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_DeleteExternalWikiService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_DeleteExternalWikiService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_DeleteExternalWikiService_Call) Return(_a0 *gitlab.Response, _a1 error) *ServicesServiceInterface_DeleteExternalWikiService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServicesServiceInterface_DeleteExternalWikiService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ServicesServiceInterface_DeleteExternalWikiService_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteGitLabCIService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) DeleteGitLabCIService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGitLabCIService")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServicesServiceInterface_DeleteGitLabCIService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteGitLabCIService'
type ServicesServiceInterface_DeleteGitLabCIService_Call struct {
	*mock.Call
}

// DeleteGitLabCIService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) DeleteGitLabCIService(pid interface{}, options ...interface{}) *ServicesServiceInterface_DeleteGitLabCIService_Call {
	return &ServicesServiceInterface_DeleteGitLabCIService_Call{Call: _e.mock.On("DeleteGitLabCIService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_DeleteGitLabCIService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_DeleteGitLabCIService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_DeleteGitLabCIService_Call) Return(_a0 *gitlab.Response, _a1 error) *ServicesServiceInterface_DeleteGitLabCIService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServicesServiceInterface_DeleteGitLabCIService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ServicesServiceInterface_DeleteGitLabCIService_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteGithubService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) DeleteGithubService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGithubService")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServicesServiceInterface_DeleteGithubService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteGithubService'
type ServicesServiceInterface_DeleteGithubService_Call struct {
	*mock.Call
}

// DeleteGithubService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) DeleteGithubService(pid interface{}, options ...interface{}) *ServicesServiceInterface_DeleteGithubService_Call {
	return &ServicesServiceInterface_DeleteGithubService_Call{Call: _e.mock.On("DeleteGithubService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_DeleteGithubService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_DeleteGithubService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_DeleteGithubService_Call) Return(_a0 *gitlab.Response, _a1 error) *ServicesServiceInterface_DeleteGithubService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServicesServiceInterface_DeleteGithubService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ServicesServiceInterface_DeleteGithubService_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteHarborService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) DeleteHarborService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteHarborService")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServicesServiceInterface_DeleteHarborService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteHarborService'
type ServicesServiceInterface_DeleteHarborService_Call struct {
	*mock.Call
}

// DeleteHarborService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) DeleteHarborService(pid interface{}, options ...interface{}) *ServicesServiceInterface_DeleteHarborService_Call {
	return &ServicesServiceInterface_DeleteHarborService_Call{Call: _e.mock.On("DeleteHarborService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_DeleteHarborService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_DeleteHarborService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_DeleteHarborService_Call) Return(_a0 *gitlab.Response, _a1 error) *ServicesServiceInterface_DeleteHarborService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServicesServiceInterface_DeleteHarborService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ServicesServiceInterface_DeleteHarborService_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteHipChatService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) DeleteHipChatService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteHipChatService")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServicesServiceInterface_DeleteHipChatService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteHipChatService'
type ServicesServiceInterface_DeleteHipChatService_Call struct {
	*mock.Call
}

// DeleteHipChatService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) DeleteHipChatService(pid interface{}, options ...interface{}) *ServicesServiceInterface_DeleteHipChatService_Call {
	return &ServicesServiceInterface_DeleteHipChatService_Call{Call: _e.mock.On("DeleteHipChatService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_DeleteHipChatService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_DeleteHipChatService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_DeleteHipChatService_Call) Return(_a0 *gitlab.Response, _a1 error) *ServicesServiceInterface_DeleteHipChatService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServicesServiceInterface_DeleteHipChatService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ServicesServiceInterface_DeleteHipChatService_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteJenkinsCIService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) DeleteJenkinsCIService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteJenkinsCIService")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServicesServiceInterface_DeleteJenkinsCIService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteJenkinsCIService'
type ServicesServiceInterface_DeleteJenkinsCIService_Call struct {
	*mock.Call
}

// DeleteJenkinsCIService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) DeleteJenkinsCIService(pid interface{}, options ...interface{}) *ServicesServiceInterface_DeleteJenkinsCIService_Call {
	return &ServicesServiceInterface_DeleteJenkinsCIService_Call{Call: _e.mock.On("DeleteJenkinsCIService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_DeleteJenkinsCIService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_DeleteJenkinsCIService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_DeleteJenkinsCIService_Call) Return(_a0 *gitlab.Response, _a1 error) *ServicesServiceInterface_DeleteJenkinsCIService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServicesServiceInterface_DeleteJenkinsCIService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ServicesServiceInterface_DeleteJenkinsCIService_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteJiraService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) DeleteJiraService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteJiraService")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServicesServiceInterface_DeleteJiraService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteJiraService'
type ServicesServiceInterface_DeleteJiraService_Call struct {
	*mock.Call
}

// DeleteJiraService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) DeleteJiraService(pid interface{}, options ...interface{}) *ServicesServiceInterface_DeleteJiraService_Call {
	return &ServicesServiceInterface_DeleteJiraService_Call{Call: _e.mock.On("DeleteJiraService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_DeleteJiraService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_DeleteJiraService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_DeleteJiraService_Call) Return(_a0 *gitlab.Response, _a1 error) *ServicesServiceInterface_DeleteJiraService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServicesServiceInterface_DeleteJiraService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ServicesServiceInterface_DeleteJiraService_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteMattermostService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) DeleteMattermostService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMattermostService")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServicesServiceInterface_DeleteMattermostService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteMattermostService'
type ServicesServiceInterface_DeleteMattermostService_Call struct {
	*mock.Call
}

// DeleteMattermostService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) DeleteMattermostService(pid interface{}, options ...interface{}) *ServicesServiceInterface_DeleteMattermostService_Call {
	return &ServicesServiceInterface_DeleteMattermostService_Call{Call: _e.mock.On("DeleteMattermostService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_DeleteMattermostService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_DeleteMattermostService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_DeleteMattermostService_Call) Return(_a0 *gitlab.Response, _a1 error) *ServicesServiceInterface_DeleteMattermostService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServicesServiceInterface_DeleteMattermostService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ServicesServiceInterface_DeleteMattermostService_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteMattermostSlashCommandsService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) DeleteMattermostSlashCommandsService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMattermostSlashCommandsService")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServicesServiceInterface_DeleteMattermostSlashCommandsService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteMattermostSlashCommandsService'
type ServicesServiceInterface_DeleteMattermostSlashCommandsService_Call struct {
	*mock.Call
}

// DeleteMattermostSlashCommandsService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) DeleteMattermostSlashCommandsService(pid interface{}, options ...interface{}) *ServicesServiceInterface_DeleteMattermostSlashCommandsService_Call {
	return &ServicesServiceInterface_DeleteMattermostSlashCommandsService_Call{Call: _e.mock.On("DeleteMattermostSlashCommandsService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_DeleteMattermostSlashCommandsService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_DeleteMattermostSlashCommandsService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_DeleteMattermostSlashCommandsService_Call) Return(_a0 *gitlab.Response, _a1 error) *ServicesServiceInterface_DeleteMattermostSlashCommandsService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServicesServiceInterface_DeleteMattermostSlashCommandsService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ServicesServiceInterface_DeleteMattermostSlashCommandsService_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteMicrosoftTeamsService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) DeleteMicrosoftTeamsService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMicrosoftTeamsService")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServicesServiceInterface_DeleteMicrosoftTeamsService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteMicrosoftTeamsService'
type ServicesServiceInterface_DeleteMicrosoftTeamsService_Call struct {
	*mock.Call
}

// DeleteMicrosoftTeamsService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) DeleteMicrosoftTeamsService(pid interface{}, options ...interface{}) *ServicesServiceInterface_DeleteMicrosoftTeamsService_Call {
	return &ServicesServiceInterface_DeleteMicrosoftTeamsService_Call{Call: _e.mock.On("DeleteMicrosoftTeamsService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_DeleteMicrosoftTeamsService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_DeleteMicrosoftTeamsService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_DeleteMicrosoftTeamsService_Call) Return(_a0 *gitlab.Response, _a1 error) *ServicesServiceInterface_DeleteMicrosoftTeamsService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServicesServiceInterface_DeleteMicrosoftTeamsService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ServicesServiceInterface_DeleteMicrosoftTeamsService_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePipelinesEmailService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) DeletePipelinesEmailService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePipelinesEmailService")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServicesServiceInterface_DeletePipelinesEmailService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePipelinesEmailService'
type ServicesServiceInterface_DeletePipelinesEmailService_Call struct {
	*mock.Call
}

// DeletePipelinesEmailService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) DeletePipelinesEmailService(pid interface{}, options ...interface{}) *ServicesServiceInterface_DeletePipelinesEmailService_Call {
	return &ServicesServiceInterface_DeletePipelinesEmailService_Call{Call: _e.mock.On("DeletePipelinesEmailService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_DeletePipelinesEmailService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_DeletePipelinesEmailService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_DeletePipelinesEmailService_Call) Return(_a0 *gitlab.Response, _a1 error) *ServicesServiceInterface_DeletePipelinesEmailService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServicesServiceInterface_DeletePipelinesEmailService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ServicesServiceInterface_DeletePipelinesEmailService_Call {
	_c.Call.Return(run)
	return _c
}

// DeletePrometheusService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) DeletePrometheusService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeletePrometheusService")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServicesServiceInterface_DeletePrometheusService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeletePrometheusService'
type ServicesServiceInterface_DeletePrometheusService_Call struct {
	*mock.Call
}

// DeletePrometheusService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) DeletePrometheusService(pid interface{}, options ...interface{}) *ServicesServiceInterface_DeletePrometheusService_Call {
	return &ServicesServiceInterface_DeletePrometheusService_Call{Call: _e.mock.On("DeletePrometheusService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_DeletePrometheusService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_DeletePrometheusService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_DeletePrometheusService_Call) Return(_a0 *gitlab.Response, _a1 error) *ServicesServiceInterface_DeletePrometheusService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServicesServiceInterface_DeletePrometheusService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ServicesServiceInterface_DeletePrometheusService_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRedmineService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) DeleteRedmineService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRedmineService")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServicesServiceInterface_DeleteRedmineService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRedmineService'
type ServicesServiceInterface_DeleteRedmineService_Call struct {
	*mock.Call
}

// DeleteRedmineService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) DeleteRedmineService(pid interface{}, options ...interface{}) *ServicesServiceInterface_DeleteRedmineService_Call {
	return &ServicesServiceInterface_DeleteRedmineService_Call{Call: _e.mock.On("DeleteRedmineService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_DeleteRedmineService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_DeleteRedmineService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_DeleteRedmineService_Call) Return(_a0 *gitlab.Response, _a1 error) *ServicesServiceInterface_DeleteRedmineService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServicesServiceInterface_DeleteRedmineService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ServicesServiceInterface_DeleteRedmineService_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSlackService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) DeleteSlackService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSlackService")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServicesServiceInterface_DeleteSlackService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSlackService'
type ServicesServiceInterface_DeleteSlackService_Call struct {
	*mock.Call
}

// DeleteSlackService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) DeleteSlackService(pid interface{}, options ...interface{}) *ServicesServiceInterface_DeleteSlackService_Call {
	return &ServicesServiceInterface_DeleteSlackService_Call{Call: _e.mock.On("DeleteSlackService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_DeleteSlackService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_DeleteSlackService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_DeleteSlackService_Call) Return(_a0 *gitlab.Response, _a1 error) *ServicesServiceInterface_DeleteSlackService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServicesServiceInterface_DeleteSlackService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ServicesServiceInterface_DeleteSlackService_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSlackSlashCommandsService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) DeleteSlackSlashCommandsService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSlackSlashCommandsService")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServicesServiceInterface_DeleteSlackSlashCommandsService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSlackSlashCommandsService'
type ServicesServiceInterface_DeleteSlackSlashCommandsService_Call struct {
	*mock.Call
}

// DeleteSlackSlashCommandsService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) DeleteSlackSlashCommandsService(pid interface{}, options ...interface{}) *ServicesServiceInterface_DeleteSlackSlashCommandsService_Call {
	return &ServicesServiceInterface_DeleteSlackSlashCommandsService_Call{Call: _e.mock.On("DeleteSlackSlashCommandsService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_DeleteSlackSlashCommandsService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_DeleteSlackSlashCommandsService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_DeleteSlackSlashCommandsService_Call) Return(_a0 *gitlab.Response, _a1 error) *ServicesServiceInterface_DeleteSlackSlashCommandsService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServicesServiceInterface_DeleteSlackSlashCommandsService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ServicesServiceInterface_DeleteSlackSlashCommandsService_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTelegramService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) DeleteTelegramService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTelegramService")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServicesServiceInterface_DeleteTelegramService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTelegramService'
type ServicesServiceInterface_DeleteTelegramService_Call struct {
	*mock.Call
}

// DeleteTelegramService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) DeleteTelegramService(pid interface{}, options ...interface{}) *ServicesServiceInterface_DeleteTelegramService_Call {
	return &ServicesServiceInterface_DeleteTelegramService_Call{Call: _e.mock.On("DeleteTelegramService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_DeleteTelegramService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_DeleteTelegramService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_DeleteTelegramService_Call) Return(_a0 *gitlab.Response, _a1 error) *ServicesServiceInterface_DeleteTelegramService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServicesServiceInterface_DeleteTelegramService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ServicesServiceInterface_DeleteTelegramService_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteYouTrackService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) DeleteYouTrackService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteYouTrackService")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServicesServiceInterface_DeleteYouTrackService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteYouTrackService'
type ServicesServiceInterface_DeleteYouTrackService_Call struct {
	*mock.Call
}

// DeleteYouTrackService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) DeleteYouTrackService(pid interface{}, options ...interface{}) *ServicesServiceInterface_DeleteYouTrackService_Call {
	return &ServicesServiceInterface_DeleteYouTrackService_Call{Call: _e.mock.On("DeleteYouTrackService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_DeleteYouTrackService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_DeleteYouTrackService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_DeleteYouTrackService_Call) Return(_a0 *gitlab.Response, _a1 error) *ServicesServiceInterface_DeleteYouTrackService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServicesServiceInterface_DeleteYouTrackService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ServicesServiceInterface_DeleteYouTrackService_Call {
	_c.Call.Return(run)
	return _c
}

// DisableSlackApplication provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) DisableSlackApplication(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableSlackApplication")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServicesServiceInterface_DisableSlackApplication_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisableSlackApplication'
type ServicesServiceInterface_DisableSlackApplication_Call struct {
	*mock.Call
}

// DisableSlackApplication is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) DisableSlackApplication(pid interface{}, options ...interface{}) *ServicesServiceInterface_DisableSlackApplication_Call {
	return &ServicesServiceInterface_DisableSlackApplication_Call{Call: _e.mock.On("DisableSlackApplication",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_DisableSlackApplication_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_DisableSlackApplication_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_DisableSlackApplication_Call) Return(_a0 *gitlab.Response, _a1 error) *ServicesServiceInterface_DisableSlackApplication_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServicesServiceInterface_DisableSlackApplication_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ServicesServiceInterface_DisableSlackApplication_Call {
	_c.Call.Return(run)
	return _c
}

// GetCustomIssueTrackerService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) GetCustomIssueTrackerService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.CustomIssueTrackerService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCustomIssueTrackerService")
	}

	var r0 *gitlab.CustomIssueTrackerService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.CustomIssueTrackerService, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.CustomIssueTrackerService); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.CustomIssueTrackerService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_GetCustomIssueTrackerService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCustomIssueTrackerService'
type ServicesServiceInterface_GetCustomIssueTrackerService_Call struct {
	*mock.Call
}

// GetCustomIssueTrackerService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) GetCustomIssueTrackerService(pid interface{}, options ...interface{}) *ServicesServiceInterface_GetCustomIssueTrackerService_Call {
	return &ServicesServiceInterface_GetCustomIssueTrackerService_Call{Call: _e.mock.On("GetCustomIssueTrackerService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_GetCustomIssueTrackerService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_GetCustomIssueTrackerService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_GetCustomIssueTrackerService_Call) Return(_a0 *gitlab.CustomIssueTrackerService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_GetCustomIssueTrackerService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_GetCustomIssueTrackerService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.CustomIssueTrackerService, *gitlab.Response, error)) *ServicesServiceInterface_GetCustomIssueTrackerService_Call {
	_c.Call.Return(run)
	return _c
}

// GetDataDogService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) GetDataDogService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.DataDogService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDataDogService")
	}

	var r0 *gitlab.DataDogService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.DataDogService, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.DataDogService); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.DataDogService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_GetDataDogService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDataDogService'
type ServicesServiceInterface_GetDataDogService_Call struct {
	*mock.Call
}

// GetDataDogService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) GetDataDogService(pid interface{}, options ...interface{}) *ServicesServiceInterface_GetDataDogService_Call {
	return &ServicesServiceInterface_GetDataDogService_Call{Call: _e.mock.On("GetDataDogService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_GetDataDogService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_GetDataDogService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_GetDataDogService_Call) Return(_a0 *gitlab.DataDogService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_GetDataDogService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_GetDataDogService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.DataDogService, *gitlab.Response, error)) *ServicesServiceInterface_GetDataDogService_Call {
	_c.Call.Return(run)
	return _c
}

// GetDiscordService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) GetDiscordService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.DiscordService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDiscordService")
	}

	var r0 *gitlab.DiscordService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.DiscordService, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.DiscordService); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.DiscordService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_GetDiscordService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDiscordService'
type ServicesServiceInterface_GetDiscordService_Call struct {
	*mock.Call
}

// GetDiscordService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) GetDiscordService(pid interface{}, options ...interface{}) *ServicesServiceInterface_GetDiscordService_Call {
	return &ServicesServiceInterface_GetDiscordService_Call{Call: _e.mock.On("GetDiscordService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_GetDiscordService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_GetDiscordService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_GetDiscordService_Call) Return(_a0 *gitlab.DiscordService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_GetDiscordService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_GetDiscordService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.DiscordService, *gitlab.Response, error)) *ServicesServiceInterface_GetDiscordService_Call {
	_c.Call.Return(run)
	return _c
}

// GetDroneCIService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) GetDroneCIService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.DroneCIService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetDroneCIService")
	}

	var r0 *gitlab.DroneCIService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.DroneCIService, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.DroneCIService); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.DroneCIService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_GetDroneCIService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDroneCIService'
type ServicesServiceInterface_GetDroneCIService_Call struct {
	*mock.Call
}

// GetDroneCIService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) GetDroneCIService(pid interface{}, options ...interface{}) *ServicesServiceInterface_GetDroneCIService_Call {
	return &ServicesServiceInterface_GetDroneCIService_Call{Call: _e.mock.On("GetDroneCIService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_GetDroneCIService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_GetDroneCIService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_GetDroneCIService_Call) Return(_a0 *gitlab.DroneCIService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_GetDroneCIService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_GetDroneCIService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.DroneCIService, *gitlab.Response, error)) *ServicesServiceInterface_GetDroneCIService_Call {
	_c.Call.Return(run)
	return _c
}

// GetEmailsOnPushService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) GetEmailsOnPushService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.EmailsOnPushService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEmailsOnPushService")
	}

	var r0 *gitlab.EmailsOnPushService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.EmailsOnPushService, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.EmailsOnPushService); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.EmailsOnPushService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_GetEmailsOnPushService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEmailsOnPushService'
type ServicesServiceInterface_GetEmailsOnPushService_Call struct {
	*mock.Call
}

// GetEmailsOnPushService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) GetEmailsOnPushService(pid interface{}, options ...interface{}) *ServicesServiceInterface_GetEmailsOnPushService_Call {
	return &ServicesServiceInterface_GetEmailsOnPushService_Call{Call: _e.mock.On("GetEmailsOnPushService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_GetEmailsOnPushService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_GetEmailsOnPushService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_GetEmailsOnPushService_Call) Return(_a0 *gitlab.EmailsOnPushService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_GetEmailsOnPushService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_GetEmailsOnPushService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.EmailsOnPushService, *gitlab.Response, error)) *ServicesServiceInterface_GetEmailsOnPushService_Call {
	_c.Call.Return(run)
	return _c
}

// GetExternalWikiService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) GetExternalWikiService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.ExternalWikiService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetExternalWikiService")
	}

	var r0 *gitlab.ExternalWikiService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.ExternalWikiService, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.ExternalWikiService); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.ExternalWikiService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_GetExternalWikiService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetExternalWikiService'
type ServicesServiceInterface_GetExternalWikiService_Call struct {
	*mock.Call
}

// GetExternalWikiService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) GetExternalWikiService(pid interface{}, options ...interface{}) *ServicesServiceInterface_GetExternalWikiService_Call {
	return &ServicesServiceInterface_GetExternalWikiService_Call{Call: _e.mock.On("GetExternalWikiService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_GetExternalWikiService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_GetExternalWikiService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_GetExternalWikiService_Call) Return(_a0 *gitlab.ExternalWikiService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_GetExternalWikiService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_GetExternalWikiService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.ExternalWikiService, *gitlab.Response, error)) *ServicesServiceInterface_GetExternalWikiService_Call {
	_c.Call.Return(run)
	return _c
}

// GetGithubService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) GetGithubService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.GithubService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetGithubService")
	}

	var r0 *gitlab.GithubService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.GithubService, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.GithubService); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.GithubService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_GetGithubService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGithubService'
type ServicesServiceInterface_GetGithubService_Call struct {
	*mock.Call
}

// GetGithubService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) GetGithubService(pid interface{}, options ...interface{}) *ServicesServiceInterface_GetGithubService_Call {
	return &ServicesServiceInterface_GetGithubService_Call{Call: _e.mock.On("GetGithubService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_GetGithubService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_GetGithubService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_GetGithubService_Call) Return(_a0 *gitlab.GithubService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_GetGithubService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_GetGithubService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.GithubService, *gitlab.Response, error)) *ServicesServiceInterface_GetGithubService_Call {
	_c.Call.Return(run)
	return _c
}

// GetHarborService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) GetHarborService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.HarborService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetHarborService")
	}

	var r0 *gitlab.HarborService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.HarborService, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.HarborService); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.HarborService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_GetHarborService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetHarborService'
type ServicesServiceInterface_GetHarborService_Call struct {
	*mock.Call
}

// GetHarborService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) GetHarborService(pid interface{}, options ...interface{}) *ServicesServiceInterface_GetHarborService_Call {
	return &ServicesServiceInterface_GetHarborService_Call{Call: _e.mock.On("GetHarborService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_GetHarborService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_GetHarborService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_GetHarborService_Call) Return(_a0 *gitlab.HarborService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_GetHarborService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_GetHarborService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.HarborService, *gitlab.Response, error)) *ServicesServiceInterface_GetHarborService_Call {
	_c.Call.Return(run)
	return _c
}

// GetJenkinsCIService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) GetJenkinsCIService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.JenkinsCIService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetJenkinsCIService")
	}

	var r0 *gitlab.JenkinsCIService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.JenkinsCIService, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.JenkinsCIService); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.JenkinsCIService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_GetJenkinsCIService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJenkinsCIService'
type ServicesServiceInterface_GetJenkinsCIService_Call struct {
	*mock.Call
}

// GetJenkinsCIService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) GetJenkinsCIService(pid interface{}, options ...interface{}) *ServicesServiceInterface_GetJenkinsCIService_Call {
	return &ServicesServiceInterface_GetJenkinsCIService_Call{Call: _e.mock.On("GetJenkinsCIService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_GetJenkinsCIService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_GetJenkinsCIService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_GetJenkinsCIService_Call) Return(_a0 *gitlab.JenkinsCIService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_GetJenkinsCIService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_GetJenkinsCIService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.JenkinsCIService, *gitlab.Response, error)) *ServicesServiceInterface_GetJenkinsCIService_Call {
	_c.Call.Return(run)
	return _c
}

// GetJiraService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) GetJiraService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.JiraService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetJiraService")
	}

	var r0 *gitlab.JiraService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.JiraService, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.JiraService); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.JiraService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_GetJiraService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetJiraService'
type ServicesServiceInterface_GetJiraService_Call struct {
	*mock.Call
}

// GetJiraService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) GetJiraService(pid interface{}, options ...interface{}) *ServicesServiceInterface_GetJiraService_Call {
	return &ServicesServiceInterface_GetJiraService_Call{Call: _e.mock.On("GetJiraService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_GetJiraService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_GetJiraService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_GetJiraService_Call) Return(_a0 *gitlab.JiraService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_GetJiraService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_GetJiraService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.JiraService, *gitlab.Response, error)) *ServicesServiceInterface_GetJiraService_Call {
	_c.Call.Return(run)
	return _c
}

// GetMattermostService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) GetMattermostService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.MattermostService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMattermostService")
	}

	var r0 *gitlab.MattermostService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.MattermostService, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.MattermostService); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.MattermostService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_GetMattermostService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMattermostService'
type ServicesServiceInterface_GetMattermostService_Call struct {
	*mock.Call
}

// GetMattermostService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) GetMattermostService(pid interface{}, options ...interface{}) *ServicesServiceInterface_GetMattermostService_Call {
	return &ServicesServiceInterface_GetMattermostService_Call{Call: _e.mock.On("GetMattermostService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_GetMattermostService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_GetMattermostService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_GetMattermostService_Call) Return(_a0 *gitlab.MattermostService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_GetMattermostService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_GetMattermostService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.MattermostService, *gitlab.Response, error)) *ServicesServiceInterface_GetMattermostService_Call {
	_c.Call.Return(run)
	return _c
}

// GetMattermostSlashCommandsService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) GetMattermostSlashCommandsService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.MattermostSlashCommandsService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMattermostSlashCommandsService")
	}

	var r0 *gitlab.MattermostSlashCommandsService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.MattermostSlashCommandsService, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.MattermostSlashCommandsService); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.MattermostSlashCommandsService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_GetMattermostSlashCommandsService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMattermostSlashCommandsService'
type ServicesServiceInterface_GetMattermostSlashCommandsService_Call struct {
	*mock.Call
}

// GetMattermostSlashCommandsService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) GetMattermostSlashCommandsService(pid interface{}, options ...interface{}) *ServicesServiceInterface_GetMattermostSlashCommandsService_Call {
	return &ServicesServiceInterface_GetMattermostSlashCommandsService_Call{Call: _e.mock.On("GetMattermostSlashCommandsService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_GetMattermostSlashCommandsService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_GetMattermostSlashCommandsService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_GetMattermostSlashCommandsService_Call) Return(_a0 *gitlab.MattermostSlashCommandsService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_GetMattermostSlashCommandsService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_GetMattermostSlashCommandsService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.MattermostSlashCommandsService, *gitlab.Response, error)) *ServicesServiceInterface_GetMattermostSlashCommandsService_Call {
	_c.Call.Return(run)
	return _c
}

// GetMicrosoftTeamsService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) GetMicrosoftTeamsService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.MicrosoftTeamsService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMicrosoftTeamsService")
	}

	var r0 *gitlab.MicrosoftTeamsService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.MicrosoftTeamsService, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.MicrosoftTeamsService); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.MicrosoftTeamsService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_GetMicrosoftTeamsService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMicrosoftTeamsService'
type ServicesServiceInterface_GetMicrosoftTeamsService_Call struct {
	*mock.Call
}

// GetMicrosoftTeamsService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) GetMicrosoftTeamsService(pid interface{}, options ...interface{}) *ServicesServiceInterface_GetMicrosoftTeamsService_Call {
	return &ServicesServiceInterface_GetMicrosoftTeamsService_Call{Call: _e.mock.On("GetMicrosoftTeamsService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_GetMicrosoftTeamsService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_GetMicrosoftTeamsService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_GetMicrosoftTeamsService_Call) Return(_a0 *gitlab.MicrosoftTeamsService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_GetMicrosoftTeamsService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_GetMicrosoftTeamsService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.MicrosoftTeamsService, *gitlab.Response, error)) *ServicesServiceInterface_GetMicrosoftTeamsService_Call {
	_c.Call.Return(run)
	return _c
}

// GetPipelinesEmailService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) GetPipelinesEmailService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.PipelinesEmailService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPipelinesEmailService")
	}

	var r0 *gitlab.PipelinesEmailService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.PipelinesEmailService, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.PipelinesEmailService); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.PipelinesEmailService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_GetPipelinesEmailService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPipelinesEmailService'
type ServicesServiceInterface_GetPipelinesEmailService_Call struct {
	*mock.Call
}

// GetPipelinesEmailService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) GetPipelinesEmailService(pid interface{}, options ...interface{}) *ServicesServiceInterface_GetPipelinesEmailService_Call {
	return &ServicesServiceInterface_GetPipelinesEmailService_Call{Call: _e.mock.On("GetPipelinesEmailService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_GetPipelinesEmailService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_GetPipelinesEmailService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_GetPipelinesEmailService_Call) Return(_a0 *gitlab.PipelinesEmailService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_GetPipelinesEmailService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_GetPipelinesEmailService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.PipelinesEmailService, *gitlab.Response, error)) *ServicesServiceInterface_GetPipelinesEmailService_Call {
	_c.Call.Return(run)
	return _c
}

// GetPrometheusService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) GetPrometheusService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.PrometheusService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPrometheusService")
	}

	var r0 *gitlab.PrometheusService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.PrometheusService, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.PrometheusService); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.PrometheusService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_GetPrometheusService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPrometheusService'
type ServicesServiceInterface_GetPrometheusService_Call struct {
	*mock.Call
}

// GetPrometheusService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) GetPrometheusService(pid interface{}, options ...interface{}) *ServicesServiceInterface_GetPrometheusService_Call {
	return &ServicesServiceInterface_GetPrometheusService_Call{Call: _e.mock.On("GetPrometheusService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_GetPrometheusService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_GetPrometheusService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_GetPrometheusService_Call) Return(_a0 *gitlab.PrometheusService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_GetPrometheusService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_GetPrometheusService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.PrometheusService, *gitlab.Response, error)) *ServicesServiceInterface_GetPrometheusService_Call {
	_c.Call.Return(run)
	return _c
}

// GetRedmineService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) GetRedmineService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.RedmineService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRedmineService")
	}

	var r0 *gitlab.RedmineService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.RedmineService, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.RedmineService); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.RedmineService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_GetRedmineService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRedmineService'
type ServicesServiceInterface_GetRedmineService_Call struct {
	*mock.Call
}

// GetRedmineService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) GetRedmineService(pid interface{}, options ...interface{}) *ServicesServiceInterface_GetRedmineService_Call {
	return &ServicesServiceInterface_GetRedmineService_Call{Call: _e.mock.On("GetRedmineService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_GetRedmineService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_GetRedmineService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_GetRedmineService_Call) Return(_a0 *gitlab.RedmineService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_GetRedmineService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_GetRedmineService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.RedmineService, *gitlab.Response, error)) *ServicesServiceInterface_GetRedmineService_Call {
	_c.Call.Return(run)
	return _c
}

// GetSlackApplication provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) GetSlackApplication(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.SlackApplication, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSlackApplication")
	}

	var r0 *gitlab.SlackApplication
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.SlackApplication, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.SlackApplication); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.SlackApplication)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_GetSlackApplication_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSlackApplication'
type ServicesServiceInterface_GetSlackApplication_Call struct {
	*mock.Call
}

// GetSlackApplication is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) GetSlackApplication(pid interface{}, options ...interface{}) *ServicesServiceInterface_GetSlackApplication_Call {
	return &ServicesServiceInterface_GetSlackApplication_Call{Call: _e.mock.On("GetSlackApplication",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_GetSlackApplication_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_GetSlackApplication_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_GetSlackApplication_Call) Return(_a0 *gitlab.SlackApplication, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_GetSlackApplication_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_GetSlackApplication_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.SlackApplication, *gitlab.Response, error)) *ServicesServiceInterface_GetSlackApplication_Call {
	_c.Call.Return(run)
	return _c
}

// GetSlackService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) GetSlackService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.SlackService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSlackService")
	}

	var r0 *gitlab.SlackService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.SlackService, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.SlackService); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.SlackService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_GetSlackService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSlackService'
type ServicesServiceInterface_GetSlackService_Call struct {
	*mock.Call
}

// GetSlackService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) GetSlackService(pid interface{}, options ...interface{}) *ServicesServiceInterface_GetSlackService_Call {
	return &ServicesServiceInterface_GetSlackService_Call{Call: _e.mock.On("GetSlackService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_GetSlackService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_GetSlackService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_GetSlackService_Call) Return(_a0 *gitlab.SlackService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_GetSlackService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_GetSlackService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.SlackService, *gitlab.Response, error)) *ServicesServiceInterface_GetSlackService_Call {
	_c.Call.Return(run)
	return _c
}

// GetSlackSlashCommandsService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) GetSlackSlashCommandsService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.SlackSlashCommandsService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSlackSlashCommandsService")
	}

	var r0 *gitlab.SlackSlashCommandsService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.SlackSlashCommandsService, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.SlackSlashCommandsService); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.SlackSlashCommandsService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_GetSlackSlashCommandsService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSlackSlashCommandsService'
type ServicesServiceInterface_GetSlackSlashCommandsService_Call struct {
	*mock.Call
}

// GetSlackSlashCommandsService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) GetSlackSlashCommandsService(pid interface{}, options ...interface{}) *ServicesServiceInterface_GetSlackSlashCommandsService_Call {
	return &ServicesServiceInterface_GetSlackSlashCommandsService_Call{Call: _e.mock.On("GetSlackSlashCommandsService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_GetSlackSlashCommandsService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_GetSlackSlashCommandsService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_GetSlackSlashCommandsService_Call) Return(_a0 *gitlab.SlackSlashCommandsService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_GetSlackSlashCommandsService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_GetSlackSlashCommandsService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.SlackSlashCommandsService, *gitlab.Response, error)) *ServicesServiceInterface_GetSlackSlashCommandsService_Call {
	_c.Call.Return(run)
	return _c
}

// GetTelegramService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) GetTelegramService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.TelegramService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTelegramService")
	}

	var r0 *gitlab.TelegramService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.TelegramService, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.TelegramService); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.TelegramService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_GetTelegramService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTelegramService'
type ServicesServiceInterface_GetTelegramService_Call struct {
	*mock.Call
}

// GetTelegramService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) GetTelegramService(pid interface{}, options ...interface{}) *ServicesServiceInterface_GetTelegramService_Call {
	return &ServicesServiceInterface_GetTelegramService_Call{Call: _e.mock.On("GetTelegramService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_GetTelegramService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_GetTelegramService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_GetTelegramService_Call) Return(_a0 *gitlab.TelegramService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_GetTelegramService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_GetTelegramService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.TelegramService, *gitlab.Response, error)) *ServicesServiceInterface_GetTelegramService_Call {
	_c.Call.Return(run)
	return _c
}

// GetYouTrackService provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) GetYouTrackService(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.YouTrackService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetYouTrackService")
	}

	var r0 *gitlab.YouTrackService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.YouTrackService, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.YouTrackService); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.YouTrackService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_GetYouTrackService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetYouTrackService'
type ServicesServiceInterface_GetYouTrackService_Call struct {
	*mock.Call
}

// GetYouTrackService is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) GetYouTrackService(pid interface{}, options ...interface{}) *ServicesServiceInterface_GetYouTrackService_Call {
	return &ServicesServiceInterface_GetYouTrackService_Call{Call: _e.mock.On("GetYouTrackService",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_GetYouTrackService_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_GetYouTrackService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_GetYouTrackService_Call) Return(_a0 *gitlab.YouTrackService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_GetYouTrackService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_GetYouTrackService_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.YouTrackService, *gitlab.Response, error)) *ServicesServiceInterface_GetYouTrackService_Call {
	_c.Call.Return(run)
	return _c
}

// ListServices provides a mock function with given fields: pid, options
func (_m *ServicesServiceInterface) ListServices(pid interface{}, options ...gitlab.RequestOptionFunc) ([]*gitlab.Service, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListServices")
	}

	var r0 []*gitlab.Service
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) ([]*gitlab.Service, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) []*gitlab.Service); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Service)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_ListServices_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListServices'
type ServicesServiceInterface_ListServices_Call struct {
	*mock.Call
}

// ListServices is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) ListServices(pid interface{}, options ...interface{}) *ServicesServiceInterface_ListServices_Call {
	return &ServicesServiceInterface_ListServices_Call{Call: _e.mock.On("ListServices",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ServicesServiceInterface_ListServices_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_ListServices_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_ListServices_Call) Return(_a0 []*gitlab.Service, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_ListServices_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_ListServices_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) ([]*gitlab.Service, *gitlab.Response, error)) *ServicesServiceInterface_ListServices_Call {
	_c.Call.Return(run)
	return _c
}

// SetCustomIssueTrackerService provides a mock function with given fields: pid, opt, options
func (_m *ServicesServiceInterface) SetCustomIssueTrackerService(pid interface{}, opt *gitlab.SetCustomIssueTrackerServiceOptions, options ...gitlab.RequestOptionFunc) (*gitlab.CustomIssueTrackerService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetCustomIssueTrackerService")
	}

	var r0 *gitlab.CustomIssueTrackerService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetCustomIssueTrackerServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.CustomIssueTrackerService, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetCustomIssueTrackerServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.CustomIssueTrackerService); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.CustomIssueTrackerService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.SetCustomIssueTrackerServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.SetCustomIssueTrackerServiceOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_SetCustomIssueTrackerService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetCustomIssueTrackerService'
type ServicesServiceInterface_SetCustomIssueTrackerService_Call struct {
	*mock.Call
}

// SetCustomIssueTrackerService is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.SetCustomIssueTrackerServiceOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) SetCustomIssueTrackerService(pid interface{}, opt interface{}, options ...interface{}) *ServicesServiceInterface_SetCustomIssueTrackerService_Call {
	return &ServicesServiceInterface_SetCustomIssueTrackerService_Call{Call: _e.mock.On("SetCustomIssueTrackerService",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ServicesServiceInterface_SetCustomIssueTrackerService_Call) Run(run func(pid interface{}, opt *gitlab.SetCustomIssueTrackerServiceOptions, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_SetCustomIssueTrackerService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.SetCustomIssueTrackerServiceOptions), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_SetCustomIssueTrackerService_Call) Return(_a0 *gitlab.CustomIssueTrackerService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_SetCustomIssueTrackerService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_SetCustomIssueTrackerService_Call) RunAndReturn(run func(interface{}, *gitlab.SetCustomIssueTrackerServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.CustomIssueTrackerService, *gitlab.Response, error)) *ServicesServiceInterface_SetCustomIssueTrackerService_Call {
	_c.Call.Return(run)
	return _c
}

// SetDataDogService provides a mock function with given fields: pid, opt, options
func (_m *ServicesServiceInterface) SetDataDogService(pid interface{}, opt *gitlab.SetDataDogServiceOptions, options ...gitlab.RequestOptionFunc) (*gitlab.DataDogService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetDataDogService")
	}

	var r0 *gitlab.DataDogService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetDataDogServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.DataDogService, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetDataDogServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.DataDogService); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.DataDogService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.SetDataDogServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.SetDataDogServiceOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_SetDataDogService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetDataDogService'
type ServicesServiceInterface_SetDataDogService_Call struct {
	*mock.Call
}

// SetDataDogService is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.SetDataDogServiceOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) SetDataDogService(pid interface{}, opt interface{}, options ...interface{}) *ServicesServiceInterface_SetDataDogService_Call {
	return &ServicesServiceInterface_SetDataDogService_Call{Call: _e.mock.On("SetDataDogService",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ServicesServiceInterface_SetDataDogService_Call) Run(run func(pid interface{}, opt *gitlab.SetDataDogServiceOptions, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_SetDataDogService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.SetDataDogServiceOptions), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_SetDataDogService_Call) Return(_a0 *gitlab.DataDogService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_SetDataDogService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_SetDataDogService_Call) RunAndReturn(run func(interface{}, *gitlab.SetDataDogServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.DataDogService, *gitlab.Response, error)) *ServicesServiceInterface_SetDataDogService_Call {
	_c.Call.Return(run)
	return _c
}

// SetDiscordService provides a mock function with given fields: pid, opt, options
func (_m *ServicesServiceInterface) SetDiscordService(pid interface{}, opt *gitlab.SetDiscordServiceOptions, options ...gitlab.RequestOptionFunc) (*gitlab.DiscordService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetDiscordService")
	}

	var r0 *gitlab.DiscordService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetDiscordServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.DiscordService, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetDiscordServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.DiscordService); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.DiscordService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.SetDiscordServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.SetDiscordServiceOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_SetDiscordService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetDiscordService'
type ServicesServiceInterface_SetDiscordService_Call struct {
	*mock.Call
}

// SetDiscordService is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.SetDiscordServiceOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) SetDiscordService(pid interface{}, opt interface{}, options ...interface{}) *ServicesServiceInterface_SetDiscordService_Call {
	return &ServicesServiceInterface_SetDiscordService_Call{Call: _e.mock.On("SetDiscordService",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ServicesServiceInterface_SetDiscordService_Call) Run(run func(pid interface{}, opt *gitlab.SetDiscordServiceOptions, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_SetDiscordService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.SetDiscordServiceOptions), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_SetDiscordService_Call) Return(_a0 *gitlab.DiscordService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_SetDiscordService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_SetDiscordService_Call) RunAndReturn(run func(interface{}, *gitlab.SetDiscordServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.DiscordService, *gitlab.Response, error)) *ServicesServiceInterface_SetDiscordService_Call {
	_c.Call.Return(run)
	return _c
}

// SetDroneCIService provides a mock function with given fields: pid, opt, options
func (_m *ServicesServiceInterface) SetDroneCIService(pid interface{}, opt *gitlab.SetDroneCIServiceOptions, options ...gitlab.RequestOptionFunc) (*gitlab.DroneCIService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetDroneCIService")
	}

	var r0 *gitlab.DroneCIService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetDroneCIServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.DroneCIService, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetDroneCIServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.DroneCIService); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.DroneCIService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.SetDroneCIServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.SetDroneCIServiceOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_SetDroneCIService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetDroneCIService'
type ServicesServiceInterface_SetDroneCIService_Call struct {
	*mock.Call
}

// SetDroneCIService is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.SetDroneCIServiceOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) SetDroneCIService(pid interface{}, opt interface{}, options ...interface{}) *ServicesServiceInterface_SetDroneCIService_Call {
	return &ServicesServiceInterface_SetDroneCIService_Call{Call: _e.mock.On("SetDroneCIService",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ServicesServiceInterface_SetDroneCIService_Call) Run(run func(pid interface{}, opt *gitlab.SetDroneCIServiceOptions, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_SetDroneCIService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.SetDroneCIServiceOptions), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_SetDroneCIService_Call) Return(_a0 *gitlab.DroneCIService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_SetDroneCIService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_SetDroneCIService_Call) RunAndReturn(run func(interface{}, *gitlab.SetDroneCIServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.DroneCIService, *gitlab.Response, error)) *ServicesServiceInterface_SetDroneCIService_Call {
	_c.Call.Return(run)
	return _c
}

// SetEmailsOnPushService provides a mock function with given fields: pid, opt, options
func (_m *ServicesServiceInterface) SetEmailsOnPushService(pid interface{}, opt *gitlab.SetEmailsOnPushServiceOptions, options ...gitlab.RequestOptionFunc) (*gitlab.EmailsOnPushService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetEmailsOnPushService")
	}

	var r0 *gitlab.EmailsOnPushService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetEmailsOnPushServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.EmailsOnPushService, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetEmailsOnPushServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.EmailsOnPushService); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.EmailsOnPushService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.SetEmailsOnPushServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.SetEmailsOnPushServiceOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_SetEmailsOnPushService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetEmailsOnPushService'
type ServicesServiceInterface_SetEmailsOnPushService_Call struct {
	*mock.Call
}

// SetEmailsOnPushService is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.SetEmailsOnPushServiceOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) SetEmailsOnPushService(pid interface{}, opt interface{}, options ...interface{}) *ServicesServiceInterface_SetEmailsOnPushService_Call {
	return &ServicesServiceInterface_SetEmailsOnPushService_Call{Call: _e.mock.On("SetEmailsOnPushService",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ServicesServiceInterface_SetEmailsOnPushService_Call) Run(run func(pid interface{}, opt *gitlab.SetEmailsOnPushServiceOptions, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_SetEmailsOnPushService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.SetEmailsOnPushServiceOptions), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_SetEmailsOnPushService_Call) Return(_a0 *gitlab.EmailsOnPushService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_SetEmailsOnPushService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_SetEmailsOnPushService_Call) RunAndReturn(run func(interface{}, *gitlab.SetEmailsOnPushServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.EmailsOnPushService, *gitlab.Response, error)) *ServicesServiceInterface_SetEmailsOnPushService_Call {
	_c.Call.Return(run)
	return _c
}

// SetExternalWikiService provides a mock function with given fields: pid, opt, options
func (_m *ServicesServiceInterface) SetExternalWikiService(pid interface{}, opt *gitlab.SetExternalWikiServiceOptions, options ...gitlab.RequestOptionFunc) (*gitlab.ExternalWikiService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetExternalWikiService")
	}

	var r0 *gitlab.ExternalWikiService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetExternalWikiServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.ExternalWikiService, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetExternalWikiServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.ExternalWikiService); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.ExternalWikiService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.SetExternalWikiServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.SetExternalWikiServiceOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_SetExternalWikiService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetExternalWikiService'
type ServicesServiceInterface_SetExternalWikiService_Call struct {
	*mock.Call
}

// SetExternalWikiService is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.SetExternalWikiServiceOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) SetExternalWikiService(pid interface{}, opt interface{}, options ...interface{}) *ServicesServiceInterface_SetExternalWikiService_Call {
	return &ServicesServiceInterface_SetExternalWikiService_Call{Call: _e.mock.On("SetExternalWikiService",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ServicesServiceInterface_SetExternalWikiService_Call) Run(run func(pid interface{}, opt *gitlab.SetExternalWikiServiceOptions, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_SetExternalWikiService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.SetExternalWikiServiceOptions), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_SetExternalWikiService_Call) Return(_a0 *gitlab.ExternalWikiService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_SetExternalWikiService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_SetExternalWikiService_Call) RunAndReturn(run func(interface{}, *gitlab.SetExternalWikiServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.ExternalWikiService, *gitlab.Response, error)) *ServicesServiceInterface_SetExternalWikiService_Call {
	_c.Call.Return(run)
	return _c
}

// SetGitLabCIService provides a mock function with given fields: pid, opt, options
func (_m *ServicesServiceInterface) SetGitLabCIService(pid interface{}, opt *gitlab.SetGitLabCIServiceOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetGitLabCIService")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetGitLabCIServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetGitLabCIServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.SetGitLabCIServiceOptions, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, opt, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServicesServiceInterface_SetGitLabCIService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetGitLabCIService'
type ServicesServiceInterface_SetGitLabCIService_Call struct {
	*mock.Call
}

// SetGitLabCIService is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.SetGitLabCIServiceOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) SetGitLabCIService(pid interface{}, opt interface{}, options ...interface{}) *ServicesServiceInterface_SetGitLabCIService_Call {
	return &ServicesServiceInterface_SetGitLabCIService_Call{Call: _e.mock.On("SetGitLabCIService",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ServicesServiceInterface_SetGitLabCIService_Call) Run(run func(pid interface{}, opt *gitlab.SetGitLabCIServiceOptions, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_SetGitLabCIService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.SetGitLabCIServiceOptions), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_SetGitLabCIService_Call) Return(_a0 *gitlab.Response, _a1 error) *ServicesServiceInterface_SetGitLabCIService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServicesServiceInterface_SetGitLabCIService_Call) RunAndReturn(run func(interface{}, *gitlab.SetGitLabCIServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ServicesServiceInterface_SetGitLabCIService_Call {
	_c.Call.Return(run)
	return _c
}

// SetGithubService provides a mock function with given fields: pid, opt, options
func (_m *ServicesServiceInterface) SetGithubService(pid interface{}, opt *gitlab.SetGithubServiceOptions, options ...gitlab.RequestOptionFunc) (*gitlab.GithubService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetGithubService")
	}

	var r0 *gitlab.GithubService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetGithubServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.GithubService, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetGithubServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.GithubService); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.GithubService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.SetGithubServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.SetGithubServiceOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_SetGithubService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetGithubService'
type ServicesServiceInterface_SetGithubService_Call struct {
	*mock.Call
}

// SetGithubService is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.SetGithubServiceOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) SetGithubService(pid interface{}, opt interface{}, options ...interface{}) *ServicesServiceInterface_SetGithubService_Call {
	return &ServicesServiceInterface_SetGithubService_Call{Call: _e.mock.On("SetGithubService",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ServicesServiceInterface_SetGithubService_Call) Run(run func(pid interface{}, opt *gitlab.SetGithubServiceOptions, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_SetGithubService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.SetGithubServiceOptions), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_SetGithubService_Call) Return(_a0 *gitlab.GithubService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_SetGithubService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_SetGithubService_Call) RunAndReturn(run func(interface{}, *gitlab.SetGithubServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.GithubService, *gitlab.Response, error)) *ServicesServiceInterface_SetGithubService_Call {
	_c.Call.Return(run)
	return _c
}

// SetHarborService provides a mock function with given fields: pid, opt, options
func (_m *ServicesServiceInterface) SetHarborService(pid interface{}, opt *gitlab.SetHarborServiceOptions, options ...gitlab.RequestOptionFunc) (*gitlab.HarborService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetHarborService")
	}

	var r0 *gitlab.HarborService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetHarborServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.HarborService, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetHarborServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.HarborService); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.HarborService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.SetHarborServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.SetHarborServiceOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_SetHarborService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetHarborService'
type ServicesServiceInterface_SetHarborService_Call struct {
	*mock.Call
}

// SetHarborService is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.SetHarborServiceOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) SetHarborService(pid interface{}, opt interface{}, options ...interface{}) *ServicesServiceInterface_SetHarborService_Call {
	return &ServicesServiceInterface_SetHarborService_Call{Call: _e.mock.On("SetHarborService",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ServicesServiceInterface_SetHarborService_Call) Run(run func(pid interface{}, opt *gitlab.SetHarborServiceOptions, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_SetHarborService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.SetHarborServiceOptions), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_SetHarborService_Call) Return(_a0 *gitlab.HarborService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_SetHarborService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_SetHarborService_Call) RunAndReturn(run func(interface{}, *gitlab.SetHarborServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.HarborService, *gitlab.Response, error)) *ServicesServiceInterface_SetHarborService_Call {
	_c.Call.Return(run)
	return _c
}

// SetHipChatService provides a mock function with given fields: pid, opt, options
func (_m *ServicesServiceInterface) SetHipChatService(pid interface{}, opt *gitlab.SetHipChatServiceOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetHipChatService")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetHipChatServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetHipChatServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.SetHipChatServiceOptions, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, opt, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ServicesServiceInterface_SetHipChatService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetHipChatService'
type ServicesServiceInterface_SetHipChatService_Call struct {
	*mock.Call
}

// SetHipChatService is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.SetHipChatServiceOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) SetHipChatService(pid interface{}, opt interface{}, options ...interface{}) *ServicesServiceInterface_SetHipChatService_Call {
	return &ServicesServiceInterface_SetHipChatService_Call{Call: _e.mock.On("SetHipChatService",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ServicesServiceInterface_SetHipChatService_Call) Run(run func(pid interface{}, opt *gitlab.SetHipChatServiceOptions, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_SetHipChatService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.SetHipChatServiceOptions), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_SetHipChatService_Call) Return(_a0 *gitlab.Response, _a1 error) *ServicesServiceInterface_SetHipChatService_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ServicesServiceInterface_SetHipChatService_Call) RunAndReturn(run func(interface{}, *gitlab.SetHipChatServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ServicesServiceInterface_SetHipChatService_Call {
	_c.Call.Return(run)
	return _c
}

// SetJenkinsCIService provides a mock function with given fields: pid, opt, options
func (_m *ServicesServiceInterface) SetJenkinsCIService(pid interface{}, opt *gitlab.SetJenkinsCIServiceOptions, options ...gitlab.RequestOptionFunc) (*gitlab.JenkinsCIService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetJenkinsCIService")
	}

	var r0 *gitlab.JenkinsCIService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetJenkinsCIServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.JenkinsCIService, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetJenkinsCIServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.JenkinsCIService); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.JenkinsCIService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.SetJenkinsCIServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.SetJenkinsCIServiceOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_SetJenkinsCIService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetJenkinsCIService'
type ServicesServiceInterface_SetJenkinsCIService_Call struct {
	*mock.Call
}

// SetJenkinsCIService is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.SetJenkinsCIServiceOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) SetJenkinsCIService(pid interface{}, opt interface{}, options ...interface{}) *ServicesServiceInterface_SetJenkinsCIService_Call {
	return &ServicesServiceInterface_SetJenkinsCIService_Call{Call: _e.mock.On("SetJenkinsCIService",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ServicesServiceInterface_SetJenkinsCIService_Call) Run(run func(pid interface{}, opt *gitlab.SetJenkinsCIServiceOptions, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_SetJenkinsCIService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.SetJenkinsCIServiceOptions), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_SetJenkinsCIService_Call) Return(_a0 *gitlab.JenkinsCIService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_SetJenkinsCIService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_SetJenkinsCIService_Call) RunAndReturn(run func(interface{}, *gitlab.SetJenkinsCIServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.JenkinsCIService, *gitlab.Response, error)) *ServicesServiceInterface_SetJenkinsCIService_Call {
	_c.Call.Return(run)
	return _c
}

// SetJiraService provides a mock function with given fields: pid, opt, options
func (_m *ServicesServiceInterface) SetJiraService(pid interface{}, opt *gitlab.SetJiraServiceOptions, options ...gitlab.RequestOptionFunc) (*gitlab.JiraService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetJiraService")
	}

	var r0 *gitlab.JiraService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetJiraServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.JiraService, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetJiraServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.JiraService); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.JiraService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.SetJiraServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.SetJiraServiceOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_SetJiraService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetJiraService'
type ServicesServiceInterface_SetJiraService_Call struct {
	*mock.Call
}

// SetJiraService is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.SetJiraServiceOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) SetJiraService(pid interface{}, opt interface{}, options ...interface{}) *ServicesServiceInterface_SetJiraService_Call {
	return &ServicesServiceInterface_SetJiraService_Call{Call: _e.mock.On("SetJiraService",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ServicesServiceInterface_SetJiraService_Call) Run(run func(pid interface{}, opt *gitlab.SetJiraServiceOptions, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_SetJiraService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.SetJiraServiceOptions), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_SetJiraService_Call) Return(_a0 *gitlab.JiraService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_SetJiraService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_SetJiraService_Call) RunAndReturn(run func(interface{}, *gitlab.SetJiraServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.JiraService, *gitlab.Response, error)) *ServicesServiceInterface_SetJiraService_Call {
	_c.Call.Return(run)
	return _c
}

// SetMattermostService provides a mock function with given fields: pid, opt, options
func (_m *ServicesServiceInterface) SetMattermostService(pid interface{}, opt *gitlab.SetMattermostServiceOptions, options ...gitlab.RequestOptionFunc) (*gitlab.MattermostService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetMattermostService")
	}

	var r0 *gitlab.MattermostService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetMattermostServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.MattermostService, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetMattermostServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.MattermostService); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.MattermostService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.SetMattermostServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.SetMattermostServiceOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_SetMattermostService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetMattermostService'
type ServicesServiceInterface_SetMattermostService_Call struct {
	*mock.Call
}

// SetMattermostService is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.SetMattermostServiceOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) SetMattermostService(pid interface{}, opt interface{}, options ...interface{}) *ServicesServiceInterface_SetMattermostService_Call {
	return &ServicesServiceInterface_SetMattermostService_Call{Call: _e.mock.On("SetMattermostService",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ServicesServiceInterface_SetMattermostService_Call) Run(run func(pid interface{}, opt *gitlab.SetMattermostServiceOptions, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_SetMattermostService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.SetMattermostServiceOptions), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_SetMattermostService_Call) Return(_a0 *gitlab.MattermostService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_SetMattermostService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_SetMattermostService_Call) RunAndReturn(run func(interface{}, *gitlab.SetMattermostServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.MattermostService, *gitlab.Response, error)) *ServicesServiceInterface_SetMattermostService_Call {
	_c.Call.Return(run)
	return _c
}

// SetMattermostSlashCommandsService provides a mock function with given fields: pid, opt, options
func (_m *ServicesServiceInterface) SetMattermostSlashCommandsService(pid interface{}, opt *gitlab.SetMattermostSlashCommandsServiceOptions, options ...gitlab.RequestOptionFunc) (*gitlab.MattermostSlashCommandsService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetMattermostSlashCommandsService")
	}

	var r0 *gitlab.MattermostSlashCommandsService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetMattermostSlashCommandsServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.MattermostSlashCommandsService, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetMattermostSlashCommandsServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.MattermostSlashCommandsService); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.MattermostSlashCommandsService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.SetMattermostSlashCommandsServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.SetMattermostSlashCommandsServiceOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_SetMattermostSlashCommandsService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetMattermostSlashCommandsService'
type ServicesServiceInterface_SetMattermostSlashCommandsService_Call struct {
	*mock.Call
}

// SetMattermostSlashCommandsService is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.SetMattermostSlashCommandsServiceOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) SetMattermostSlashCommandsService(pid interface{}, opt interface{}, options ...interface{}) *ServicesServiceInterface_SetMattermostSlashCommandsService_Call {
	return &ServicesServiceInterface_SetMattermostSlashCommandsService_Call{Call: _e.mock.On("SetMattermostSlashCommandsService",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ServicesServiceInterface_SetMattermostSlashCommandsService_Call) Run(run func(pid interface{}, opt *gitlab.SetMattermostSlashCommandsServiceOptions, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_SetMattermostSlashCommandsService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.SetMattermostSlashCommandsServiceOptions), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_SetMattermostSlashCommandsService_Call) Return(_a0 *gitlab.MattermostSlashCommandsService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_SetMattermostSlashCommandsService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_SetMattermostSlashCommandsService_Call) RunAndReturn(run func(interface{}, *gitlab.SetMattermostSlashCommandsServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.MattermostSlashCommandsService, *gitlab.Response, error)) *ServicesServiceInterface_SetMattermostSlashCommandsService_Call {
	_c.Call.Return(run)
	return _c
}

// SetMicrosoftTeamsService provides a mock function with given fields: pid, opt, options
func (_m *ServicesServiceInterface) SetMicrosoftTeamsService(pid interface{}, opt *gitlab.SetMicrosoftTeamsServiceOptions, options ...gitlab.RequestOptionFunc) (*gitlab.MicrosoftTeamsService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetMicrosoftTeamsService")
	}

	var r0 *gitlab.MicrosoftTeamsService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetMicrosoftTeamsServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.MicrosoftTeamsService, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetMicrosoftTeamsServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.MicrosoftTeamsService); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.MicrosoftTeamsService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.SetMicrosoftTeamsServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.SetMicrosoftTeamsServiceOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_SetMicrosoftTeamsService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetMicrosoftTeamsService'
type ServicesServiceInterface_SetMicrosoftTeamsService_Call struct {
	*mock.Call
}

// SetMicrosoftTeamsService is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.SetMicrosoftTeamsServiceOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) SetMicrosoftTeamsService(pid interface{}, opt interface{}, options ...interface{}) *ServicesServiceInterface_SetMicrosoftTeamsService_Call {
	return &ServicesServiceInterface_SetMicrosoftTeamsService_Call{Call: _e.mock.On("SetMicrosoftTeamsService",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ServicesServiceInterface_SetMicrosoftTeamsService_Call) Run(run func(pid interface{}, opt *gitlab.SetMicrosoftTeamsServiceOptions, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_SetMicrosoftTeamsService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.SetMicrosoftTeamsServiceOptions), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_SetMicrosoftTeamsService_Call) Return(_a0 *gitlab.MicrosoftTeamsService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_SetMicrosoftTeamsService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_SetMicrosoftTeamsService_Call) RunAndReturn(run func(interface{}, *gitlab.SetMicrosoftTeamsServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.MicrosoftTeamsService, *gitlab.Response, error)) *ServicesServiceInterface_SetMicrosoftTeamsService_Call {
	_c.Call.Return(run)
	return _c
}

// SetPipelinesEmailService provides a mock function with given fields: pid, opt, options
func (_m *ServicesServiceInterface) SetPipelinesEmailService(pid interface{}, opt *gitlab.SetPipelinesEmailServiceOptions, options ...gitlab.RequestOptionFunc) (*gitlab.PipelinesEmailService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetPipelinesEmailService")
	}

	var r0 *gitlab.PipelinesEmailService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetPipelinesEmailServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.PipelinesEmailService, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetPipelinesEmailServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.PipelinesEmailService); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.PipelinesEmailService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.SetPipelinesEmailServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.SetPipelinesEmailServiceOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_SetPipelinesEmailService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetPipelinesEmailService'
type ServicesServiceInterface_SetPipelinesEmailService_Call struct {
	*mock.Call
}

// SetPipelinesEmailService is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.SetPipelinesEmailServiceOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) SetPipelinesEmailService(pid interface{}, opt interface{}, options ...interface{}) *ServicesServiceInterface_SetPipelinesEmailService_Call {
	return &ServicesServiceInterface_SetPipelinesEmailService_Call{Call: _e.mock.On("SetPipelinesEmailService",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ServicesServiceInterface_SetPipelinesEmailService_Call) Run(run func(pid interface{}, opt *gitlab.SetPipelinesEmailServiceOptions, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_SetPipelinesEmailService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.SetPipelinesEmailServiceOptions), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_SetPipelinesEmailService_Call) Return(_a0 *gitlab.PipelinesEmailService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_SetPipelinesEmailService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_SetPipelinesEmailService_Call) RunAndReturn(run func(interface{}, *gitlab.SetPipelinesEmailServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.PipelinesEmailService, *gitlab.Response, error)) *ServicesServiceInterface_SetPipelinesEmailService_Call {
	_c.Call.Return(run)
	return _c
}

// SetPrometheusService provides a mock function with given fields: pid, opt, options
func (_m *ServicesServiceInterface) SetPrometheusService(pid interface{}, opt *gitlab.SetPrometheusServiceOptions, options ...gitlab.RequestOptionFunc) (*gitlab.PrometheusService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetPrometheusService")
	}

	var r0 *gitlab.PrometheusService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetPrometheusServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.PrometheusService, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetPrometheusServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.PrometheusService); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.PrometheusService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.SetPrometheusServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.SetPrometheusServiceOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_SetPrometheusService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetPrometheusService'
type ServicesServiceInterface_SetPrometheusService_Call struct {
	*mock.Call
}

// SetPrometheusService is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.SetPrometheusServiceOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) SetPrometheusService(pid interface{}, opt interface{}, options ...interface{}) *ServicesServiceInterface_SetPrometheusService_Call {
	return &ServicesServiceInterface_SetPrometheusService_Call{Call: _e.mock.On("SetPrometheusService",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ServicesServiceInterface_SetPrometheusService_Call) Run(run func(pid interface{}, opt *gitlab.SetPrometheusServiceOptions, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_SetPrometheusService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.SetPrometheusServiceOptions), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_SetPrometheusService_Call) Return(_a0 *gitlab.PrometheusService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_SetPrometheusService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_SetPrometheusService_Call) RunAndReturn(run func(interface{}, *gitlab.SetPrometheusServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.PrometheusService, *gitlab.Response, error)) *ServicesServiceInterface_SetPrometheusService_Call {
	_c.Call.Return(run)
	return _c
}

// SetRedmineService provides a mock function with given fields: pid, opt, options
func (_m *ServicesServiceInterface) SetRedmineService(pid interface{}, opt *gitlab.SetRedmineServiceOptions, options ...gitlab.RequestOptionFunc) (*gitlab.RedmineService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetRedmineService")
	}

	var r0 *gitlab.RedmineService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetRedmineServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.RedmineService, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetRedmineServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.RedmineService); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.RedmineService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.SetRedmineServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.SetRedmineServiceOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_SetRedmineService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetRedmineService'
type ServicesServiceInterface_SetRedmineService_Call struct {
	*mock.Call
}

// SetRedmineService is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.SetRedmineServiceOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) SetRedmineService(pid interface{}, opt interface{}, options ...interface{}) *ServicesServiceInterface_SetRedmineService_Call {
	return &ServicesServiceInterface_SetRedmineService_Call{Call: _e.mock.On("SetRedmineService",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ServicesServiceInterface_SetRedmineService_Call) Run(run func(pid interface{}, opt *gitlab.SetRedmineServiceOptions, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_SetRedmineService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.SetRedmineServiceOptions), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_SetRedmineService_Call) Return(_a0 *gitlab.RedmineService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_SetRedmineService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_SetRedmineService_Call) RunAndReturn(run func(interface{}, *gitlab.SetRedmineServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.RedmineService, *gitlab.Response, error)) *ServicesServiceInterface_SetRedmineService_Call {
	_c.Call.Return(run)
	return _c
}

// SetSlackApplication provides a mock function with given fields: pid, opt, options
func (_m *ServicesServiceInterface) SetSlackApplication(pid interface{}, opt *gitlab.SetSlackApplicationOptions, options ...gitlab.RequestOptionFunc) (*gitlab.SlackApplication, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetSlackApplication")
	}

	var r0 *gitlab.SlackApplication
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetSlackApplicationOptions, ...gitlab.RequestOptionFunc) (*gitlab.SlackApplication, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetSlackApplicationOptions, ...gitlab.RequestOptionFunc) *gitlab.SlackApplication); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.SlackApplication)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.SetSlackApplicationOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.SetSlackApplicationOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_SetSlackApplication_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetSlackApplication'
type ServicesServiceInterface_SetSlackApplication_Call struct {
	*mock.Call
}

// SetSlackApplication is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.SetSlackApplicationOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) SetSlackApplication(pid interface{}, opt interface{}, options ...interface{}) *ServicesServiceInterface_SetSlackApplication_Call {
	return &ServicesServiceInterface_SetSlackApplication_Call{Call: _e.mock.On("SetSlackApplication",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ServicesServiceInterface_SetSlackApplication_Call) Run(run func(pid interface{}, opt *gitlab.SetSlackApplicationOptions, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_SetSlackApplication_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.SetSlackApplicationOptions), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_SetSlackApplication_Call) Return(_a0 *gitlab.SlackApplication, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_SetSlackApplication_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_SetSlackApplication_Call) RunAndReturn(run func(interface{}, *gitlab.SetSlackApplicationOptions, ...gitlab.RequestOptionFunc) (*gitlab.SlackApplication, *gitlab.Response, error)) *ServicesServiceInterface_SetSlackApplication_Call {
	_c.Call.Return(run)
	return _c
}

// SetSlackService provides a mock function with given fields: pid, opt, options
func (_m *ServicesServiceInterface) SetSlackService(pid interface{}, opt *gitlab.SetSlackServiceOptions, options ...gitlab.RequestOptionFunc) (*gitlab.SlackService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetSlackService")
	}

	var r0 *gitlab.SlackService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetSlackServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.SlackService, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetSlackServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.SlackService); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.SlackService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.SetSlackServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.SetSlackServiceOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_SetSlackService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetSlackService'
type ServicesServiceInterface_SetSlackService_Call struct {
	*mock.Call
}

// SetSlackService is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.SetSlackServiceOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) SetSlackService(pid interface{}, opt interface{}, options ...interface{}) *ServicesServiceInterface_SetSlackService_Call {
	return &ServicesServiceInterface_SetSlackService_Call{Call: _e.mock.On("SetSlackService",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ServicesServiceInterface_SetSlackService_Call) Run(run func(pid interface{}, opt *gitlab.SetSlackServiceOptions, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_SetSlackService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.SetSlackServiceOptions), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_SetSlackService_Call) Return(_a0 *gitlab.SlackService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_SetSlackService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_SetSlackService_Call) RunAndReturn(run func(interface{}, *gitlab.SetSlackServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.SlackService, *gitlab.Response, error)) *ServicesServiceInterface_SetSlackService_Call {
	_c.Call.Return(run)
	return _c
}

// SetSlackSlashCommandsService provides a mock function with given fields: pid, opt, options
func (_m *ServicesServiceInterface) SetSlackSlashCommandsService(pid interface{}, opt *gitlab.SetSlackSlashCommandsServiceOptions, options ...gitlab.RequestOptionFunc) (*gitlab.SlackSlashCommandsService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetSlackSlashCommandsService")
	}

	var r0 *gitlab.SlackSlashCommandsService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetSlackSlashCommandsServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.SlackSlashCommandsService, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetSlackSlashCommandsServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.SlackSlashCommandsService); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.SlackSlashCommandsService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.SetSlackSlashCommandsServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.SetSlackSlashCommandsServiceOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_SetSlackSlashCommandsService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetSlackSlashCommandsService'
type ServicesServiceInterface_SetSlackSlashCommandsService_Call struct {
	*mock.Call
}

// SetSlackSlashCommandsService is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.SetSlackSlashCommandsServiceOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) SetSlackSlashCommandsService(pid interface{}, opt interface{}, options ...interface{}) *ServicesServiceInterface_SetSlackSlashCommandsService_Call {
	return &ServicesServiceInterface_SetSlackSlashCommandsService_Call{Call: _e.mock.On("SetSlackSlashCommandsService",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ServicesServiceInterface_SetSlackSlashCommandsService_Call) Run(run func(pid interface{}, opt *gitlab.SetSlackSlashCommandsServiceOptions, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_SetSlackSlashCommandsService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.SetSlackSlashCommandsServiceOptions), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_SetSlackSlashCommandsService_Call) Return(_a0 *gitlab.SlackSlashCommandsService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_SetSlackSlashCommandsService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_SetSlackSlashCommandsService_Call) RunAndReturn(run func(interface{}, *gitlab.SetSlackSlashCommandsServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.SlackSlashCommandsService, *gitlab.Response, error)) *ServicesServiceInterface_SetSlackSlashCommandsService_Call {
	_c.Call.Return(run)
	return _c
}

// SetTelegramService provides a mock function with given fields: pid, opt, options
func (_m *ServicesServiceInterface) SetTelegramService(pid interface{}, opt *gitlab.SetTelegramServiceOptions, options ...gitlab.RequestOptionFunc) (*gitlab.TelegramService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetTelegramService")
	}

	var r0 *gitlab.TelegramService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetTelegramServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.TelegramService, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetTelegramServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.TelegramService); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.TelegramService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.SetTelegramServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.SetTelegramServiceOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_SetTelegramService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetTelegramService'
type ServicesServiceInterface_SetTelegramService_Call struct {
	*mock.Call
}

// SetTelegramService is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.SetTelegramServiceOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) SetTelegramService(pid interface{}, opt interface{}, options ...interface{}) *ServicesServiceInterface_SetTelegramService_Call {
	return &ServicesServiceInterface_SetTelegramService_Call{Call: _e.mock.On("SetTelegramService",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ServicesServiceInterface_SetTelegramService_Call) Run(run func(pid interface{}, opt *gitlab.SetTelegramServiceOptions, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_SetTelegramService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.SetTelegramServiceOptions), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_SetTelegramService_Call) Return(_a0 *gitlab.TelegramService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_SetTelegramService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_SetTelegramService_Call) RunAndReturn(run func(interface{}, *gitlab.SetTelegramServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.TelegramService, *gitlab.Response, error)) *ServicesServiceInterface_SetTelegramService_Call {
	_c.Call.Return(run)
	return _c
}

// SetYouTrackService provides a mock function with given fields: pid, opt, options
func (_m *ServicesServiceInterface) SetYouTrackService(pid interface{}, opt *gitlab.SetYouTrackServiceOptions, options ...gitlab.RequestOptionFunc) (*gitlab.YouTrackService, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetYouTrackService")
	}

	var r0 *gitlab.YouTrackService
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetYouTrackServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.YouTrackService, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.SetYouTrackServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.YouTrackService); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.YouTrackService)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.SetYouTrackServiceOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.SetYouTrackServiceOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ServicesServiceInterface_SetYouTrackService_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetYouTrackService'
type ServicesServiceInterface_SetYouTrackService_Call struct {
	*mock.Call
}

// SetYouTrackService is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.SetYouTrackServiceOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ServicesServiceInterface_Expecter) SetYouTrackService(pid interface{}, opt interface{}, options ...interface{}) *ServicesServiceInterface_SetYouTrackService_Call {
	return &ServicesServiceInterface_SetYouTrackService_Call{Call: _e.mock.On("SetYouTrackService",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ServicesServiceInterface_SetYouTrackService_Call) Run(run func(pid interface{}, opt *gitlab.SetYouTrackServiceOptions, options ...gitlab.RequestOptionFunc)) *ServicesServiceInterface_SetYouTrackService_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.SetYouTrackServiceOptions), variadicArgs...)
	})
	return _c
}

func (_c *ServicesServiceInterface_SetYouTrackService_Call) Return(_a0 *gitlab.YouTrackService, _a1 *gitlab.Response, _a2 error) *ServicesServiceInterface_SetYouTrackService_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ServicesServiceInterface_SetYouTrackService_Call) RunAndReturn(run func(interface{}, *gitlab.SetYouTrackServiceOptions, ...gitlab.RequestOptionFunc) (*gitlab.YouTrackService, *gitlab.Response, error)) *ServicesServiceInterface_SetYouTrackService_Call {
	_c.Call.Return(run)
	return _c
}

// NewServicesServiceInterface creates a new instance of ServicesServiceInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewServicesServiceInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *ServicesServiceInterface {
	mock := &ServicesServiceInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

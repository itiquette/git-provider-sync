// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"
	gitlab "gitlab.com/gitlab-org/api/client-go"
)

// DiscussionsServiceInterface is an autogenerated mock type for the DiscussionsServiceInterface type
type DiscussionsServiceInterface struct {
	mock.Mock
}

type DiscussionsServiceInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *DiscussionsServiceInterface) EXPECT() *DiscussionsServiceInterface_Expecter {
	return &DiscussionsServiceInterface_Expecter{mock: &_m.Mock}
}

// AddCommitDiscussionNote provides a mock function with given fields: pid, commit, discussion, opt, options
func (_m *DiscussionsServiceInterface) AddCommitDiscussionNote(pid interface{}, commit string, discussion string, opt *gitlab.AddCommitDiscussionNoteOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, commit, discussion, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddCommitDiscussionNote")
	}

	var r0 *gitlab.Note
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, string, *gitlab.AddCommitDiscussionNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)); ok {
		return rf(pid, commit, discussion, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, string, *gitlab.AddCommitDiscussionNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Note); ok {
		r0 = rf(pid, commit, discussion, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Note)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, string, *gitlab.AddCommitDiscussionNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, commit, discussion, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, string, *gitlab.AddCommitDiscussionNoteOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, commit, discussion, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DiscussionsServiceInterface_AddCommitDiscussionNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddCommitDiscussionNote'
type DiscussionsServiceInterface_AddCommitDiscussionNote_Call struct {
	*mock.Call
}

// AddCommitDiscussionNote is a helper method to define mock.On call
//   - pid interface{}
//   - commit string
//   - discussion string
//   - opt *gitlab.AddCommitDiscussionNoteOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) AddCommitDiscussionNote(pid interface{}, commit interface{}, discussion interface{}, opt interface{}, options ...interface{}) *DiscussionsServiceInterface_AddCommitDiscussionNote_Call {
	return &DiscussionsServiceInterface_AddCommitDiscussionNote_Call{Call: _e.mock.On("AddCommitDiscussionNote",
		append([]interface{}{pid, commit, discussion, opt}, options...)...)}
}

func (_c *DiscussionsServiceInterface_AddCommitDiscussionNote_Call) Run(run func(pid interface{}, commit string, discussion string, opt *gitlab.AddCommitDiscussionNoteOptions, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_AddCommitDiscussionNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(string), args[3].(*gitlab.AddCommitDiscussionNoteOptions), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_AddCommitDiscussionNote_Call) Return(_a0 *gitlab.Note, _a1 *gitlab.Response, _a2 error) *DiscussionsServiceInterface_AddCommitDiscussionNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *DiscussionsServiceInterface_AddCommitDiscussionNote_Call) RunAndReturn(run func(interface{}, string, string, *gitlab.AddCommitDiscussionNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *DiscussionsServiceInterface_AddCommitDiscussionNote_Call {
	_c.Call.Return(run)
	return _c
}

// AddEpicDiscussionNote provides a mock function with given fields: gid, epic, discussion, opt, options
func (_m *DiscussionsServiceInterface) AddEpicDiscussionNote(gid interface{}, epic int, discussion string, opt *gitlab.AddEpicDiscussionNoteOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, epic, discussion, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddEpicDiscussionNote")
	}

	var r0 *gitlab.Note
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, string, *gitlab.AddEpicDiscussionNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)); ok {
		return rf(gid, epic, discussion, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, string, *gitlab.AddEpicDiscussionNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Note); ok {
		r0 = rf(gid, epic, discussion, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Note)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, string, *gitlab.AddEpicDiscussionNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, epic, discussion, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, string, *gitlab.AddEpicDiscussionNoteOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, epic, discussion, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DiscussionsServiceInterface_AddEpicDiscussionNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddEpicDiscussionNote'
type DiscussionsServiceInterface_AddEpicDiscussionNote_Call struct {
	*mock.Call
}

// AddEpicDiscussionNote is a helper method to define mock.On call
//   - gid interface{}
//   - epic int
//   - discussion string
//   - opt *gitlab.AddEpicDiscussionNoteOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) AddEpicDiscussionNote(gid interface{}, epic interface{}, discussion interface{}, opt interface{}, options ...interface{}) *DiscussionsServiceInterface_AddEpicDiscussionNote_Call {
	return &DiscussionsServiceInterface_AddEpicDiscussionNote_Call{Call: _e.mock.On("AddEpicDiscussionNote",
		append([]interface{}{gid, epic, discussion, opt}, options...)...)}
}

func (_c *DiscussionsServiceInterface_AddEpicDiscussionNote_Call) Run(run func(gid interface{}, epic int, discussion string, opt *gitlab.AddEpicDiscussionNoteOptions, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_AddEpicDiscussionNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(string), args[3].(*gitlab.AddEpicDiscussionNoteOptions), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_AddEpicDiscussionNote_Call) Return(_a0 *gitlab.Note, _a1 *gitlab.Response, _a2 error) *DiscussionsServiceInterface_AddEpicDiscussionNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *DiscussionsServiceInterface_AddEpicDiscussionNote_Call) RunAndReturn(run func(interface{}, int, string, *gitlab.AddEpicDiscussionNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *DiscussionsServiceInterface_AddEpicDiscussionNote_Call {
	_c.Call.Return(run)
	return _c
}

// AddIssueDiscussionNote provides a mock function with given fields: pid, issue, discussion, opt, options
func (_m *DiscussionsServiceInterface) AddIssueDiscussionNote(pid interface{}, issue int, discussion string, opt *gitlab.AddIssueDiscussionNoteOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issue, discussion, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddIssueDiscussionNote")
	}

	var r0 *gitlab.Note
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, string, *gitlab.AddIssueDiscussionNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)); ok {
		return rf(pid, issue, discussion, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, string, *gitlab.AddIssueDiscussionNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Note); ok {
		r0 = rf(pid, issue, discussion, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Note)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, string, *gitlab.AddIssueDiscussionNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issue, discussion, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, string, *gitlab.AddIssueDiscussionNoteOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issue, discussion, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DiscussionsServiceInterface_AddIssueDiscussionNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddIssueDiscussionNote'
type DiscussionsServiceInterface_AddIssueDiscussionNote_Call struct {
	*mock.Call
}

// AddIssueDiscussionNote is a helper method to define mock.On call
//   - pid interface{}
//   - issue int
//   - discussion string
//   - opt *gitlab.AddIssueDiscussionNoteOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) AddIssueDiscussionNote(pid interface{}, issue interface{}, discussion interface{}, opt interface{}, options ...interface{}) *DiscussionsServiceInterface_AddIssueDiscussionNote_Call {
	return &DiscussionsServiceInterface_AddIssueDiscussionNote_Call{Call: _e.mock.On("AddIssueDiscussionNote",
		append([]interface{}{pid, issue, discussion, opt}, options...)...)}
}

func (_c *DiscussionsServiceInterface_AddIssueDiscussionNote_Call) Run(run func(pid interface{}, issue int, discussion string, opt *gitlab.AddIssueDiscussionNoteOptions, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_AddIssueDiscussionNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(string), args[3].(*gitlab.AddIssueDiscussionNoteOptions), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_AddIssueDiscussionNote_Call) Return(_a0 *gitlab.Note, _a1 *gitlab.Response, _a2 error) *DiscussionsServiceInterface_AddIssueDiscussionNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *DiscussionsServiceInterface_AddIssueDiscussionNote_Call) RunAndReturn(run func(interface{}, int, string, *gitlab.AddIssueDiscussionNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *DiscussionsServiceInterface_AddIssueDiscussionNote_Call {
	_c.Call.Return(run)
	return _c
}

// AddMergeRequestDiscussionNote provides a mock function with given fields: pid, mergeRequest, discussion, opt, options
func (_m *DiscussionsServiceInterface) AddMergeRequestDiscussionNote(pid interface{}, mergeRequest int, discussion string, opt *gitlab.AddMergeRequestDiscussionNoteOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, discussion, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddMergeRequestDiscussionNote")
	}

	var r0 *gitlab.Note
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, string, *gitlab.AddMergeRequestDiscussionNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, discussion, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, string, *gitlab.AddMergeRequestDiscussionNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Note); ok {
		r0 = rf(pid, mergeRequest, discussion, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Note)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, string, *gitlab.AddMergeRequestDiscussionNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, discussion, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, string, *gitlab.AddMergeRequestDiscussionNoteOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, discussion, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DiscussionsServiceInterface_AddMergeRequestDiscussionNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddMergeRequestDiscussionNote'
type DiscussionsServiceInterface_AddMergeRequestDiscussionNote_Call struct {
	*mock.Call
}

// AddMergeRequestDiscussionNote is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - discussion string
//   - opt *gitlab.AddMergeRequestDiscussionNoteOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) AddMergeRequestDiscussionNote(pid interface{}, mergeRequest interface{}, discussion interface{}, opt interface{}, options ...interface{}) *DiscussionsServiceInterface_AddMergeRequestDiscussionNote_Call {
	return &DiscussionsServiceInterface_AddMergeRequestDiscussionNote_Call{Call: _e.mock.On("AddMergeRequestDiscussionNote",
		append([]interface{}{pid, mergeRequest, discussion, opt}, options...)...)}
}

func (_c *DiscussionsServiceInterface_AddMergeRequestDiscussionNote_Call) Run(run func(pid interface{}, mergeRequest int, discussion string, opt *gitlab.AddMergeRequestDiscussionNoteOptions, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_AddMergeRequestDiscussionNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(string), args[3].(*gitlab.AddMergeRequestDiscussionNoteOptions), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_AddMergeRequestDiscussionNote_Call) Return(_a0 *gitlab.Note, _a1 *gitlab.Response, _a2 error) *DiscussionsServiceInterface_AddMergeRequestDiscussionNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *DiscussionsServiceInterface_AddMergeRequestDiscussionNote_Call) RunAndReturn(run func(interface{}, int, string, *gitlab.AddMergeRequestDiscussionNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *DiscussionsServiceInterface_AddMergeRequestDiscussionNote_Call {
	_c.Call.Return(run)
	return _c
}

// AddSnippetDiscussionNote provides a mock function with given fields: pid, snippet, discussion, opt, options
func (_m *DiscussionsServiceInterface) AddSnippetDiscussionNote(pid interface{}, snippet int, discussion string, opt *gitlab.AddSnippetDiscussionNoteOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, snippet, discussion, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddSnippetDiscussionNote")
	}

	var r0 *gitlab.Note
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, string, *gitlab.AddSnippetDiscussionNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)); ok {
		return rf(pid, snippet, discussion, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, string, *gitlab.AddSnippetDiscussionNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Note); ok {
		r0 = rf(pid, snippet, discussion, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Note)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, string, *gitlab.AddSnippetDiscussionNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, snippet, discussion, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, string, *gitlab.AddSnippetDiscussionNoteOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, snippet, discussion, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DiscussionsServiceInterface_AddSnippetDiscussionNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddSnippetDiscussionNote'
type DiscussionsServiceInterface_AddSnippetDiscussionNote_Call struct {
	*mock.Call
}

// AddSnippetDiscussionNote is a helper method to define mock.On call
//   - pid interface{}
//   - snippet int
//   - discussion string
//   - opt *gitlab.AddSnippetDiscussionNoteOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) AddSnippetDiscussionNote(pid interface{}, snippet interface{}, discussion interface{}, opt interface{}, options ...interface{}) *DiscussionsServiceInterface_AddSnippetDiscussionNote_Call {
	return &DiscussionsServiceInterface_AddSnippetDiscussionNote_Call{Call: _e.mock.On("AddSnippetDiscussionNote",
		append([]interface{}{pid, snippet, discussion, opt}, options...)...)}
}

func (_c *DiscussionsServiceInterface_AddSnippetDiscussionNote_Call) Run(run func(pid interface{}, snippet int, discussion string, opt *gitlab.AddSnippetDiscussionNoteOptions, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_AddSnippetDiscussionNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(string), args[3].(*gitlab.AddSnippetDiscussionNoteOptions), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_AddSnippetDiscussionNote_Call) Return(_a0 *gitlab.Note, _a1 *gitlab.Response, _a2 error) *DiscussionsServiceInterface_AddSnippetDiscussionNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *DiscussionsServiceInterface_AddSnippetDiscussionNote_Call) RunAndReturn(run func(interface{}, int, string, *gitlab.AddSnippetDiscussionNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *DiscussionsServiceInterface_AddSnippetDiscussionNote_Call {
	_c.Call.Return(run)
	return _c
}

// CreateCommitDiscussion provides a mock function with given fields: pid, commit, opt, options
func (_m *DiscussionsServiceInterface) CreateCommitDiscussion(pid interface{}, commit string, opt *gitlab.CreateCommitDiscussionOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, commit, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCommitDiscussion")
	}

	var r0 *gitlab.Discussion
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.CreateCommitDiscussionOptions, ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error)); ok {
		return rf(pid, commit, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.CreateCommitDiscussionOptions, ...gitlab.RequestOptionFunc) *gitlab.Discussion); ok {
		r0 = rf(pid, commit, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Discussion)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, *gitlab.CreateCommitDiscussionOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, commit, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, *gitlab.CreateCommitDiscussionOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, commit, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DiscussionsServiceInterface_CreateCommitDiscussion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCommitDiscussion'
type DiscussionsServiceInterface_CreateCommitDiscussion_Call struct {
	*mock.Call
}

// CreateCommitDiscussion is a helper method to define mock.On call
//   - pid interface{}
//   - commit string
//   - opt *gitlab.CreateCommitDiscussionOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) CreateCommitDiscussion(pid interface{}, commit interface{}, opt interface{}, options ...interface{}) *DiscussionsServiceInterface_CreateCommitDiscussion_Call {
	return &DiscussionsServiceInterface_CreateCommitDiscussion_Call{Call: _e.mock.On("CreateCommitDiscussion",
		append([]interface{}{pid, commit, opt}, options...)...)}
}

func (_c *DiscussionsServiceInterface_CreateCommitDiscussion_Call) Run(run func(pid interface{}, commit string, opt *gitlab.CreateCommitDiscussionOptions, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_CreateCommitDiscussion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(*gitlab.CreateCommitDiscussionOptions), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_CreateCommitDiscussion_Call) Return(_a0 *gitlab.Discussion, _a1 *gitlab.Response, _a2 error) *DiscussionsServiceInterface_CreateCommitDiscussion_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *DiscussionsServiceInterface_CreateCommitDiscussion_Call) RunAndReturn(run func(interface{}, string, *gitlab.CreateCommitDiscussionOptions, ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error)) *DiscussionsServiceInterface_CreateCommitDiscussion_Call {
	_c.Call.Return(run)
	return _c
}

// CreateEpicDiscussion provides a mock function with given fields: gid, epic, opt, options
func (_m *DiscussionsServiceInterface) CreateEpicDiscussion(gid interface{}, epic int, opt *gitlab.CreateEpicDiscussionOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, epic, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateEpicDiscussion")
	}

	var r0 *gitlab.Discussion
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.CreateEpicDiscussionOptions, ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error)); ok {
		return rf(gid, epic, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.CreateEpicDiscussionOptions, ...gitlab.RequestOptionFunc) *gitlab.Discussion); ok {
		r0 = rf(gid, epic, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Discussion)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.CreateEpicDiscussionOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, epic, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.CreateEpicDiscussionOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, epic, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DiscussionsServiceInterface_CreateEpicDiscussion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateEpicDiscussion'
type DiscussionsServiceInterface_CreateEpicDiscussion_Call struct {
	*mock.Call
}

// CreateEpicDiscussion is a helper method to define mock.On call
//   - gid interface{}
//   - epic int
//   - opt *gitlab.CreateEpicDiscussionOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) CreateEpicDiscussion(gid interface{}, epic interface{}, opt interface{}, options ...interface{}) *DiscussionsServiceInterface_CreateEpicDiscussion_Call {
	return &DiscussionsServiceInterface_CreateEpicDiscussion_Call{Call: _e.mock.On("CreateEpicDiscussion",
		append([]interface{}{gid, epic, opt}, options...)...)}
}

func (_c *DiscussionsServiceInterface_CreateEpicDiscussion_Call) Run(run func(gid interface{}, epic int, opt *gitlab.CreateEpicDiscussionOptions, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_CreateEpicDiscussion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.CreateEpicDiscussionOptions), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_CreateEpicDiscussion_Call) Return(_a0 *gitlab.Discussion, _a1 *gitlab.Response, _a2 error) *DiscussionsServiceInterface_CreateEpicDiscussion_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *DiscussionsServiceInterface_CreateEpicDiscussion_Call) RunAndReturn(run func(interface{}, int, *gitlab.CreateEpicDiscussionOptions, ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error)) *DiscussionsServiceInterface_CreateEpicDiscussion_Call {
	_c.Call.Return(run)
	return _c
}

// CreateIssueDiscussion provides a mock function with given fields: pid, issue, opt, options
func (_m *DiscussionsServiceInterface) CreateIssueDiscussion(pid interface{}, issue int, opt *gitlab.CreateIssueDiscussionOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issue, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIssueDiscussion")
	}

	var r0 *gitlab.Discussion
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.CreateIssueDiscussionOptions, ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error)); ok {
		return rf(pid, issue, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.CreateIssueDiscussionOptions, ...gitlab.RequestOptionFunc) *gitlab.Discussion); ok {
		r0 = rf(pid, issue, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Discussion)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.CreateIssueDiscussionOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issue, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.CreateIssueDiscussionOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issue, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DiscussionsServiceInterface_CreateIssueDiscussion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateIssueDiscussion'
type DiscussionsServiceInterface_CreateIssueDiscussion_Call struct {
	*mock.Call
}

// CreateIssueDiscussion is a helper method to define mock.On call
//   - pid interface{}
//   - issue int
//   - opt *gitlab.CreateIssueDiscussionOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) CreateIssueDiscussion(pid interface{}, issue interface{}, opt interface{}, options ...interface{}) *DiscussionsServiceInterface_CreateIssueDiscussion_Call {
	return &DiscussionsServiceInterface_CreateIssueDiscussion_Call{Call: _e.mock.On("CreateIssueDiscussion",
		append([]interface{}{pid, issue, opt}, options...)...)}
}

func (_c *DiscussionsServiceInterface_CreateIssueDiscussion_Call) Run(run func(pid interface{}, issue int, opt *gitlab.CreateIssueDiscussionOptions, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_CreateIssueDiscussion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.CreateIssueDiscussionOptions), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_CreateIssueDiscussion_Call) Return(_a0 *gitlab.Discussion, _a1 *gitlab.Response, _a2 error) *DiscussionsServiceInterface_CreateIssueDiscussion_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *DiscussionsServiceInterface_CreateIssueDiscussion_Call) RunAndReturn(run func(interface{}, int, *gitlab.CreateIssueDiscussionOptions, ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error)) *DiscussionsServiceInterface_CreateIssueDiscussion_Call {
	_c.Call.Return(run)
	return _c
}

// CreateMergeRequestDiscussion provides a mock function with given fields: pid, mergeRequest, opt, options
func (_m *DiscussionsServiceInterface) CreateMergeRequestDiscussion(pid interface{}, mergeRequest int, opt *gitlab.CreateMergeRequestDiscussionOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateMergeRequestDiscussion")
	}

	var r0 *gitlab.Discussion
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.CreateMergeRequestDiscussionOptions, ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.CreateMergeRequestDiscussionOptions, ...gitlab.RequestOptionFunc) *gitlab.Discussion); ok {
		r0 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Discussion)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.CreateMergeRequestDiscussionOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.CreateMergeRequestDiscussionOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DiscussionsServiceInterface_CreateMergeRequestDiscussion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMergeRequestDiscussion'
type DiscussionsServiceInterface_CreateMergeRequestDiscussion_Call struct {
	*mock.Call
}

// CreateMergeRequestDiscussion is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - opt *gitlab.CreateMergeRequestDiscussionOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) CreateMergeRequestDiscussion(pid interface{}, mergeRequest interface{}, opt interface{}, options ...interface{}) *DiscussionsServiceInterface_CreateMergeRequestDiscussion_Call {
	return &DiscussionsServiceInterface_CreateMergeRequestDiscussion_Call{Call: _e.mock.On("CreateMergeRequestDiscussion",
		append([]interface{}{pid, mergeRequest, opt}, options...)...)}
}

func (_c *DiscussionsServiceInterface_CreateMergeRequestDiscussion_Call) Run(run func(pid interface{}, mergeRequest int, opt *gitlab.CreateMergeRequestDiscussionOptions, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_CreateMergeRequestDiscussion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.CreateMergeRequestDiscussionOptions), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_CreateMergeRequestDiscussion_Call) Return(_a0 *gitlab.Discussion, _a1 *gitlab.Response, _a2 error) *DiscussionsServiceInterface_CreateMergeRequestDiscussion_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *DiscussionsServiceInterface_CreateMergeRequestDiscussion_Call) RunAndReturn(run func(interface{}, int, *gitlab.CreateMergeRequestDiscussionOptions, ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error)) *DiscussionsServiceInterface_CreateMergeRequestDiscussion_Call {
	_c.Call.Return(run)
	return _c
}

// CreateSnippetDiscussion provides a mock function with given fields: pid, snippet, opt, options
func (_m *DiscussionsServiceInterface) CreateSnippetDiscussion(pid interface{}, snippet int, opt *gitlab.CreateSnippetDiscussionOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, snippet, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSnippetDiscussion")
	}

	var r0 *gitlab.Discussion
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.CreateSnippetDiscussionOptions, ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error)); ok {
		return rf(pid, snippet, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.CreateSnippetDiscussionOptions, ...gitlab.RequestOptionFunc) *gitlab.Discussion); ok {
		r0 = rf(pid, snippet, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Discussion)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.CreateSnippetDiscussionOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, snippet, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.CreateSnippetDiscussionOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, snippet, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DiscussionsServiceInterface_CreateSnippetDiscussion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSnippetDiscussion'
type DiscussionsServiceInterface_CreateSnippetDiscussion_Call struct {
	*mock.Call
}

// CreateSnippetDiscussion is a helper method to define mock.On call
//   - pid interface{}
//   - snippet int
//   - opt *gitlab.CreateSnippetDiscussionOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) CreateSnippetDiscussion(pid interface{}, snippet interface{}, opt interface{}, options ...interface{}) *DiscussionsServiceInterface_CreateSnippetDiscussion_Call {
	return &DiscussionsServiceInterface_CreateSnippetDiscussion_Call{Call: _e.mock.On("CreateSnippetDiscussion",
		append([]interface{}{pid, snippet, opt}, options...)...)}
}

func (_c *DiscussionsServiceInterface_CreateSnippetDiscussion_Call) Run(run func(pid interface{}, snippet int, opt *gitlab.CreateSnippetDiscussionOptions, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_CreateSnippetDiscussion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.CreateSnippetDiscussionOptions), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_CreateSnippetDiscussion_Call) Return(_a0 *gitlab.Discussion, _a1 *gitlab.Response, _a2 error) *DiscussionsServiceInterface_CreateSnippetDiscussion_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *DiscussionsServiceInterface_CreateSnippetDiscussion_Call) RunAndReturn(run func(interface{}, int, *gitlab.CreateSnippetDiscussionOptions, ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error)) *DiscussionsServiceInterface_CreateSnippetDiscussion_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteCommitDiscussionNote provides a mock function with given fields: pid, commit, discussion, note, options
func (_m *DiscussionsServiceInterface) DeleteCommitDiscussionNote(pid interface{}, commit string, discussion string, note int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, commit, discussion, note)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCommitDiscussionNote")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, string, string, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, commit, discussion, note, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, string, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, commit, discussion, note, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, string, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, commit, discussion, note, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DiscussionsServiceInterface_DeleteCommitDiscussionNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteCommitDiscussionNote'
type DiscussionsServiceInterface_DeleteCommitDiscussionNote_Call struct {
	*mock.Call
}

// DeleteCommitDiscussionNote is a helper method to define mock.On call
//   - pid interface{}
//   - commit string
//   - discussion string
//   - note int
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) DeleteCommitDiscussionNote(pid interface{}, commit interface{}, discussion interface{}, note interface{}, options ...interface{}) *DiscussionsServiceInterface_DeleteCommitDiscussionNote_Call {
	return &DiscussionsServiceInterface_DeleteCommitDiscussionNote_Call{Call: _e.mock.On("DeleteCommitDiscussionNote",
		append([]interface{}{pid, commit, discussion, note}, options...)...)}
}

func (_c *DiscussionsServiceInterface_DeleteCommitDiscussionNote_Call) Run(run func(pid interface{}, commit string, discussion string, note int, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_DeleteCommitDiscussionNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(string), args[3].(int), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_DeleteCommitDiscussionNote_Call) Return(_a0 *gitlab.Response, _a1 error) *DiscussionsServiceInterface_DeleteCommitDiscussionNote_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DiscussionsServiceInterface_DeleteCommitDiscussionNote_Call) RunAndReturn(run func(interface{}, string, string, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *DiscussionsServiceInterface_DeleteCommitDiscussionNote_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteEpicDiscussionNote provides a mock function with given fields: gid, epic, discussion, note, options
func (_m *DiscussionsServiceInterface) DeleteEpicDiscussionNote(gid interface{}, epic int, discussion string, note int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, epic, discussion, note)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEpicDiscussionNote")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, string, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(gid, epic, discussion, note, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, string, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(gid, epic, discussion, note, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, string, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(gid, epic, discussion, note, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DiscussionsServiceInterface_DeleteEpicDiscussionNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteEpicDiscussionNote'
type DiscussionsServiceInterface_DeleteEpicDiscussionNote_Call struct {
	*mock.Call
}

// DeleteEpicDiscussionNote is a helper method to define mock.On call
//   - gid interface{}
//   - epic int
//   - discussion string
//   - note int
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) DeleteEpicDiscussionNote(gid interface{}, epic interface{}, discussion interface{}, note interface{}, options ...interface{}) *DiscussionsServiceInterface_DeleteEpicDiscussionNote_Call {
	return &DiscussionsServiceInterface_DeleteEpicDiscussionNote_Call{Call: _e.mock.On("DeleteEpicDiscussionNote",
		append([]interface{}{gid, epic, discussion, note}, options...)...)}
}

func (_c *DiscussionsServiceInterface_DeleteEpicDiscussionNote_Call) Run(run func(gid interface{}, epic int, discussion string, note int, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_DeleteEpicDiscussionNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(string), args[3].(int), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_DeleteEpicDiscussionNote_Call) Return(_a0 *gitlab.Response, _a1 error) *DiscussionsServiceInterface_DeleteEpicDiscussionNote_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DiscussionsServiceInterface_DeleteEpicDiscussionNote_Call) RunAndReturn(run func(interface{}, int, string, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *DiscussionsServiceInterface_DeleteEpicDiscussionNote_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteIssueDiscussionNote provides a mock function with given fields: pid, issue, discussion, note, options
func (_m *DiscussionsServiceInterface) DeleteIssueDiscussionNote(pid interface{}, issue int, discussion string, note int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issue, discussion, note)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIssueDiscussionNote")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, string, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, issue, discussion, note, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, string, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, issue, discussion, note, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, string, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, issue, discussion, note, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DiscussionsServiceInterface_DeleteIssueDiscussionNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteIssueDiscussionNote'
type DiscussionsServiceInterface_DeleteIssueDiscussionNote_Call struct {
	*mock.Call
}

// DeleteIssueDiscussionNote is a helper method to define mock.On call
//   - pid interface{}
//   - issue int
//   - discussion string
//   - note int
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) DeleteIssueDiscussionNote(pid interface{}, issue interface{}, discussion interface{}, note interface{}, options ...interface{}) *DiscussionsServiceInterface_DeleteIssueDiscussionNote_Call {
	return &DiscussionsServiceInterface_DeleteIssueDiscussionNote_Call{Call: _e.mock.On("DeleteIssueDiscussionNote",
		append([]interface{}{pid, issue, discussion, note}, options...)...)}
}

func (_c *DiscussionsServiceInterface_DeleteIssueDiscussionNote_Call) Run(run func(pid interface{}, issue int, discussion string, note int, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_DeleteIssueDiscussionNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(string), args[3].(int), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_DeleteIssueDiscussionNote_Call) Return(_a0 *gitlab.Response, _a1 error) *DiscussionsServiceInterface_DeleteIssueDiscussionNote_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DiscussionsServiceInterface_DeleteIssueDiscussionNote_Call) RunAndReturn(run func(interface{}, int, string, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *DiscussionsServiceInterface_DeleteIssueDiscussionNote_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteMergeRequestDiscussionNote provides a mock function with given fields: pid, mergeRequest, discussion, note, options
func (_m *DiscussionsServiceInterface) DeleteMergeRequestDiscussionNote(pid interface{}, mergeRequest int, discussion string, note int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, discussion, note)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMergeRequestDiscussionNote")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, string, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, discussion, note, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, string, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, mergeRequest, discussion, note, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, string, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, mergeRequest, discussion, note, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DiscussionsServiceInterface_DeleteMergeRequestDiscussionNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteMergeRequestDiscussionNote'
type DiscussionsServiceInterface_DeleteMergeRequestDiscussionNote_Call struct {
	*mock.Call
}

// DeleteMergeRequestDiscussionNote is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - discussion string
//   - note int
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) DeleteMergeRequestDiscussionNote(pid interface{}, mergeRequest interface{}, discussion interface{}, note interface{}, options ...interface{}) *DiscussionsServiceInterface_DeleteMergeRequestDiscussionNote_Call {
	return &DiscussionsServiceInterface_DeleteMergeRequestDiscussionNote_Call{Call: _e.mock.On("DeleteMergeRequestDiscussionNote",
		append([]interface{}{pid, mergeRequest, discussion, note}, options...)...)}
}

func (_c *DiscussionsServiceInterface_DeleteMergeRequestDiscussionNote_Call) Run(run func(pid interface{}, mergeRequest int, discussion string, note int, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_DeleteMergeRequestDiscussionNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(string), args[3].(int), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_DeleteMergeRequestDiscussionNote_Call) Return(_a0 *gitlab.Response, _a1 error) *DiscussionsServiceInterface_DeleteMergeRequestDiscussionNote_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DiscussionsServiceInterface_DeleteMergeRequestDiscussionNote_Call) RunAndReturn(run func(interface{}, int, string, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *DiscussionsServiceInterface_DeleteMergeRequestDiscussionNote_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSnippetDiscussionNote provides a mock function with given fields: pid, snippet, discussion, note, options
func (_m *DiscussionsServiceInterface) DeleteSnippetDiscussionNote(pid interface{}, snippet int, discussion string, note int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, snippet, discussion, note)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSnippetDiscussionNote")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, string, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, snippet, discussion, note, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, string, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, snippet, discussion, note, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, string, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, snippet, discussion, note, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DiscussionsServiceInterface_DeleteSnippetDiscussionNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSnippetDiscussionNote'
type DiscussionsServiceInterface_DeleteSnippetDiscussionNote_Call struct {
	*mock.Call
}

// DeleteSnippetDiscussionNote is a helper method to define mock.On call
//   - pid interface{}
//   - snippet int
//   - discussion string
//   - note int
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) DeleteSnippetDiscussionNote(pid interface{}, snippet interface{}, discussion interface{}, note interface{}, options ...interface{}) *DiscussionsServiceInterface_DeleteSnippetDiscussionNote_Call {
	return &DiscussionsServiceInterface_DeleteSnippetDiscussionNote_Call{Call: _e.mock.On("DeleteSnippetDiscussionNote",
		append([]interface{}{pid, snippet, discussion, note}, options...)...)}
}

func (_c *DiscussionsServiceInterface_DeleteSnippetDiscussionNote_Call) Run(run func(pid interface{}, snippet int, discussion string, note int, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_DeleteSnippetDiscussionNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(string), args[3].(int), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_DeleteSnippetDiscussionNote_Call) Return(_a0 *gitlab.Response, _a1 error) *DiscussionsServiceInterface_DeleteSnippetDiscussionNote_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *DiscussionsServiceInterface_DeleteSnippetDiscussionNote_Call) RunAndReturn(run func(interface{}, int, string, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *DiscussionsServiceInterface_DeleteSnippetDiscussionNote_Call {
	_c.Call.Return(run)
	return _c
}

// GetCommitDiscussion provides a mock function with given fields: pid, commit, discussion, options
func (_m *DiscussionsServiceInterface) GetCommitDiscussion(pid interface{}, commit string, discussion string, options ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, commit, discussion)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCommitDiscussion")
	}

	var r0 *gitlab.Discussion
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, string, ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error)); ok {
		return rf(pid, commit, discussion, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, string, ...gitlab.RequestOptionFunc) *gitlab.Discussion); ok {
		r0 = rf(pid, commit, discussion, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Discussion)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, string, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, commit, discussion, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, string, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, commit, discussion, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DiscussionsServiceInterface_GetCommitDiscussion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCommitDiscussion'
type DiscussionsServiceInterface_GetCommitDiscussion_Call struct {
	*mock.Call
}

// GetCommitDiscussion is a helper method to define mock.On call
//   - pid interface{}
//   - commit string
//   - discussion string
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) GetCommitDiscussion(pid interface{}, commit interface{}, discussion interface{}, options ...interface{}) *DiscussionsServiceInterface_GetCommitDiscussion_Call {
	return &DiscussionsServiceInterface_GetCommitDiscussion_Call{Call: _e.mock.On("GetCommitDiscussion",
		append([]interface{}{pid, commit, discussion}, options...)...)}
}

func (_c *DiscussionsServiceInterface_GetCommitDiscussion_Call) Run(run func(pid interface{}, commit string, discussion string, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_GetCommitDiscussion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_GetCommitDiscussion_Call) Return(_a0 *gitlab.Discussion, _a1 *gitlab.Response, _a2 error) *DiscussionsServiceInterface_GetCommitDiscussion_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *DiscussionsServiceInterface_GetCommitDiscussion_Call) RunAndReturn(run func(interface{}, string, string, ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error)) *DiscussionsServiceInterface_GetCommitDiscussion_Call {
	_c.Call.Return(run)
	return _c
}

// GetEpicDiscussion provides a mock function with given fields: gid, epic, discussion, options
func (_m *DiscussionsServiceInterface) GetEpicDiscussion(gid interface{}, epic int, discussion string, options ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, epic, discussion)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEpicDiscussion")
	}

	var r0 *gitlab.Discussion
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error)); ok {
		return rf(gid, epic, discussion, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) *gitlab.Discussion); ok {
		r0 = rf(gid, epic, discussion, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Discussion)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, epic, discussion, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, epic, discussion, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DiscussionsServiceInterface_GetEpicDiscussion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEpicDiscussion'
type DiscussionsServiceInterface_GetEpicDiscussion_Call struct {
	*mock.Call
}

// GetEpicDiscussion is a helper method to define mock.On call
//   - gid interface{}
//   - epic int
//   - discussion string
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) GetEpicDiscussion(gid interface{}, epic interface{}, discussion interface{}, options ...interface{}) *DiscussionsServiceInterface_GetEpicDiscussion_Call {
	return &DiscussionsServiceInterface_GetEpicDiscussion_Call{Call: _e.mock.On("GetEpicDiscussion",
		append([]interface{}{gid, epic, discussion}, options...)...)}
}

func (_c *DiscussionsServiceInterface_GetEpicDiscussion_Call) Run(run func(gid interface{}, epic int, discussion string, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_GetEpicDiscussion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_GetEpicDiscussion_Call) Return(_a0 *gitlab.Discussion, _a1 *gitlab.Response, _a2 error) *DiscussionsServiceInterface_GetEpicDiscussion_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *DiscussionsServiceInterface_GetEpicDiscussion_Call) RunAndReturn(run func(interface{}, int, string, ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error)) *DiscussionsServiceInterface_GetEpicDiscussion_Call {
	_c.Call.Return(run)
	return _c
}

// GetIssueDiscussion provides a mock function with given fields: pid, issue, discussion, options
func (_m *DiscussionsServiceInterface) GetIssueDiscussion(pid interface{}, issue int, discussion string, options ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issue, discussion)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIssueDiscussion")
	}

	var r0 *gitlab.Discussion
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error)); ok {
		return rf(pid, issue, discussion, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) *gitlab.Discussion); ok {
		r0 = rf(pid, issue, discussion, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Discussion)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issue, discussion, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issue, discussion, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DiscussionsServiceInterface_GetIssueDiscussion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIssueDiscussion'
type DiscussionsServiceInterface_GetIssueDiscussion_Call struct {
	*mock.Call
}

// GetIssueDiscussion is a helper method to define mock.On call
//   - pid interface{}
//   - issue int
//   - discussion string
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) GetIssueDiscussion(pid interface{}, issue interface{}, discussion interface{}, options ...interface{}) *DiscussionsServiceInterface_GetIssueDiscussion_Call {
	return &DiscussionsServiceInterface_GetIssueDiscussion_Call{Call: _e.mock.On("GetIssueDiscussion",
		append([]interface{}{pid, issue, discussion}, options...)...)}
}

func (_c *DiscussionsServiceInterface_GetIssueDiscussion_Call) Run(run func(pid interface{}, issue int, discussion string, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_GetIssueDiscussion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_GetIssueDiscussion_Call) Return(_a0 *gitlab.Discussion, _a1 *gitlab.Response, _a2 error) *DiscussionsServiceInterface_GetIssueDiscussion_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *DiscussionsServiceInterface_GetIssueDiscussion_Call) RunAndReturn(run func(interface{}, int, string, ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error)) *DiscussionsServiceInterface_GetIssueDiscussion_Call {
	_c.Call.Return(run)
	return _c
}

// GetMergeRequestDiscussion provides a mock function with given fields: pid, mergeRequest, discussion, options
func (_m *DiscussionsServiceInterface) GetMergeRequestDiscussion(pid interface{}, mergeRequest int, discussion string, options ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, discussion)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMergeRequestDiscussion")
	}

	var r0 *gitlab.Discussion
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, discussion, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) *gitlab.Discussion); ok {
		r0 = rf(pid, mergeRequest, discussion, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Discussion)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, discussion, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, discussion, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DiscussionsServiceInterface_GetMergeRequestDiscussion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMergeRequestDiscussion'
type DiscussionsServiceInterface_GetMergeRequestDiscussion_Call struct {
	*mock.Call
}

// GetMergeRequestDiscussion is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - discussion string
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) GetMergeRequestDiscussion(pid interface{}, mergeRequest interface{}, discussion interface{}, options ...interface{}) *DiscussionsServiceInterface_GetMergeRequestDiscussion_Call {
	return &DiscussionsServiceInterface_GetMergeRequestDiscussion_Call{Call: _e.mock.On("GetMergeRequestDiscussion",
		append([]interface{}{pid, mergeRequest, discussion}, options...)...)}
}

func (_c *DiscussionsServiceInterface_GetMergeRequestDiscussion_Call) Run(run func(pid interface{}, mergeRequest int, discussion string, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_GetMergeRequestDiscussion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_GetMergeRequestDiscussion_Call) Return(_a0 *gitlab.Discussion, _a1 *gitlab.Response, _a2 error) *DiscussionsServiceInterface_GetMergeRequestDiscussion_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *DiscussionsServiceInterface_GetMergeRequestDiscussion_Call) RunAndReturn(run func(interface{}, int, string, ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error)) *DiscussionsServiceInterface_GetMergeRequestDiscussion_Call {
	_c.Call.Return(run)
	return _c
}

// GetSnippetDiscussion provides a mock function with given fields: pid, snippet, discussion, options
func (_m *DiscussionsServiceInterface) GetSnippetDiscussion(pid interface{}, snippet int, discussion string, options ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, snippet, discussion)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSnippetDiscussion")
	}

	var r0 *gitlab.Discussion
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error)); ok {
		return rf(pid, snippet, discussion, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) *gitlab.Discussion); ok {
		r0 = rf(pid, snippet, discussion, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Discussion)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, snippet, discussion, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, snippet, discussion, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DiscussionsServiceInterface_GetSnippetDiscussion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSnippetDiscussion'
type DiscussionsServiceInterface_GetSnippetDiscussion_Call struct {
	*mock.Call
}

// GetSnippetDiscussion is a helper method to define mock.On call
//   - pid interface{}
//   - snippet int
//   - discussion string
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) GetSnippetDiscussion(pid interface{}, snippet interface{}, discussion interface{}, options ...interface{}) *DiscussionsServiceInterface_GetSnippetDiscussion_Call {
	return &DiscussionsServiceInterface_GetSnippetDiscussion_Call{Call: _e.mock.On("GetSnippetDiscussion",
		append([]interface{}{pid, snippet, discussion}, options...)...)}
}

func (_c *DiscussionsServiceInterface_GetSnippetDiscussion_Call) Run(run func(pid interface{}, snippet int, discussion string, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_GetSnippetDiscussion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_GetSnippetDiscussion_Call) Return(_a0 *gitlab.Discussion, _a1 *gitlab.Response, _a2 error) *DiscussionsServiceInterface_GetSnippetDiscussion_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *DiscussionsServiceInterface_GetSnippetDiscussion_Call) RunAndReturn(run func(interface{}, int, string, ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error)) *DiscussionsServiceInterface_GetSnippetDiscussion_Call {
	_c.Call.Return(run)
	return _c
}

// ListCommitDiscussions provides a mock function with given fields: pid, commit, opt, options
func (_m *DiscussionsServiceInterface) ListCommitDiscussions(pid interface{}, commit string, opt *gitlab.ListCommitDiscussionsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Discussion, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, commit, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCommitDiscussions")
	}

	var r0 []*gitlab.Discussion
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.ListCommitDiscussionsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Discussion, *gitlab.Response, error)); ok {
		return rf(pid, commit, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.ListCommitDiscussionsOptions, ...gitlab.RequestOptionFunc) []*gitlab.Discussion); ok {
		r0 = rf(pid, commit, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Discussion)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, *gitlab.ListCommitDiscussionsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, commit, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, *gitlab.ListCommitDiscussionsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, commit, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DiscussionsServiceInterface_ListCommitDiscussions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListCommitDiscussions'
type DiscussionsServiceInterface_ListCommitDiscussions_Call struct {
	*mock.Call
}

// ListCommitDiscussions is a helper method to define mock.On call
//   - pid interface{}
//   - commit string
//   - opt *gitlab.ListCommitDiscussionsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) ListCommitDiscussions(pid interface{}, commit interface{}, opt interface{}, options ...interface{}) *DiscussionsServiceInterface_ListCommitDiscussions_Call {
	return &DiscussionsServiceInterface_ListCommitDiscussions_Call{Call: _e.mock.On("ListCommitDiscussions",
		append([]interface{}{pid, commit, opt}, options...)...)}
}

func (_c *DiscussionsServiceInterface_ListCommitDiscussions_Call) Run(run func(pid interface{}, commit string, opt *gitlab.ListCommitDiscussionsOptions, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_ListCommitDiscussions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(*gitlab.ListCommitDiscussionsOptions), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_ListCommitDiscussions_Call) Return(_a0 []*gitlab.Discussion, _a1 *gitlab.Response, _a2 error) *DiscussionsServiceInterface_ListCommitDiscussions_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *DiscussionsServiceInterface_ListCommitDiscussions_Call) RunAndReturn(run func(interface{}, string, *gitlab.ListCommitDiscussionsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Discussion, *gitlab.Response, error)) *DiscussionsServiceInterface_ListCommitDiscussions_Call {
	_c.Call.Return(run)
	return _c
}

// ListGroupEpicDiscussions provides a mock function with given fields: gid, epic, opt, options
func (_m *DiscussionsServiceInterface) ListGroupEpicDiscussions(gid interface{}, epic int, opt *gitlab.ListGroupEpicDiscussionsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Discussion, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, epic, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListGroupEpicDiscussions")
	}

	var r0 []*gitlab.Discussion
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListGroupEpicDiscussionsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Discussion, *gitlab.Response, error)); ok {
		return rf(gid, epic, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListGroupEpicDiscussionsOptions, ...gitlab.RequestOptionFunc) []*gitlab.Discussion); ok {
		r0 = rf(gid, epic, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Discussion)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.ListGroupEpicDiscussionsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, epic, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.ListGroupEpicDiscussionsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, epic, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DiscussionsServiceInterface_ListGroupEpicDiscussions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListGroupEpicDiscussions'
type DiscussionsServiceInterface_ListGroupEpicDiscussions_Call struct {
	*mock.Call
}

// ListGroupEpicDiscussions is a helper method to define mock.On call
//   - gid interface{}
//   - epic int
//   - opt *gitlab.ListGroupEpicDiscussionsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) ListGroupEpicDiscussions(gid interface{}, epic interface{}, opt interface{}, options ...interface{}) *DiscussionsServiceInterface_ListGroupEpicDiscussions_Call {
	return &DiscussionsServiceInterface_ListGroupEpicDiscussions_Call{Call: _e.mock.On("ListGroupEpicDiscussions",
		append([]interface{}{gid, epic, opt}, options...)...)}
}

func (_c *DiscussionsServiceInterface_ListGroupEpicDiscussions_Call) Run(run func(gid interface{}, epic int, opt *gitlab.ListGroupEpicDiscussionsOptions, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_ListGroupEpicDiscussions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.ListGroupEpicDiscussionsOptions), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_ListGroupEpicDiscussions_Call) Return(_a0 []*gitlab.Discussion, _a1 *gitlab.Response, _a2 error) *DiscussionsServiceInterface_ListGroupEpicDiscussions_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *DiscussionsServiceInterface_ListGroupEpicDiscussions_Call) RunAndReturn(run func(interface{}, int, *gitlab.ListGroupEpicDiscussionsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Discussion, *gitlab.Response, error)) *DiscussionsServiceInterface_ListGroupEpicDiscussions_Call {
	_c.Call.Return(run)
	return _c
}

// ListIssueDiscussions provides a mock function with given fields: pid, issue, opt, options
func (_m *DiscussionsServiceInterface) ListIssueDiscussions(pid interface{}, issue int, opt *gitlab.ListIssueDiscussionsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Discussion, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issue, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListIssueDiscussions")
	}

	var r0 []*gitlab.Discussion
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListIssueDiscussionsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Discussion, *gitlab.Response, error)); ok {
		return rf(pid, issue, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListIssueDiscussionsOptions, ...gitlab.RequestOptionFunc) []*gitlab.Discussion); ok {
		r0 = rf(pid, issue, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Discussion)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.ListIssueDiscussionsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issue, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.ListIssueDiscussionsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issue, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DiscussionsServiceInterface_ListIssueDiscussions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListIssueDiscussions'
type DiscussionsServiceInterface_ListIssueDiscussions_Call struct {
	*mock.Call
}

// ListIssueDiscussions is a helper method to define mock.On call
//   - pid interface{}
//   - issue int
//   - opt *gitlab.ListIssueDiscussionsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) ListIssueDiscussions(pid interface{}, issue interface{}, opt interface{}, options ...interface{}) *DiscussionsServiceInterface_ListIssueDiscussions_Call {
	return &DiscussionsServiceInterface_ListIssueDiscussions_Call{Call: _e.mock.On("ListIssueDiscussions",
		append([]interface{}{pid, issue, opt}, options...)...)}
}

func (_c *DiscussionsServiceInterface_ListIssueDiscussions_Call) Run(run func(pid interface{}, issue int, opt *gitlab.ListIssueDiscussionsOptions, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_ListIssueDiscussions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.ListIssueDiscussionsOptions), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_ListIssueDiscussions_Call) Return(_a0 []*gitlab.Discussion, _a1 *gitlab.Response, _a2 error) *DiscussionsServiceInterface_ListIssueDiscussions_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *DiscussionsServiceInterface_ListIssueDiscussions_Call) RunAndReturn(run func(interface{}, int, *gitlab.ListIssueDiscussionsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Discussion, *gitlab.Response, error)) *DiscussionsServiceInterface_ListIssueDiscussions_Call {
	_c.Call.Return(run)
	return _c
}

// ListMergeRequestDiscussions provides a mock function with given fields: pid, mergeRequest, opt, options
func (_m *DiscussionsServiceInterface) ListMergeRequestDiscussions(pid interface{}, mergeRequest int, opt *gitlab.ListMergeRequestDiscussionsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Discussion, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMergeRequestDiscussions")
	}

	var r0 []*gitlab.Discussion
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListMergeRequestDiscussionsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Discussion, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListMergeRequestDiscussionsOptions, ...gitlab.RequestOptionFunc) []*gitlab.Discussion); ok {
		r0 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Discussion)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.ListMergeRequestDiscussionsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.ListMergeRequestDiscussionsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DiscussionsServiceInterface_ListMergeRequestDiscussions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMergeRequestDiscussions'
type DiscussionsServiceInterface_ListMergeRequestDiscussions_Call struct {
	*mock.Call
}

// ListMergeRequestDiscussions is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - opt *gitlab.ListMergeRequestDiscussionsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) ListMergeRequestDiscussions(pid interface{}, mergeRequest interface{}, opt interface{}, options ...interface{}) *DiscussionsServiceInterface_ListMergeRequestDiscussions_Call {
	return &DiscussionsServiceInterface_ListMergeRequestDiscussions_Call{Call: _e.mock.On("ListMergeRequestDiscussions",
		append([]interface{}{pid, mergeRequest, opt}, options...)...)}
}

func (_c *DiscussionsServiceInterface_ListMergeRequestDiscussions_Call) Run(run func(pid interface{}, mergeRequest int, opt *gitlab.ListMergeRequestDiscussionsOptions, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_ListMergeRequestDiscussions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.ListMergeRequestDiscussionsOptions), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_ListMergeRequestDiscussions_Call) Return(_a0 []*gitlab.Discussion, _a1 *gitlab.Response, _a2 error) *DiscussionsServiceInterface_ListMergeRequestDiscussions_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *DiscussionsServiceInterface_ListMergeRequestDiscussions_Call) RunAndReturn(run func(interface{}, int, *gitlab.ListMergeRequestDiscussionsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Discussion, *gitlab.Response, error)) *DiscussionsServiceInterface_ListMergeRequestDiscussions_Call {
	_c.Call.Return(run)
	return _c
}

// ListSnippetDiscussions provides a mock function with given fields: pid, snippet, opt, options
func (_m *DiscussionsServiceInterface) ListSnippetDiscussions(pid interface{}, snippet int, opt *gitlab.ListSnippetDiscussionsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Discussion, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, snippet, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSnippetDiscussions")
	}

	var r0 []*gitlab.Discussion
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListSnippetDiscussionsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Discussion, *gitlab.Response, error)); ok {
		return rf(pid, snippet, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListSnippetDiscussionsOptions, ...gitlab.RequestOptionFunc) []*gitlab.Discussion); ok {
		r0 = rf(pid, snippet, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Discussion)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.ListSnippetDiscussionsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, snippet, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.ListSnippetDiscussionsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, snippet, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DiscussionsServiceInterface_ListSnippetDiscussions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListSnippetDiscussions'
type DiscussionsServiceInterface_ListSnippetDiscussions_Call struct {
	*mock.Call
}

// ListSnippetDiscussions is a helper method to define mock.On call
//   - pid interface{}
//   - snippet int
//   - opt *gitlab.ListSnippetDiscussionsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) ListSnippetDiscussions(pid interface{}, snippet interface{}, opt interface{}, options ...interface{}) *DiscussionsServiceInterface_ListSnippetDiscussions_Call {
	return &DiscussionsServiceInterface_ListSnippetDiscussions_Call{Call: _e.mock.On("ListSnippetDiscussions",
		append([]interface{}{pid, snippet, opt}, options...)...)}
}

func (_c *DiscussionsServiceInterface_ListSnippetDiscussions_Call) Run(run func(pid interface{}, snippet int, opt *gitlab.ListSnippetDiscussionsOptions, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_ListSnippetDiscussions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.ListSnippetDiscussionsOptions), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_ListSnippetDiscussions_Call) Return(_a0 []*gitlab.Discussion, _a1 *gitlab.Response, _a2 error) *DiscussionsServiceInterface_ListSnippetDiscussions_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *DiscussionsServiceInterface_ListSnippetDiscussions_Call) RunAndReturn(run func(interface{}, int, *gitlab.ListSnippetDiscussionsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Discussion, *gitlab.Response, error)) *DiscussionsServiceInterface_ListSnippetDiscussions_Call {
	_c.Call.Return(run)
	return _c
}

// ResolveMergeRequestDiscussion provides a mock function with given fields: pid, mergeRequest, discussion, opt, options
func (_m *DiscussionsServiceInterface) ResolveMergeRequestDiscussion(pid interface{}, mergeRequest int, discussion string, opt *gitlab.ResolveMergeRequestDiscussionOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, discussion, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResolveMergeRequestDiscussion")
	}

	var r0 *gitlab.Discussion
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, string, *gitlab.ResolveMergeRequestDiscussionOptions, ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, discussion, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, string, *gitlab.ResolveMergeRequestDiscussionOptions, ...gitlab.RequestOptionFunc) *gitlab.Discussion); ok {
		r0 = rf(pid, mergeRequest, discussion, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Discussion)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, string, *gitlab.ResolveMergeRequestDiscussionOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, discussion, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, string, *gitlab.ResolveMergeRequestDiscussionOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, discussion, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DiscussionsServiceInterface_ResolveMergeRequestDiscussion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResolveMergeRequestDiscussion'
type DiscussionsServiceInterface_ResolveMergeRequestDiscussion_Call struct {
	*mock.Call
}

// ResolveMergeRequestDiscussion is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - discussion string
//   - opt *gitlab.ResolveMergeRequestDiscussionOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) ResolveMergeRequestDiscussion(pid interface{}, mergeRequest interface{}, discussion interface{}, opt interface{}, options ...interface{}) *DiscussionsServiceInterface_ResolveMergeRequestDiscussion_Call {
	return &DiscussionsServiceInterface_ResolveMergeRequestDiscussion_Call{Call: _e.mock.On("ResolveMergeRequestDiscussion",
		append([]interface{}{pid, mergeRequest, discussion, opt}, options...)...)}
}

func (_c *DiscussionsServiceInterface_ResolveMergeRequestDiscussion_Call) Run(run func(pid interface{}, mergeRequest int, discussion string, opt *gitlab.ResolveMergeRequestDiscussionOptions, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_ResolveMergeRequestDiscussion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(string), args[3].(*gitlab.ResolveMergeRequestDiscussionOptions), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_ResolveMergeRequestDiscussion_Call) Return(_a0 *gitlab.Discussion, _a1 *gitlab.Response, _a2 error) *DiscussionsServiceInterface_ResolveMergeRequestDiscussion_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *DiscussionsServiceInterface_ResolveMergeRequestDiscussion_Call) RunAndReturn(run func(interface{}, int, string, *gitlab.ResolveMergeRequestDiscussionOptions, ...gitlab.RequestOptionFunc) (*gitlab.Discussion, *gitlab.Response, error)) *DiscussionsServiceInterface_ResolveMergeRequestDiscussion_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateCommitDiscussionNote provides a mock function with given fields: pid, commit, discussion, note, opt, options
func (_m *DiscussionsServiceInterface) UpdateCommitDiscussionNote(pid interface{}, commit string, discussion string, note int, opt *gitlab.UpdateCommitDiscussionNoteOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, commit, discussion, note, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCommitDiscussionNote")
	}

	var r0 *gitlab.Note
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, string, int, *gitlab.UpdateCommitDiscussionNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)); ok {
		return rf(pid, commit, discussion, note, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, string, int, *gitlab.UpdateCommitDiscussionNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Note); ok {
		r0 = rf(pid, commit, discussion, note, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Note)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, string, int, *gitlab.UpdateCommitDiscussionNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, commit, discussion, note, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, string, int, *gitlab.UpdateCommitDiscussionNoteOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, commit, discussion, note, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DiscussionsServiceInterface_UpdateCommitDiscussionNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateCommitDiscussionNote'
type DiscussionsServiceInterface_UpdateCommitDiscussionNote_Call struct {
	*mock.Call
}

// UpdateCommitDiscussionNote is a helper method to define mock.On call
//   - pid interface{}
//   - commit string
//   - discussion string
//   - note int
//   - opt *gitlab.UpdateCommitDiscussionNoteOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) UpdateCommitDiscussionNote(pid interface{}, commit interface{}, discussion interface{}, note interface{}, opt interface{}, options ...interface{}) *DiscussionsServiceInterface_UpdateCommitDiscussionNote_Call {
	return &DiscussionsServiceInterface_UpdateCommitDiscussionNote_Call{Call: _e.mock.On("UpdateCommitDiscussionNote",
		append([]interface{}{pid, commit, discussion, note, opt}, options...)...)}
}

func (_c *DiscussionsServiceInterface_UpdateCommitDiscussionNote_Call) Run(run func(pid interface{}, commit string, discussion string, note int, opt *gitlab.UpdateCommitDiscussionNoteOptions, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_UpdateCommitDiscussionNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(string), args[3].(int), args[4].(*gitlab.UpdateCommitDiscussionNoteOptions), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_UpdateCommitDiscussionNote_Call) Return(_a0 *gitlab.Note, _a1 *gitlab.Response, _a2 error) *DiscussionsServiceInterface_UpdateCommitDiscussionNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *DiscussionsServiceInterface_UpdateCommitDiscussionNote_Call) RunAndReturn(run func(interface{}, string, string, int, *gitlab.UpdateCommitDiscussionNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *DiscussionsServiceInterface_UpdateCommitDiscussionNote_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateEpicDiscussionNote provides a mock function with given fields: gid, epic, discussion, note, opt, options
func (_m *DiscussionsServiceInterface) UpdateEpicDiscussionNote(gid interface{}, epic int, discussion string, note int, opt *gitlab.UpdateEpicDiscussionNoteOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, epic, discussion, note, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEpicDiscussionNote")
	}

	var r0 *gitlab.Note
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, string, int, *gitlab.UpdateEpicDiscussionNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)); ok {
		return rf(gid, epic, discussion, note, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, string, int, *gitlab.UpdateEpicDiscussionNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Note); ok {
		r0 = rf(gid, epic, discussion, note, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Note)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, string, int, *gitlab.UpdateEpicDiscussionNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, epic, discussion, note, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, string, int, *gitlab.UpdateEpicDiscussionNoteOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, epic, discussion, note, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DiscussionsServiceInterface_UpdateEpicDiscussionNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateEpicDiscussionNote'
type DiscussionsServiceInterface_UpdateEpicDiscussionNote_Call struct {
	*mock.Call
}

// UpdateEpicDiscussionNote is a helper method to define mock.On call
//   - gid interface{}
//   - epic int
//   - discussion string
//   - note int
//   - opt *gitlab.UpdateEpicDiscussionNoteOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) UpdateEpicDiscussionNote(gid interface{}, epic interface{}, discussion interface{}, note interface{}, opt interface{}, options ...interface{}) *DiscussionsServiceInterface_UpdateEpicDiscussionNote_Call {
	return &DiscussionsServiceInterface_UpdateEpicDiscussionNote_Call{Call: _e.mock.On("UpdateEpicDiscussionNote",
		append([]interface{}{gid, epic, discussion, note, opt}, options...)...)}
}

func (_c *DiscussionsServiceInterface_UpdateEpicDiscussionNote_Call) Run(run func(gid interface{}, epic int, discussion string, note int, opt *gitlab.UpdateEpicDiscussionNoteOptions, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_UpdateEpicDiscussionNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(string), args[3].(int), args[4].(*gitlab.UpdateEpicDiscussionNoteOptions), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_UpdateEpicDiscussionNote_Call) Return(_a0 *gitlab.Note, _a1 *gitlab.Response, _a2 error) *DiscussionsServiceInterface_UpdateEpicDiscussionNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *DiscussionsServiceInterface_UpdateEpicDiscussionNote_Call) RunAndReturn(run func(interface{}, int, string, int, *gitlab.UpdateEpicDiscussionNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *DiscussionsServiceInterface_UpdateEpicDiscussionNote_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateIssueDiscussionNote provides a mock function with given fields: pid, issue, discussion, note, opt, options
func (_m *DiscussionsServiceInterface) UpdateIssueDiscussionNote(pid interface{}, issue int, discussion string, note int, opt *gitlab.UpdateIssueDiscussionNoteOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issue, discussion, note, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateIssueDiscussionNote")
	}

	var r0 *gitlab.Note
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, string, int, *gitlab.UpdateIssueDiscussionNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)); ok {
		return rf(pid, issue, discussion, note, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, string, int, *gitlab.UpdateIssueDiscussionNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Note); ok {
		r0 = rf(pid, issue, discussion, note, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Note)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, string, int, *gitlab.UpdateIssueDiscussionNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issue, discussion, note, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, string, int, *gitlab.UpdateIssueDiscussionNoteOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issue, discussion, note, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DiscussionsServiceInterface_UpdateIssueDiscussionNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateIssueDiscussionNote'
type DiscussionsServiceInterface_UpdateIssueDiscussionNote_Call struct {
	*mock.Call
}

// UpdateIssueDiscussionNote is a helper method to define mock.On call
//   - pid interface{}
//   - issue int
//   - discussion string
//   - note int
//   - opt *gitlab.UpdateIssueDiscussionNoteOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) UpdateIssueDiscussionNote(pid interface{}, issue interface{}, discussion interface{}, note interface{}, opt interface{}, options ...interface{}) *DiscussionsServiceInterface_UpdateIssueDiscussionNote_Call {
	return &DiscussionsServiceInterface_UpdateIssueDiscussionNote_Call{Call: _e.mock.On("UpdateIssueDiscussionNote",
		append([]interface{}{pid, issue, discussion, note, opt}, options...)...)}
}

func (_c *DiscussionsServiceInterface_UpdateIssueDiscussionNote_Call) Run(run func(pid interface{}, issue int, discussion string, note int, opt *gitlab.UpdateIssueDiscussionNoteOptions, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_UpdateIssueDiscussionNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(string), args[3].(int), args[4].(*gitlab.UpdateIssueDiscussionNoteOptions), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_UpdateIssueDiscussionNote_Call) Return(_a0 *gitlab.Note, _a1 *gitlab.Response, _a2 error) *DiscussionsServiceInterface_UpdateIssueDiscussionNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *DiscussionsServiceInterface_UpdateIssueDiscussionNote_Call) RunAndReturn(run func(interface{}, int, string, int, *gitlab.UpdateIssueDiscussionNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *DiscussionsServiceInterface_UpdateIssueDiscussionNote_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateMergeRequestDiscussionNote provides a mock function with given fields: pid, mergeRequest, discussion, note, opt, options
func (_m *DiscussionsServiceInterface) UpdateMergeRequestDiscussionNote(pid interface{}, mergeRequest int, discussion string, note int, opt *gitlab.UpdateMergeRequestDiscussionNoteOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, discussion, note, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMergeRequestDiscussionNote")
	}

	var r0 *gitlab.Note
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, string, int, *gitlab.UpdateMergeRequestDiscussionNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, discussion, note, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, string, int, *gitlab.UpdateMergeRequestDiscussionNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Note); ok {
		r0 = rf(pid, mergeRequest, discussion, note, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Note)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, string, int, *gitlab.UpdateMergeRequestDiscussionNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, discussion, note, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, string, int, *gitlab.UpdateMergeRequestDiscussionNoteOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, discussion, note, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DiscussionsServiceInterface_UpdateMergeRequestDiscussionNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateMergeRequestDiscussionNote'
type DiscussionsServiceInterface_UpdateMergeRequestDiscussionNote_Call struct {
	*mock.Call
}

// UpdateMergeRequestDiscussionNote is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - discussion string
//   - note int
//   - opt *gitlab.UpdateMergeRequestDiscussionNoteOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) UpdateMergeRequestDiscussionNote(pid interface{}, mergeRequest interface{}, discussion interface{}, note interface{}, opt interface{}, options ...interface{}) *DiscussionsServiceInterface_UpdateMergeRequestDiscussionNote_Call {
	return &DiscussionsServiceInterface_UpdateMergeRequestDiscussionNote_Call{Call: _e.mock.On("UpdateMergeRequestDiscussionNote",
		append([]interface{}{pid, mergeRequest, discussion, note, opt}, options...)...)}
}

func (_c *DiscussionsServiceInterface_UpdateMergeRequestDiscussionNote_Call) Run(run func(pid interface{}, mergeRequest int, discussion string, note int, opt *gitlab.UpdateMergeRequestDiscussionNoteOptions, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_UpdateMergeRequestDiscussionNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(string), args[3].(int), args[4].(*gitlab.UpdateMergeRequestDiscussionNoteOptions), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_UpdateMergeRequestDiscussionNote_Call) Return(_a0 *gitlab.Note, _a1 *gitlab.Response, _a2 error) *DiscussionsServiceInterface_UpdateMergeRequestDiscussionNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *DiscussionsServiceInterface_UpdateMergeRequestDiscussionNote_Call) RunAndReturn(run func(interface{}, int, string, int, *gitlab.UpdateMergeRequestDiscussionNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *DiscussionsServiceInterface_UpdateMergeRequestDiscussionNote_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateSnippetDiscussionNote provides a mock function with given fields: pid, snippet, discussion, note, opt, options
func (_m *DiscussionsServiceInterface) UpdateSnippetDiscussionNote(pid interface{}, snippet int, discussion string, note int, opt *gitlab.UpdateSnippetDiscussionNoteOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, snippet, discussion, note, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSnippetDiscussionNote")
	}

	var r0 *gitlab.Note
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, string, int, *gitlab.UpdateSnippetDiscussionNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)); ok {
		return rf(pid, snippet, discussion, note, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, string, int, *gitlab.UpdateSnippetDiscussionNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Note); ok {
		r0 = rf(pid, snippet, discussion, note, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Note)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, string, int, *gitlab.UpdateSnippetDiscussionNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, snippet, discussion, note, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, string, int, *gitlab.UpdateSnippetDiscussionNoteOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, snippet, discussion, note, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// DiscussionsServiceInterface_UpdateSnippetDiscussionNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateSnippetDiscussionNote'
type DiscussionsServiceInterface_UpdateSnippetDiscussionNote_Call struct {
	*mock.Call
}

// UpdateSnippetDiscussionNote is a helper method to define mock.On call
//   - pid interface{}
//   - snippet int
//   - discussion string
//   - note int
//   - opt *gitlab.UpdateSnippetDiscussionNoteOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *DiscussionsServiceInterface_Expecter) UpdateSnippetDiscussionNote(pid interface{}, snippet interface{}, discussion interface{}, note interface{}, opt interface{}, options ...interface{}) *DiscussionsServiceInterface_UpdateSnippetDiscussionNote_Call {
	return &DiscussionsServiceInterface_UpdateSnippetDiscussionNote_Call{Call: _e.mock.On("UpdateSnippetDiscussionNote",
		append([]interface{}{pid, snippet, discussion, note, opt}, options...)...)}
}

func (_c *DiscussionsServiceInterface_UpdateSnippetDiscussionNote_Call) Run(run func(pid interface{}, snippet int, discussion string, note int, opt *gitlab.UpdateSnippetDiscussionNoteOptions, options ...gitlab.RequestOptionFunc)) *DiscussionsServiceInterface_UpdateSnippetDiscussionNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-5)
		for i, a := range args[5:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(string), args[3].(int), args[4].(*gitlab.UpdateSnippetDiscussionNoteOptions), variadicArgs...)
	})
	return _c
}

func (_c *DiscussionsServiceInterface_UpdateSnippetDiscussionNote_Call) Return(_a0 *gitlab.Note, _a1 *gitlab.Response, _a2 error) *DiscussionsServiceInterface_UpdateSnippetDiscussionNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *DiscussionsServiceInterface_UpdateSnippetDiscussionNote_Call) RunAndReturn(run func(interface{}, int, string, int, *gitlab.UpdateSnippetDiscussionNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *DiscussionsServiceInterface_UpdateSnippetDiscussionNote_Call {
	_c.Call.Return(run)
	return _c
}

// NewDiscussionsServiceInterface creates a new instance of DiscussionsServiceInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewDiscussionsServiceInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *DiscussionsServiceInterface {
	mock := &DiscussionsServiceInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

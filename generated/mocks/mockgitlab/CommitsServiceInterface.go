// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"
	gitlab "gitlab.com/gitlab-org/api/client-go"
)

// CommitsServiceInterface is an autogenerated mock type for the CommitsServiceInterface type
type CommitsServiceInterface struct {
	mock.Mock
}

type CommitsServiceInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *CommitsServiceInterface) EXPECT() *CommitsServiceInterface_Expecter {
	return &CommitsServiceInterface_Expecter{mock: &_m.Mock}
}

// CherryPickCommit provides a mock function with given fields: pid, sha, opt, options
func (_m *CommitsServiceInterface) CherryPickCommit(pid interface{}, sha string, opt *gitlab.CherryPickCommitOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Commit, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, sha, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CherryPickCommit")
	}

	var r0 *gitlab.Commit
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.CherryPickCommitOptions, ...gitlab.RequestOptionFunc) (*gitlab.Commit, *gitlab.Response, error)); ok {
		return rf(pid, sha, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.CherryPickCommitOptions, ...gitlab.RequestOptionFunc) *gitlab.Commit); ok {
		r0 = rf(pid, sha, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Commit)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, *gitlab.CherryPickCommitOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, sha, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, *gitlab.CherryPickCommitOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, sha, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// CommitsServiceInterface_CherryPickCommit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CherryPickCommit'
type CommitsServiceInterface_CherryPickCommit_Call struct {
	*mock.Call
}

// CherryPickCommit is a helper method to define mock.On call
//   - pid interface{}
//   - sha string
//   - opt *gitlab.CherryPickCommitOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *CommitsServiceInterface_Expecter) CherryPickCommit(pid interface{}, sha interface{}, opt interface{}, options ...interface{}) *CommitsServiceInterface_CherryPickCommit_Call {
	return &CommitsServiceInterface_CherryPickCommit_Call{Call: _e.mock.On("CherryPickCommit",
		append([]interface{}{pid, sha, opt}, options...)...)}
}

func (_c *CommitsServiceInterface_CherryPickCommit_Call) Run(run func(pid interface{}, sha string, opt *gitlab.CherryPickCommitOptions, options ...gitlab.RequestOptionFunc)) *CommitsServiceInterface_CherryPickCommit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(*gitlab.CherryPickCommitOptions), variadicArgs...)
	})
	return _c
}

func (_c *CommitsServiceInterface_CherryPickCommit_Call) Return(_a0 *gitlab.Commit, _a1 *gitlab.Response, _a2 error) *CommitsServiceInterface_CherryPickCommit_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *CommitsServiceInterface_CherryPickCommit_Call) RunAndReturn(run func(interface{}, string, *gitlab.CherryPickCommitOptions, ...gitlab.RequestOptionFunc) (*gitlab.Commit, *gitlab.Response, error)) *CommitsServiceInterface_CherryPickCommit_Call {
	_c.Call.Return(run)
	return _c
}

// CreateCommit provides a mock function with given fields: pid, opt, options
func (_m *CommitsServiceInterface) CreateCommit(pid interface{}, opt *gitlab.CreateCommitOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Commit, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateCommit")
	}

	var r0 *gitlab.Commit
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.CreateCommitOptions, ...gitlab.RequestOptionFunc) (*gitlab.Commit, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.CreateCommitOptions, ...gitlab.RequestOptionFunc) *gitlab.Commit); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Commit)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.CreateCommitOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.CreateCommitOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// CommitsServiceInterface_CreateCommit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCommit'
type CommitsServiceInterface_CreateCommit_Call struct {
	*mock.Call
}

// CreateCommit is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.CreateCommitOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *CommitsServiceInterface_Expecter) CreateCommit(pid interface{}, opt interface{}, options ...interface{}) *CommitsServiceInterface_CreateCommit_Call {
	return &CommitsServiceInterface_CreateCommit_Call{Call: _e.mock.On("CreateCommit",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *CommitsServiceInterface_CreateCommit_Call) Run(run func(pid interface{}, opt *gitlab.CreateCommitOptions, options ...gitlab.RequestOptionFunc)) *CommitsServiceInterface_CreateCommit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.CreateCommitOptions), variadicArgs...)
	})
	return _c
}

func (_c *CommitsServiceInterface_CreateCommit_Call) Return(_a0 *gitlab.Commit, _a1 *gitlab.Response, _a2 error) *CommitsServiceInterface_CreateCommit_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *CommitsServiceInterface_CreateCommit_Call) RunAndReturn(run func(interface{}, *gitlab.CreateCommitOptions, ...gitlab.RequestOptionFunc) (*gitlab.Commit, *gitlab.Response, error)) *CommitsServiceInterface_CreateCommit_Call {
	_c.Call.Return(run)
	return _c
}

// GetCommit provides a mock function with given fields: pid, sha, opt, options
func (_m *CommitsServiceInterface) GetCommit(pid interface{}, sha string, opt *gitlab.GetCommitOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Commit, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, sha, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCommit")
	}

	var r0 *gitlab.Commit
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.GetCommitOptions, ...gitlab.RequestOptionFunc) (*gitlab.Commit, *gitlab.Response, error)); ok {
		return rf(pid, sha, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.GetCommitOptions, ...gitlab.RequestOptionFunc) *gitlab.Commit); ok {
		r0 = rf(pid, sha, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Commit)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, *gitlab.GetCommitOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, sha, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, *gitlab.GetCommitOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, sha, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// CommitsServiceInterface_GetCommit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCommit'
type CommitsServiceInterface_GetCommit_Call struct {
	*mock.Call
}

// GetCommit is a helper method to define mock.On call
//   - pid interface{}
//   - sha string
//   - opt *gitlab.GetCommitOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *CommitsServiceInterface_Expecter) GetCommit(pid interface{}, sha interface{}, opt interface{}, options ...interface{}) *CommitsServiceInterface_GetCommit_Call {
	return &CommitsServiceInterface_GetCommit_Call{Call: _e.mock.On("GetCommit",
		append([]interface{}{pid, sha, opt}, options...)...)}
}

func (_c *CommitsServiceInterface_GetCommit_Call) Run(run func(pid interface{}, sha string, opt *gitlab.GetCommitOptions, options ...gitlab.RequestOptionFunc)) *CommitsServiceInterface_GetCommit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(*gitlab.GetCommitOptions), variadicArgs...)
	})
	return _c
}

func (_c *CommitsServiceInterface_GetCommit_Call) Return(_a0 *gitlab.Commit, _a1 *gitlab.Response, _a2 error) *CommitsServiceInterface_GetCommit_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *CommitsServiceInterface_GetCommit_Call) RunAndReturn(run func(interface{}, string, *gitlab.GetCommitOptions, ...gitlab.RequestOptionFunc) (*gitlab.Commit, *gitlab.Response, error)) *CommitsServiceInterface_GetCommit_Call {
	_c.Call.Return(run)
	return _c
}

// GetCommitComments provides a mock function with given fields: pid, sha, opt, options
func (_m *CommitsServiceInterface) GetCommitComments(pid interface{}, sha string, opt *gitlab.GetCommitCommentsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.CommitComment, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, sha, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCommitComments")
	}

	var r0 []*gitlab.CommitComment
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.GetCommitCommentsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.CommitComment, *gitlab.Response, error)); ok {
		return rf(pid, sha, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.GetCommitCommentsOptions, ...gitlab.RequestOptionFunc) []*gitlab.CommitComment); ok {
		r0 = rf(pid, sha, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.CommitComment)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, *gitlab.GetCommitCommentsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, sha, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, *gitlab.GetCommitCommentsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, sha, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// CommitsServiceInterface_GetCommitComments_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCommitComments'
type CommitsServiceInterface_GetCommitComments_Call struct {
	*mock.Call
}

// GetCommitComments is a helper method to define mock.On call
//   - pid interface{}
//   - sha string
//   - opt *gitlab.GetCommitCommentsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *CommitsServiceInterface_Expecter) GetCommitComments(pid interface{}, sha interface{}, opt interface{}, options ...interface{}) *CommitsServiceInterface_GetCommitComments_Call {
	return &CommitsServiceInterface_GetCommitComments_Call{Call: _e.mock.On("GetCommitComments",
		append([]interface{}{pid, sha, opt}, options...)...)}
}

func (_c *CommitsServiceInterface_GetCommitComments_Call) Run(run func(pid interface{}, sha string, opt *gitlab.GetCommitCommentsOptions, options ...gitlab.RequestOptionFunc)) *CommitsServiceInterface_GetCommitComments_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(*gitlab.GetCommitCommentsOptions), variadicArgs...)
	})
	return _c
}

func (_c *CommitsServiceInterface_GetCommitComments_Call) Return(_a0 []*gitlab.CommitComment, _a1 *gitlab.Response, _a2 error) *CommitsServiceInterface_GetCommitComments_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *CommitsServiceInterface_GetCommitComments_Call) RunAndReturn(run func(interface{}, string, *gitlab.GetCommitCommentsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.CommitComment, *gitlab.Response, error)) *CommitsServiceInterface_GetCommitComments_Call {
	_c.Call.Return(run)
	return _c
}

// GetCommitDiff provides a mock function with given fields: pid, sha, opt, options
func (_m *CommitsServiceInterface) GetCommitDiff(pid interface{}, sha string, opt *gitlab.GetCommitDiffOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Diff, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, sha, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCommitDiff")
	}

	var r0 []*gitlab.Diff
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.GetCommitDiffOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Diff, *gitlab.Response, error)); ok {
		return rf(pid, sha, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.GetCommitDiffOptions, ...gitlab.RequestOptionFunc) []*gitlab.Diff); ok {
		r0 = rf(pid, sha, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Diff)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, *gitlab.GetCommitDiffOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, sha, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, *gitlab.GetCommitDiffOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, sha, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// CommitsServiceInterface_GetCommitDiff_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCommitDiff'
type CommitsServiceInterface_GetCommitDiff_Call struct {
	*mock.Call
}

// GetCommitDiff is a helper method to define mock.On call
//   - pid interface{}
//   - sha string
//   - opt *gitlab.GetCommitDiffOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *CommitsServiceInterface_Expecter) GetCommitDiff(pid interface{}, sha interface{}, opt interface{}, options ...interface{}) *CommitsServiceInterface_GetCommitDiff_Call {
	return &CommitsServiceInterface_GetCommitDiff_Call{Call: _e.mock.On("GetCommitDiff",
		append([]interface{}{pid, sha, opt}, options...)...)}
}

func (_c *CommitsServiceInterface_GetCommitDiff_Call) Run(run func(pid interface{}, sha string, opt *gitlab.GetCommitDiffOptions, options ...gitlab.RequestOptionFunc)) *CommitsServiceInterface_GetCommitDiff_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(*gitlab.GetCommitDiffOptions), variadicArgs...)
	})
	return _c
}

func (_c *CommitsServiceInterface_GetCommitDiff_Call) Return(_a0 []*gitlab.Diff, _a1 *gitlab.Response, _a2 error) *CommitsServiceInterface_GetCommitDiff_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *CommitsServiceInterface_GetCommitDiff_Call) RunAndReturn(run func(interface{}, string, *gitlab.GetCommitDiffOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Diff, *gitlab.Response, error)) *CommitsServiceInterface_GetCommitDiff_Call {
	_c.Call.Return(run)
	return _c
}

// GetCommitRefs provides a mock function with given fields: pid, sha, opt, options
func (_m *CommitsServiceInterface) GetCommitRefs(pid interface{}, sha string, opt *gitlab.GetCommitRefsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.CommitRef, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, sha, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCommitRefs")
	}

	var r0 []*gitlab.CommitRef
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.GetCommitRefsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.CommitRef, *gitlab.Response, error)); ok {
		return rf(pid, sha, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.GetCommitRefsOptions, ...gitlab.RequestOptionFunc) []*gitlab.CommitRef); ok {
		r0 = rf(pid, sha, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.CommitRef)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, *gitlab.GetCommitRefsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, sha, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, *gitlab.GetCommitRefsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, sha, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// CommitsServiceInterface_GetCommitRefs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCommitRefs'
type CommitsServiceInterface_GetCommitRefs_Call struct {
	*mock.Call
}

// GetCommitRefs is a helper method to define mock.On call
//   - pid interface{}
//   - sha string
//   - opt *gitlab.GetCommitRefsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *CommitsServiceInterface_Expecter) GetCommitRefs(pid interface{}, sha interface{}, opt interface{}, options ...interface{}) *CommitsServiceInterface_GetCommitRefs_Call {
	return &CommitsServiceInterface_GetCommitRefs_Call{Call: _e.mock.On("GetCommitRefs",
		append([]interface{}{pid, sha, opt}, options...)...)}
}

func (_c *CommitsServiceInterface_GetCommitRefs_Call) Run(run func(pid interface{}, sha string, opt *gitlab.GetCommitRefsOptions, options ...gitlab.RequestOptionFunc)) *CommitsServiceInterface_GetCommitRefs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(*gitlab.GetCommitRefsOptions), variadicArgs...)
	})
	return _c
}

func (_c *CommitsServiceInterface_GetCommitRefs_Call) Return(_a0 []*gitlab.CommitRef, _a1 *gitlab.Response, _a2 error) *CommitsServiceInterface_GetCommitRefs_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *CommitsServiceInterface_GetCommitRefs_Call) RunAndReturn(run func(interface{}, string, *gitlab.GetCommitRefsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.CommitRef, *gitlab.Response, error)) *CommitsServiceInterface_GetCommitRefs_Call {
	_c.Call.Return(run)
	return _c
}

// GetCommitStatuses provides a mock function with given fields: pid, sha, opt, options
func (_m *CommitsServiceInterface) GetCommitStatuses(pid interface{}, sha string, opt *gitlab.GetCommitStatusesOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.CommitStatus, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, sha, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCommitStatuses")
	}

	var r0 []*gitlab.CommitStatus
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.GetCommitStatusesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.CommitStatus, *gitlab.Response, error)); ok {
		return rf(pid, sha, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.GetCommitStatusesOptions, ...gitlab.RequestOptionFunc) []*gitlab.CommitStatus); ok {
		r0 = rf(pid, sha, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.CommitStatus)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, *gitlab.GetCommitStatusesOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, sha, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, *gitlab.GetCommitStatusesOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, sha, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// CommitsServiceInterface_GetCommitStatuses_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCommitStatuses'
type CommitsServiceInterface_GetCommitStatuses_Call struct {
	*mock.Call
}

// GetCommitStatuses is a helper method to define mock.On call
//   - pid interface{}
//   - sha string
//   - opt *gitlab.GetCommitStatusesOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *CommitsServiceInterface_Expecter) GetCommitStatuses(pid interface{}, sha interface{}, opt interface{}, options ...interface{}) *CommitsServiceInterface_GetCommitStatuses_Call {
	return &CommitsServiceInterface_GetCommitStatuses_Call{Call: _e.mock.On("GetCommitStatuses",
		append([]interface{}{pid, sha, opt}, options...)...)}
}

func (_c *CommitsServiceInterface_GetCommitStatuses_Call) Run(run func(pid interface{}, sha string, opt *gitlab.GetCommitStatusesOptions, options ...gitlab.RequestOptionFunc)) *CommitsServiceInterface_GetCommitStatuses_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(*gitlab.GetCommitStatusesOptions), variadicArgs...)
	})
	return _c
}

func (_c *CommitsServiceInterface_GetCommitStatuses_Call) Return(_a0 []*gitlab.CommitStatus, _a1 *gitlab.Response, _a2 error) *CommitsServiceInterface_GetCommitStatuses_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *CommitsServiceInterface_GetCommitStatuses_Call) RunAndReturn(run func(interface{}, string, *gitlab.GetCommitStatusesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.CommitStatus, *gitlab.Response, error)) *CommitsServiceInterface_GetCommitStatuses_Call {
	_c.Call.Return(run)
	return _c
}

// GetGPGSignature provides a mock function with given fields: pid, sha, options
func (_m *CommitsServiceInterface) GetGPGSignature(pid interface{}, sha string, options ...gitlab.RequestOptionFunc) (*gitlab.GPGSignature, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, sha)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetGPGSignature")
	}

	var r0 *gitlab.GPGSignature
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, ...gitlab.RequestOptionFunc) (*gitlab.GPGSignature, *gitlab.Response, error)); ok {
		return rf(pid, sha, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, ...gitlab.RequestOptionFunc) *gitlab.GPGSignature); ok {
		r0 = rf(pid, sha, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.GPGSignature)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, sha, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, sha, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// CommitsServiceInterface_GetGPGSignature_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGPGSignature'
type CommitsServiceInterface_GetGPGSignature_Call struct {
	*mock.Call
}

// GetGPGSignature is a helper method to define mock.On call
//   - pid interface{}
//   - sha string
//   - options ...gitlab.RequestOptionFunc
func (_e *CommitsServiceInterface_Expecter) GetGPGSignature(pid interface{}, sha interface{}, options ...interface{}) *CommitsServiceInterface_GetGPGSignature_Call {
	return &CommitsServiceInterface_GetGPGSignature_Call{Call: _e.mock.On("GetGPGSignature",
		append([]interface{}{pid, sha}, options...)...)}
}

func (_c *CommitsServiceInterface_GetGPGSignature_Call) Run(run func(pid interface{}, sha string, options ...gitlab.RequestOptionFunc)) *CommitsServiceInterface_GetGPGSignature_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *CommitsServiceInterface_GetGPGSignature_Call) Return(_a0 *gitlab.GPGSignature, _a1 *gitlab.Response, _a2 error) *CommitsServiceInterface_GetGPGSignature_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *CommitsServiceInterface_GetGPGSignature_Call) RunAndReturn(run func(interface{}, string, ...gitlab.RequestOptionFunc) (*gitlab.GPGSignature, *gitlab.Response, error)) *CommitsServiceInterface_GetGPGSignature_Call {
	_c.Call.Return(run)
	return _c
}

// ListCommits provides a mock function with given fields: pid, opt, options
func (_m *CommitsServiceInterface) ListCommits(pid interface{}, opt *gitlab.ListCommitsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Commit, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListCommits")
	}

	var r0 []*gitlab.Commit
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListCommitsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Commit, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListCommitsOptions, ...gitlab.RequestOptionFunc) []*gitlab.Commit); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Commit)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListCommitsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListCommitsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// CommitsServiceInterface_ListCommits_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListCommits'
type CommitsServiceInterface_ListCommits_Call struct {
	*mock.Call
}

// ListCommits is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.ListCommitsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *CommitsServiceInterface_Expecter) ListCommits(pid interface{}, opt interface{}, options ...interface{}) *CommitsServiceInterface_ListCommits_Call {
	return &CommitsServiceInterface_ListCommits_Call{Call: _e.mock.On("ListCommits",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *CommitsServiceInterface_ListCommits_Call) Run(run func(pid interface{}, opt *gitlab.ListCommitsOptions, options ...gitlab.RequestOptionFunc)) *CommitsServiceInterface_ListCommits_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListCommitsOptions), variadicArgs...)
	})
	return _c
}

func (_c *CommitsServiceInterface_ListCommits_Call) Return(_a0 []*gitlab.Commit, _a1 *gitlab.Response, _a2 error) *CommitsServiceInterface_ListCommits_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *CommitsServiceInterface_ListCommits_Call) RunAndReturn(run func(interface{}, *gitlab.ListCommitsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Commit, *gitlab.Response, error)) *CommitsServiceInterface_ListCommits_Call {
	_c.Call.Return(run)
	return _c
}

// ListMergeRequestsByCommit provides a mock function with given fields: pid, sha, options
func (_m *CommitsServiceInterface) ListMergeRequestsByCommit(pid interface{}, sha string, options ...gitlab.RequestOptionFunc) ([]*gitlab.BasicMergeRequest, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, sha)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMergeRequestsByCommit")
	}

	var r0 []*gitlab.BasicMergeRequest
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, ...gitlab.RequestOptionFunc) ([]*gitlab.BasicMergeRequest, *gitlab.Response, error)); ok {
		return rf(pid, sha, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, ...gitlab.RequestOptionFunc) []*gitlab.BasicMergeRequest); ok {
		r0 = rf(pid, sha, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.BasicMergeRequest)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, sha, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, sha, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// CommitsServiceInterface_ListMergeRequestsByCommit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMergeRequestsByCommit'
type CommitsServiceInterface_ListMergeRequestsByCommit_Call struct {
	*mock.Call
}

// ListMergeRequestsByCommit is a helper method to define mock.On call
//   - pid interface{}
//   - sha string
//   - options ...gitlab.RequestOptionFunc
func (_e *CommitsServiceInterface_Expecter) ListMergeRequestsByCommit(pid interface{}, sha interface{}, options ...interface{}) *CommitsServiceInterface_ListMergeRequestsByCommit_Call {
	return &CommitsServiceInterface_ListMergeRequestsByCommit_Call{Call: _e.mock.On("ListMergeRequestsByCommit",
		append([]interface{}{pid, sha}, options...)...)}
}

func (_c *CommitsServiceInterface_ListMergeRequestsByCommit_Call) Run(run func(pid interface{}, sha string, options ...gitlab.RequestOptionFunc)) *CommitsServiceInterface_ListMergeRequestsByCommit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *CommitsServiceInterface_ListMergeRequestsByCommit_Call) Return(_a0 []*gitlab.BasicMergeRequest, _a1 *gitlab.Response, _a2 error) *CommitsServiceInterface_ListMergeRequestsByCommit_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *CommitsServiceInterface_ListMergeRequestsByCommit_Call) RunAndReturn(run func(interface{}, string, ...gitlab.RequestOptionFunc) ([]*gitlab.BasicMergeRequest, *gitlab.Response, error)) *CommitsServiceInterface_ListMergeRequestsByCommit_Call {
	_c.Call.Return(run)
	return _c
}

// PostCommitComment provides a mock function with given fields: pid, sha, opt, options
func (_m *CommitsServiceInterface) PostCommitComment(pid interface{}, sha string, opt *gitlab.PostCommitCommentOptions, options ...gitlab.RequestOptionFunc) (*gitlab.CommitComment, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, sha, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for PostCommitComment")
	}

	var r0 *gitlab.CommitComment
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.PostCommitCommentOptions, ...gitlab.RequestOptionFunc) (*gitlab.CommitComment, *gitlab.Response, error)); ok {
		return rf(pid, sha, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.PostCommitCommentOptions, ...gitlab.RequestOptionFunc) *gitlab.CommitComment); ok {
		r0 = rf(pid, sha, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.CommitComment)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, *gitlab.PostCommitCommentOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, sha, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, *gitlab.PostCommitCommentOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, sha, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// CommitsServiceInterface_PostCommitComment_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PostCommitComment'
type CommitsServiceInterface_PostCommitComment_Call struct {
	*mock.Call
}

// PostCommitComment is a helper method to define mock.On call
//   - pid interface{}
//   - sha string
//   - opt *gitlab.PostCommitCommentOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *CommitsServiceInterface_Expecter) PostCommitComment(pid interface{}, sha interface{}, opt interface{}, options ...interface{}) *CommitsServiceInterface_PostCommitComment_Call {
	return &CommitsServiceInterface_PostCommitComment_Call{Call: _e.mock.On("PostCommitComment",
		append([]interface{}{pid, sha, opt}, options...)...)}
}

func (_c *CommitsServiceInterface_PostCommitComment_Call) Run(run func(pid interface{}, sha string, opt *gitlab.PostCommitCommentOptions, options ...gitlab.RequestOptionFunc)) *CommitsServiceInterface_PostCommitComment_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(*gitlab.PostCommitCommentOptions), variadicArgs...)
	})
	return _c
}

func (_c *CommitsServiceInterface_PostCommitComment_Call) Return(_a0 *gitlab.CommitComment, _a1 *gitlab.Response, _a2 error) *CommitsServiceInterface_PostCommitComment_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *CommitsServiceInterface_PostCommitComment_Call) RunAndReturn(run func(interface{}, string, *gitlab.PostCommitCommentOptions, ...gitlab.RequestOptionFunc) (*gitlab.CommitComment, *gitlab.Response, error)) *CommitsServiceInterface_PostCommitComment_Call {
	_c.Call.Return(run)
	return _c
}

// RevertCommit provides a mock function with given fields: pid, sha, opt, options
func (_m *CommitsServiceInterface) RevertCommit(pid interface{}, sha string, opt *gitlab.RevertCommitOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Commit, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, sha, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RevertCommit")
	}

	var r0 *gitlab.Commit
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.RevertCommitOptions, ...gitlab.RequestOptionFunc) (*gitlab.Commit, *gitlab.Response, error)); ok {
		return rf(pid, sha, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.RevertCommitOptions, ...gitlab.RequestOptionFunc) *gitlab.Commit); ok {
		r0 = rf(pid, sha, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Commit)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, *gitlab.RevertCommitOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, sha, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, *gitlab.RevertCommitOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, sha, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// CommitsServiceInterface_RevertCommit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RevertCommit'
type CommitsServiceInterface_RevertCommit_Call struct {
	*mock.Call
}

// RevertCommit is a helper method to define mock.On call
//   - pid interface{}
//   - sha string
//   - opt *gitlab.RevertCommitOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *CommitsServiceInterface_Expecter) RevertCommit(pid interface{}, sha interface{}, opt interface{}, options ...interface{}) *CommitsServiceInterface_RevertCommit_Call {
	return &CommitsServiceInterface_RevertCommit_Call{Call: _e.mock.On("RevertCommit",
		append([]interface{}{pid, sha, opt}, options...)...)}
}

func (_c *CommitsServiceInterface_RevertCommit_Call) Run(run func(pid interface{}, sha string, opt *gitlab.RevertCommitOptions, options ...gitlab.RequestOptionFunc)) *CommitsServiceInterface_RevertCommit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(*gitlab.RevertCommitOptions), variadicArgs...)
	})
	return _c
}

func (_c *CommitsServiceInterface_RevertCommit_Call) Return(_a0 *gitlab.Commit, _a1 *gitlab.Response, _a2 error) *CommitsServiceInterface_RevertCommit_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *CommitsServiceInterface_RevertCommit_Call) RunAndReturn(run func(interface{}, string, *gitlab.RevertCommitOptions, ...gitlab.RequestOptionFunc) (*gitlab.Commit, *gitlab.Response, error)) *CommitsServiceInterface_RevertCommit_Call {
	_c.Call.Return(run)
	return _c
}

// SetCommitStatus provides a mock function with given fields: pid, sha, opt, options
func (_m *CommitsServiceInterface) SetCommitStatus(pid interface{}, sha string, opt *gitlab.SetCommitStatusOptions, options ...gitlab.RequestOptionFunc) (*gitlab.CommitStatus, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, sha, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetCommitStatus")
	}

	var r0 *gitlab.CommitStatus
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SetCommitStatusOptions, ...gitlab.RequestOptionFunc) (*gitlab.CommitStatus, *gitlab.Response, error)); ok {
		return rf(pid, sha, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SetCommitStatusOptions, ...gitlab.RequestOptionFunc) *gitlab.CommitStatus); ok {
		r0 = rf(pid, sha, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.CommitStatus)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, *gitlab.SetCommitStatusOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, sha, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, *gitlab.SetCommitStatusOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, sha, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// CommitsServiceInterface_SetCommitStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetCommitStatus'
type CommitsServiceInterface_SetCommitStatus_Call struct {
	*mock.Call
}

// SetCommitStatus is a helper method to define mock.On call
//   - pid interface{}
//   - sha string
//   - opt *gitlab.SetCommitStatusOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *CommitsServiceInterface_Expecter) SetCommitStatus(pid interface{}, sha interface{}, opt interface{}, options ...interface{}) *CommitsServiceInterface_SetCommitStatus_Call {
	return &CommitsServiceInterface_SetCommitStatus_Call{Call: _e.mock.On("SetCommitStatus",
		append([]interface{}{pid, sha, opt}, options...)...)}
}

func (_c *CommitsServiceInterface_SetCommitStatus_Call) Run(run func(pid interface{}, sha string, opt *gitlab.SetCommitStatusOptions, options ...gitlab.RequestOptionFunc)) *CommitsServiceInterface_SetCommitStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(*gitlab.SetCommitStatusOptions), variadicArgs...)
	})
	return _c
}

func (_c *CommitsServiceInterface_SetCommitStatus_Call) Return(_a0 *gitlab.CommitStatus, _a1 *gitlab.Response, _a2 error) *CommitsServiceInterface_SetCommitStatus_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *CommitsServiceInterface_SetCommitStatus_Call) RunAndReturn(run func(interface{}, string, *gitlab.SetCommitStatusOptions, ...gitlab.RequestOptionFunc) (*gitlab.CommitStatus, *gitlab.Response, error)) *CommitsServiceInterface_SetCommitStatus_Call {
	_c.Call.Return(run)
	return _c
}

// NewCommitsServiceInterface creates a new instance of CommitsServiceInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCommitsServiceInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *CommitsServiceInterface {
	mock := &CommitsServiceInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

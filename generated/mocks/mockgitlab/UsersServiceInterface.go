// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	io "io"

	gitlab "gitlab.com/gitlab-org/api/client-go"

	mock "github.com/stretchr/testify/mock"
)

// UsersServiceInterface is an autogenerated mock type for the UsersServiceInterface type
type UsersServiceInterface struct {
	mock.Mock
}

type UsersServiceInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *UsersServiceInterface) EXPECT() *UsersServiceInterface_Expecter {
	return &UsersServiceInterface_Expecter{mock: &_m.Mock}
}

// ActivateUser provides a mock function with given fields: user, options
func (_m *UsersServiceInterface) ActivateUser(user int, options ...gitlab.RequestOptionFunc) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ActivateUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) error); ok {
		r0 = rf(user, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UsersServiceInterface_ActivateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ActivateUser'
type UsersServiceInterface_ActivateUser_Call struct {
	*mock.Call
}

// ActivateUser is a helper method to define mock.On call
//   - user int
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) ActivateUser(user interface{}, options ...interface{}) *UsersServiceInterface_ActivateUser_Call {
	return &UsersServiceInterface_ActivateUser_Call{Call: _e.mock.On("ActivateUser",
		append([]interface{}{user}, options...)...)}
}

func (_c *UsersServiceInterface_ActivateUser_Call) Run(run func(user int, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_ActivateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_ActivateUser_Call) Return(_a0 error) *UsersServiceInterface_ActivateUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UsersServiceInterface_ActivateUser_Call) RunAndReturn(run func(int, ...gitlab.RequestOptionFunc) error) *UsersServiceInterface_ActivateUser_Call {
	_c.Call.Return(run)
	return _c
}

// AddEmail provides a mock function with given fields: opt, options
func (_m *UsersServiceInterface) AddEmail(opt *gitlab.AddEmailOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Email, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddEmail")
	}

	var r0 *gitlab.Email
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(*gitlab.AddEmailOptions, ...gitlab.RequestOptionFunc) (*gitlab.Email, *gitlab.Response, error)); ok {
		return rf(opt, options...)
	}
	if rf, ok := ret.Get(0).(func(*gitlab.AddEmailOptions, ...gitlab.RequestOptionFunc) *gitlab.Email); ok {
		r0 = rf(opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Email)
		}
	}

	if rf, ok := ret.Get(1).(func(*gitlab.AddEmailOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(*gitlab.AddEmailOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_AddEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddEmail'
type UsersServiceInterface_AddEmail_Call struct {
	*mock.Call
}

// AddEmail is a helper method to define mock.On call
//   - opt *gitlab.AddEmailOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) AddEmail(opt interface{}, options ...interface{}) *UsersServiceInterface_AddEmail_Call {
	return &UsersServiceInterface_AddEmail_Call{Call: _e.mock.On("AddEmail",
		append([]interface{}{opt}, options...)...)}
}

func (_c *UsersServiceInterface_AddEmail_Call) Run(run func(opt *gitlab.AddEmailOptions, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_AddEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(*gitlab.AddEmailOptions), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_AddEmail_Call) Return(_a0 *gitlab.Email, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_AddEmail_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_AddEmail_Call) RunAndReturn(run func(*gitlab.AddEmailOptions, ...gitlab.RequestOptionFunc) (*gitlab.Email, *gitlab.Response, error)) *UsersServiceInterface_AddEmail_Call {
	_c.Call.Return(run)
	return _c
}

// AddEmailForUser provides a mock function with given fields: user, opt, options
func (_m *UsersServiceInterface) AddEmailForUser(user int, opt *gitlab.AddEmailOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Email, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddEmailForUser")
	}

	var r0 *gitlab.Email
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(int, *gitlab.AddEmailOptions, ...gitlab.RequestOptionFunc) (*gitlab.Email, *gitlab.Response, error)); ok {
		return rf(user, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(int, *gitlab.AddEmailOptions, ...gitlab.RequestOptionFunc) *gitlab.Email); ok {
		r0 = rf(user, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Email)
		}
	}

	if rf, ok := ret.Get(1).(func(int, *gitlab.AddEmailOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(user, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(int, *gitlab.AddEmailOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(user, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_AddEmailForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddEmailForUser'
type UsersServiceInterface_AddEmailForUser_Call struct {
	*mock.Call
}

// AddEmailForUser is a helper method to define mock.On call
//   - user int
//   - opt *gitlab.AddEmailOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) AddEmailForUser(user interface{}, opt interface{}, options ...interface{}) *UsersServiceInterface_AddEmailForUser_Call {
	return &UsersServiceInterface_AddEmailForUser_Call{Call: _e.mock.On("AddEmailForUser",
		append([]interface{}{user, opt}, options...)...)}
}

func (_c *UsersServiceInterface_AddEmailForUser_Call) Run(run func(user int, opt *gitlab.AddEmailOptions, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_AddEmailForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), args[1].(*gitlab.AddEmailOptions), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_AddEmailForUser_Call) Return(_a0 *gitlab.Email, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_AddEmailForUser_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_AddEmailForUser_Call) RunAndReturn(run func(int, *gitlab.AddEmailOptions, ...gitlab.RequestOptionFunc) (*gitlab.Email, *gitlab.Response, error)) *UsersServiceInterface_AddEmailForUser_Call {
	_c.Call.Return(run)
	return _c
}

// AddGPGKey provides a mock function with given fields: opt, options
func (_m *UsersServiceInterface) AddGPGKey(opt *gitlab.AddGPGKeyOptions, options ...gitlab.RequestOptionFunc) (*gitlab.GPGKey, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddGPGKey")
	}

	var r0 *gitlab.GPGKey
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(*gitlab.AddGPGKeyOptions, ...gitlab.RequestOptionFunc) (*gitlab.GPGKey, *gitlab.Response, error)); ok {
		return rf(opt, options...)
	}
	if rf, ok := ret.Get(0).(func(*gitlab.AddGPGKeyOptions, ...gitlab.RequestOptionFunc) *gitlab.GPGKey); ok {
		r0 = rf(opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.GPGKey)
		}
	}

	if rf, ok := ret.Get(1).(func(*gitlab.AddGPGKeyOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(*gitlab.AddGPGKeyOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_AddGPGKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddGPGKey'
type UsersServiceInterface_AddGPGKey_Call struct {
	*mock.Call
}

// AddGPGKey is a helper method to define mock.On call
//   - opt *gitlab.AddGPGKeyOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) AddGPGKey(opt interface{}, options ...interface{}) *UsersServiceInterface_AddGPGKey_Call {
	return &UsersServiceInterface_AddGPGKey_Call{Call: _e.mock.On("AddGPGKey",
		append([]interface{}{opt}, options...)...)}
}

func (_c *UsersServiceInterface_AddGPGKey_Call) Run(run func(opt *gitlab.AddGPGKeyOptions, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_AddGPGKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(*gitlab.AddGPGKeyOptions), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_AddGPGKey_Call) Return(_a0 *gitlab.GPGKey, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_AddGPGKey_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_AddGPGKey_Call) RunAndReturn(run func(*gitlab.AddGPGKeyOptions, ...gitlab.RequestOptionFunc) (*gitlab.GPGKey, *gitlab.Response, error)) *UsersServiceInterface_AddGPGKey_Call {
	_c.Call.Return(run)
	return _c
}

// AddGPGKeyForUser provides a mock function with given fields: user, opt, options
func (_m *UsersServiceInterface) AddGPGKeyForUser(user int, opt *gitlab.AddGPGKeyOptions, options ...gitlab.RequestOptionFunc) (*gitlab.GPGKey, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddGPGKeyForUser")
	}

	var r0 *gitlab.GPGKey
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(int, *gitlab.AddGPGKeyOptions, ...gitlab.RequestOptionFunc) (*gitlab.GPGKey, *gitlab.Response, error)); ok {
		return rf(user, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(int, *gitlab.AddGPGKeyOptions, ...gitlab.RequestOptionFunc) *gitlab.GPGKey); ok {
		r0 = rf(user, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.GPGKey)
		}
	}

	if rf, ok := ret.Get(1).(func(int, *gitlab.AddGPGKeyOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(user, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(int, *gitlab.AddGPGKeyOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(user, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_AddGPGKeyForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddGPGKeyForUser'
type UsersServiceInterface_AddGPGKeyForUser_Call struct {
	*mock.Call
}

// AddGPGKeyForUser is a helper method to define mock.On call
//   - user int
//   - opt *gitlab.AddGPGKeyOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) AddGPGKeyForUser(user interface{}, opt interface{}, options ...interface{}) *UsersServiceInterface_AddGPGKeyForUser_Call {
	return &UsersServiceInterface_AddGPGKeyForUser_Call{Call: _e.mock.On("AddGPGKeyForUser",
		append([]interface{}{user, opt}, options...)...)}
}

func (_c *UsersServiceInterface_AddGPGKeyForUser_Call) Run(run func(user int, opt *gitlab.AddGPGKeyOptions, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_AddGPGKeyForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), args[1].(*gitlab.AddGPGKeyOptions), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_AddGPGKeyForUser_Call) Return(_a0 *gitlab.GPGKey, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_AddGPGKeyForUser_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_AddGPGKeyForUser_Call) RunAndReturn(run func(int, *gitlab.AddGPGKeyOptions, ...gitlab.RequestOptionFunc) (*gitlab.GPGKey, *gitlab.Response, error)) *UsersServiceInterface_AddGPGKeyForUser_Call {
	_c.Call.Return(run)
	return _c
}

// AddSSHKey provides a mock function with given fields: opt, options
func (_m *UsersServiceInterface) AddSSHKey(opt *gitlab.AddSSHKeyOptions, options ...gitlab.RequestOptionFunc) (*gitlab.SSHKey, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddSSHKey")
	}

	var r0 *gitlab.SSHKey
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(*gitlab.AddSSHKeyOptions, ...gitlab.RequestOptionFunc) (*gitlab.SSHKey, *gitlab.Response, error)); ok {
		return rf(opt, options...)
	}
	if rf, ok := ret.Get(0).(func(*gitlab.AddSSHKeyOptions, ...gitlab.RequestOptionFunc) *gitlab.SSHKey); ok {
		r0 = rf(opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.SSHKey)
		}
	}

	if rf, ok := ret.Get(1).(func(*gitlab.AddSSHKeyOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(*gitlab.AddSSHKeyOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_AddSSHKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddSSHKey'
type UsersServiceInterface_AddSSHKey_Call struct {
	*mock.Call
}

// AddSSHKey is a helper method to define mock.On call
//   - opt *gitlab.AddSSHKeyOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) AddSSHKey(opt interface{}, options ...interface{}) *UsersServiceInterface_AddSSHKey_Call {
	return &UsersServiceInterface_AddSSHKey_Call{Call: _e.mock.On("AddSSHKey",
		append([]interface{}{opt}, options...)...)}
}

func (_c *UsersServiceInterface_AddSSHKey_Call) Run(run func(opt *gitlab.AddSSHKeyOptions, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_AddSSHKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(*gitlab.AddSSHKeyOptions), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_AddSSHKey_Call) Return(_a0 *gitlab.SSHKey, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_AddSSHKey_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_AddSSHKey_Call) RunAndReturn(run func(*gitlab.AddSSHKeyOptions, ...gitlab.RequestOptionFunc) (*gitlab.SSHKey, *gitlab.Response, error)) *UsersServiceInterface_AddSSHKey_Call {
	_c.Call.Return(run)
	return _c
}

// AddSSHKeyForUser provides a mock function with given fields: user, opt, options
func (_m *UsersServiceInterface) AddSSHKeyForUser(user int, opt *gitlab.AddSSHKeyOptions, options ...gitlab.RequestOptionFunc) (*gitlab.SSHKey, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddSSHKeyForUser")
	}

	var r0 *gitlab.SSHKey
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(int, *gitlab.AddSSHKeyOptions, ...gitlab.RequestOptionFunc) (*gitlab.SSHKey, *gitlab.Response, error)); ok {
		return rf(user, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(int, *gitlab.AddSSHKeyOptions, ...gitlab.RequestOptionFunc) *gitlab.SSHKey); ok {
		r0 = rf(user, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.SSHKey)
		}
	}

	if rf, ok := ret.Get(1).(func(int, *gitlab.AddSSHKeyOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(user, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(int, *gitlab.AddSSHKeyOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(user, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_AddSSHKeyForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddSSHKeyForUser'
type UsersServiceInterface_AddSSHKeyForUser_Call struct {
	*mock.Call
}

// AddSSHKeyForUser is a helper method to define mock.On call
//   - user int
//   - opt *gitlab.AddSSHKeyOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) AddSSHKeyForUser(user interface{}, opt interface{}, options ...interface{}) *UsersServiceInterface_AddSSHKeyForUser_Call {
	return &UsersServiceInterface_AddSSHKeyForUser_Call{Call: _e.mock.On("AddSSHKeyForUser",
		append([]interface{}{user, opt}, options...)...)}
}

func (_c *UsersServiceInterface_AddSSHKeyForUser_Call) Run(run func(user int, opt *gitlab.AddSSHKeyOptions, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_AddSSHKeyForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), args[1].(*gitlab.AddSSHKeyOptions), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_AddSSHKeyForUser_Call) Return(_a0 *gitlab.SSHKey, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_AddSSHKeyForUser_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_AddSSHKeyForUser_Call) RunAndReturn(run func(int, *gitlab.AddSSHKeyOptions, ...gitlab.RequestOptionFunc) (*gitlab.SSHKey, *gitlab.Response, error)) *UsersServiceInterface_AddSSHKeyForUser_Call {
	_c.Call.Return(run)
	return _c
}

// ApproveUser provides a mock function with given fields: user, options
func (_m *UsersServiceInterface) ApproveUser(user int, options ...gitlab.RequestOptionFunc) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ApproveUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) error); ok {
		r0 = rf(user, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UsersServiceInterface_ApproveUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ApproveUser'
type UsersServiceInterface_ApproveUser_Call struct {
	*mock.Call
}

// ApproveUser is a helper method to define mock.On call
//   - user int
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) ApproveUser(user interface{}, options ...interface{}) *UsersServiceInterface_ApproveUser_Call {
	return &UsersServiceInterface_ApproveUser_Call{Call: _e.mock.On("ApproveUser",
		append([]interface{}{user}, options...)...)}
}

func (_c *UsersServiceInterface_ApproveUser_Call) Run(run func(user int, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_ApproveUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_ApproveUser_Call) Return(_a0 error) *UsersServiceInterface_ApproveUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UsersServiceInterface_ApproveUser_Call) RunAndReturn(run func(int, ...gitlab.RequestOptionFunc) error) *UsersServiceInterface_ApproveUser_Call {
	_c.Call.Return(run)
	return _c
}

// BanUser provides a mock function with given fields: user, options
func (_m *UsersServiceInterface) BanUser(user int, options ...gitlab.RequestOptionFunc) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BanUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) error); ok {
		r0 = rf(user, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UsersServiceInterface_BanUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BanUser'
type UsersServiceInterface_BanUser_Call struct {
	*mock.Call
}

// BanUser is a helper method to define mock.On call
//   - user int
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) BanUser(user interface{}, options ...interface{}) *UsersServiceInterface_BanUser_Call {
	return &UsersServiceInterface_BanUser_Call{Call: _e.mock.On("BanUser",
		append([]interface{}{user}, options...)...)}
}

func (_c *UsersServiceInterface_BanUser_Call) Run(run func(user int, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_BanUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_BanUser_Call) Return(_a0 error) *UsersServiceInterface_BanUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UsersServiceInterface_BanUser_Call) RunAndReturn(run func(int, ...gitlab.RequestOptionFunc) error) *UsersServiceInterface_BanUser_Call {
	_c.Call.Return(run)
	return _c
}

// BlockUser provides a mock function with given fields: user, options
func (_m *UsersServiceInterface) BlockUser(user int, options ...gitlab.RequestOptionFunc) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BlockUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) error); ok {
		r0 = rf(user, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UsersServiceInterface_BlockUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlockUser'
type UsersServiceInterface_BlockUser_Call struct {
	*mock.Call
}

// BlockUser is a helper method to define mock.On call
//   - user int
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) BlockUser(user interface{}, options ...interface{}) *UsersServiceInterface_BlockUser_Call {
	return &UsersServiceInterface_BlockUser_Call{Call: _e.mock.On("BlockUser",
		append([]interface{}{user}, options...)...)}
}

func (_c *UsersServiceInterface_BlockUser_Call) Run(run func(user int, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_BlockUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_BlockUser_Call) Return(_a0 error) *UsersServiceInterface_BlockUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UsersServiceInterface_BlockUser_Call) RunAndReturn(run func(int, ...gitlab.RequestOptionFunc) error) *UsersServiceInterface_BlockUser_Call {
	_c.Call.Return(run)
	return _c
}

// CreateImpersonationToken provides a mock function with given fields: user, opt, options
func (_m *UsersServiceInterface) CreateImpersonationToken(user int, opt *gitlab.CreateImpersonationTokenOptions, options ...gitlab.RequestOptionFunc) (*gitlab.ImpersonationToken, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateImpersonationToken")
	}

	var r0 *gitlab.ImpersonationToken
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(int, *gitlab.CreateImpersonationTokenOptions, ...gitlab.RequestOptionFunc) (*gitlab.ImpersonationToken, *gitlab.Response, error)); ok {
		return rf(user, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(int, *gitlab.CreateImpersonationTokenOptions, ...gitlab.RequestOptionFunc) *gitlab.ImpersonationToken); ok {
		r0 = rf(user, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.ImpersonationToken)
		}
	}

	if rf, ok := ret.Get(1).(func(int, *gitlab.CreateImpersonationTokenOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(user, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(int, *gitlab.CreateImpersonationTokenOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(user, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_CreateImpersonationToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateImpersonationToken'
type UsersServiceInterface_CreateImpersonationToken_Call struct {
	*mock.Call
}

// CreateImpersonationToken is a helper method to define mock.On call
//   - user int
//   - opt *gitlab.CreateImpersonationTokenOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) CreateImpersonationToken(user interface{}, opt interface{}, options ...interface{}) *UsersServiceInterface_CreateImpersonationToken_Call {
	return &UsersServiceInterface_CreateImpersonationToken_Call{Call: _e.mock.On("CreateImpersonationToken",
		append([]interface{}{user, opt}, options...)...)}
}

func (_c *UsersServiceInterface_CreateImpersonationToken_Call) Run(run func(user int, opt *gitlab.CreateImpersonationTokenOptions, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_CreateImpersonationToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), args[1].(*gitlab.CreateImpersonationTokenOptions), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_CreateImpersonationToken_Call) Return(_a0 *gitlab.ImpersonationToken, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_CreateImpersonationToken_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_CreateImpersonationToken_Call) RunAndReturn(run func(int, *gitlab.CreateImpersonationTokenOptions, ...gitlab.RequestOptionFunc) (*gitlab.ImpersonationToken, *gitlab.Response, error)) *UsersServiceInterface_CreateImpersonationToken_Call {
	_c.Call.Return(run)
	return _c
}

// CreatePersonalAccessToken provides a mock function with given fields: user, opt, options
func (_m *UsersServiceInterface) CreatePersonalAccessToken(user int, opt *gitlab.CreatePersonalAccessTokenOptions, options ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePersonalAccessToken")
	}

	var r0 *gitlab.PersonalAccessToken
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(int, *gitlab.CreatePersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error)); ok {
		return rf(user, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(int, *gitlab.CreatePersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) *gitlab.PersonalAccessToken); ok {
		r0 = rf(user, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.PersonalAccessToken)
		}
	}

	if rf, ok := ret.Get(1).(func(int, *gitlab.CreatePersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(user, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(int, *gitlab.CreatePersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(user, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_CreatePersonalAccessToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePersonalAccessToken'
type UsersServiceInterface_CreatePersonalAccessToken_Call struct {
	*mock.Call
}

// CreatePersonalAccessToken is a helper method to define mock.On call
//   - user int
//   - opt *gitlab.CreatePersonalAccessTokenOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) CreatePersonalAccessToken(user interface{}, opt interface{}, options ...interface{}) *UsersServiceInterface_CreatePersonalAccessToken_Call {
	return &UsersServiceInterface_CreatePersonalAccessToken_Call{Call: _e.mock.On("CreatePersonalAccessToken",
		append([]interface{}{user, opt}, options...)...)}
}

func (_c *UsersServiceInterface_CreatePersonalAccessToken_Call) Run(run func(user int, opt *gitlab.CreatePersonalAccessTokenOptions, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_CreatePersonalAccessToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), args[1].(*gitlab.CreatePersonalAccessTokenOptions), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_CreatePersonalAccessToken_Call) Return(_a0 *gitlab.PersonalAccessToken, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_CreatePersonalAccessToken_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_CreatePersonalAccessToken_Call) RunAndReturn(run func(int, *gitlab.CreatePersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error)) *UsersServiceInterface_CreatePersonalAccessToken_Call {
	_c.Call.Return(run)
	return _c
}

// CreatePersonalAccessTokenForCurrentUser provides a mock function with given fields: opt, options
func (_m *UsersServiceInterface) CreatePersonalAccessTokenForCurrentUser(opt *gitlab.CreatePersonalAccessTokenForCurrentUserOptions, options ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreatePersonalAccessTokenForCurrentUser")
	}

	var r0 *gitlab.PersonalAccessToken
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(*gitlab.CreatePersonalAccessTokenForCurrentUserOptions, ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error)); ok {
		return rf(opt, options...)
	}
	if rf, ok := ret.Get(0).(func(*gitlab.CreatePersonalAccessTokenForCurrentUserOptions, ...gitlab.RequestOptionFunc) *gitlab.PersonalAccessToken); ok {
		r0 = rf(opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.PersonalAccessToken)
		}
	}

	if rf, ok := ret.Get(1).(func(*gitlab.CreatePersonalAccessTokenForCurrentUserOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(*gitlab.CreatePersonalAccessTokenForCurrentUserOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_CreatePersonalAccessTokenForCurrentUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreatePersonalAccessTokenForCurrentUser'
type UsersServiceInterface_CreatePersonalAccessTokenForCurrentUser_Call struct {
	*mock.Call
}

// CreatePersonalAccessTokenForCurrentUser is a helper method to define mock.On call
//   - opt *gitlab.CreatePersonalAccessTokenForCurrentUserOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) CreatePersonalAccessTokenForCurrentUser(opt interface{}, options ...interface{}) *UsersServiceInterface_CreatePersonalAccessTokenForCurrentUser_Call {
	return &UsersServiceInterface_CreatePersonalAccessTokenForCurrentUser_Call{Call: _e.mock.On("CreatePersonalAccessTokenForCurrentUser",
		append([]interface{}{opt}, options...)...)}
}

func (_c *UsersServiceInterface_CreatePersonalAccessTokenForCurrentUser_Call) Run(run func(opt *gitlab.CreatePersonalAccessTokenForCurrentUserOptions, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_CreatePersonalAccessTokenForCurrentUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(*gitlab.CreatePersonalAccessTokenForCurrentUserOptions), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_CreatePersonalAccessTokenForCurrentUser_Call) Return(_a0 *gitlab.PersonalAccessToken, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_CreatePersonalAccessTokenForCurrentUser_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_CreatePersonalAccessTokenForCurrentUser_Call) RunAndReturn(run func(*gitlab.CreatePersonalAccessTokenForCurrentUserOptions, ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error)) *UsersServiceInterface_CreatePersonalAccessTokenForCurrentUser_Call {
	_c.Call.Return(run)
	return _c
}

// CreateServiceAccountUser provides a mock function with given fields: opts, options
func (_m *UsersServiceInterface) CreateServiceAccountUser(opts *gitlab.CreateServiceAccountUserOptions, options ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, opts)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateServiceAccountUser")
	}

	var r0 *gitlab.User
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(*gitlab.CreateServiceAccountUserOptions, ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error)); ok {
		return rf(opts, options...)
	}
	if rf, ok := ret.Get(0).(func(*gitlab.CreateServiceAccountUserOptions, ...gitlab.RequestOptionFunc) *gitlab.User); ok {
		r0 = rf(opts, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.User)
		}
	}

	if rf, ok := ret.Get(1).(func(*gitlab.CreateServiceAccountUserOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(opts, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(*gitlab.CreateServiceAccountUserOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(opts, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_CreateServiceAccountUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateServiceAccountUser'
type UsersServiceInterface_CreateServiceAccountUser_Call struct {
	*mock.Call
}

// CreateServiceAccountUser is a helper method to define mock.On call
//   - opts *gitlab.CreateServiceAccountUserOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) CreateServiceAccountUser(opts interface{}, options ...interface{}) *UsersServiceInterface_CreateServiceAccountUser_Call {
	return &UsersServiceInterface_CreateServiceAccountUser_Call{Call: _e.mock.On("CreateServiceAccountUser",
		append([]interface{}{opts}, options...)...)}
}

func (_c *UsersServiceInterface_CreateServiceAccountUser_Call) Run(run func(opts *gitlab.CreateServiceAccountUserOptions, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_CreateServiceAccountUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(*gitlab.CreateServiceAccountUserOptions), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_CreateServiceAccountUser_Call) Return(_a0 *gitlab.User, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_CreateServiceAccountUser_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_CreateServiceAccountUser_Call) RunAndReturn(run func(*gitlab.CreateServiceAccountUserOptions, ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error)) *UsersServiceInterface_CreateServiceAccountUser_Call {
	_c.Call.Return(run)
	return _c
}

// CreateUser provides a mock function with given fields: opt, options
func (_m *UsersServiceInterface) CreateUser(opt *gitlab.CreateUserOptions, options ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateUser")
	}

	var r0 *gitlab.User
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(*gitlab.CreateUserOptions, ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error)); ok {
		return rf(opt, options...)
	}
	if rf, ok := ret.Get(0).(func(*gitlab.CreateUserOptions, ...gitlab.RequestOptionFunc) *gitlab.User); ok {
		r0 = rf(opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.User)
		}
	}

	if rf, ok := ret.Get(1).(func(*gitlab.CreateUserOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(*gitlab.CreateUserOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_CreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUser'
type UsersServiceInterface_CreateUser_Call struct {
	*mock.Call
}

// CreateUser is a helper method to define mock.On call
//   - opt *gitlab.CreateUserOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) CreateUser(opt interface{}, options ...interface{}) *UsersServiceInterface_CreateUser_Call {
	return &UsersServiceInterface_CreateUser_Call{Call: _e.mock.On("CreateUser",
		append([]interface{}{opt}, options...)...)}
}

func (_c *UsersServiceInterface_CreateUser_Call) Run(run func(opt *gitlab.CreateUserOptions, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_CreateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(*gitlab.CreateUserOptions), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_CreateUser_Call) Return(_a0 *gitlab.User, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_CreateUser_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_CreateUser_Call) RunAndReturn(run func(*gitlab.CreateUserOptions, ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error)) *UsersServiceInterface_CreateUser_Call {
	_c.Call.Return(run)
	return _c
}

// CreateUserRunner provides a mock function with given fields: opts, options
func (_m *UsersServiceInterface) CreateUserRunner(opts *gitlab.CreateUserRunnerOptions, options ...gitlab.RequestOptionFunc) (*gitlab.UserRunner, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, opts)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateUserRunner")
	}

	var r0 *gitlab.UserRunner
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(*gitlab.CreateUserRunnerOptions, ...gitlab.RequestOptionFunc) (*gitlab.UserRunner, *gitlab.Response, error)); ok {
		return rf(opts, options...)
	}
	if rf, ok := ret.Get(0).(func(*gitlab.CreateUserRunnerOptions, ...gitlab.RequestOptionFunc) *gitlab.UserRunner); ok {
		r0 = rf(opts, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.UserRunner)
		}
	}

	if rf, ok := ret.Get(1).(func(*gitlab.CreateUserRunnerOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(opts, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(*gitlab.CreateUserRunnerOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(opts, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_CreateUserRunner_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUserRunner'
type UsersServiceInterface_CreateUserRunner_Call struct {
	*mock.Call
}

// CreateUserRunner is a helper method to define mock.On call
//   - opts *gitlab.CreateUserRunnerOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) CreateUserRunner(opts interface{}, options ...interface{}) *UsersServiceInterface_CreateUserRunner_Call {
	return &UsersServiceInterface_CreateUserRunner_Call{Call: _e.mock.On("CreateUserRunner",
		append([]interface{}{opts}, options...)...)}
}

func (_c *UsersServiceInterface_CreateUserRunner_Call) Run(run func(opts *gitlab.CreateUserRunnerOptions, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_CreateUserRunner_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(*gitlab.CreateUserRunnerOptions), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_CreateUserRunner_Call) Return(_a0 *gitlab.UserRunner, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_CreateUserRunner_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_CreateUserRunner_Call) RunAndReturn(run func(*gitlab.CreateUserRunnerOptions, ...gitlab.RequestOptionFunc) (*gitlab.UserRunner, *gitlab.Response, error)) *UsersServiceInterface_CreateUserRunner_Call {
	_c.Call.Return(run)
	return _c
}

// CurrentUser provides a mock function with given fields: options
func (_m *UsersServiceInterface) CurrentUser(options ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CurrentUser")
	}

	var r0 *gitlab.User
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...gitlab.RequestOptionFunc) *gitlab.User); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.User)
		}
	}

	if rf, ok := ret.Get(1).(func(...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_CurrentUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CurrentUser'
type UsersServiceInterface_CurrentUser_Call struct {
	*mock.Call
}

// CurrentUser is a helper method to define mock.On call
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) CurrentUser(options ...interface{}) *UsersServiceInterface_CurrentUser_Call {
	return &UsersServiceInterface_CurrentUser_Call{Call: _e.mock.On("CurrentUser",
		append([]interface{}{}, options...)...)}
}

func (_c *UsersServiceInterface_CurrentUser_Call) Run(run func(options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_CurrentUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_CurrentUser_Call) Return(_a0 *gitlab.User, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_CurrentUser_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_CurrentUser_Call) RunAndReturn(run func(...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error)) *UsersServiceInterface_CurrentUser_Call {
	_c.Call.Return(run)
	return _c
}

// CurrentUserStatus provides a mock function with given fields: options
func (_m *UsersServiceInterface) CurrentUserStatus(options ...gitlab.RequestOptionFunc) (*gitlab.UserStatus, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CurrentUserStatus")
	}

	var r0 *gitlab.UserStatus
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(...gitlab.RequestOptionFunc) (*gitlab.UserStatus, *gitlab.Response, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...gitlab.RequestOptionFunc) *gitlab.UserStatus); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.UserStatus)
		}
	}

	if rf, ok := ret.Get(1).(func(...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_CurrentUserStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CurrentUserStatus'
type UsersServiceInterface_CurrentUserStatus_Call struct {
	*mock.Call
}

// CurrentUserStatus is a helper method to define mock.On call
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) CurrentUserStatus(options ...interface{}) *UsersServiceInterface_CurrentUserStatus_Call {
	return &UsersServiceInterface_CurrentUserStatus_Call{Call: _e.mock.On("CurrentUserStatus",
		append([]interface{}{}, options...)...)}
}

func (_c *UsersServiceInterface_CurrentUserStatus_Call) Run(run func(options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_CurrentUserStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_CurrentUserStatus_Call) Return(_a0 *gitlab.UserStatus, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_CurrentUserStatus_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_CurrentUserStatus_Call) RunAndReturn(run func(...gitlab.RequestOptionFunc) (*gitlab.UserStatus, *gitlab.Response, error)) *UsersServiceInterface_CurrentUserStatus_Call {
	_c.Call.Return(run)
	return _c
}

// DeactivateUser provides a mock function with given fields: user, options
func (_m *UsersServiceInterface) DeactivateUser(user int, options ...gitlab.RequestOptionFunc) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeactivateUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) error); ok {
		r0 = rf(user, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UsersServiceInterface_DeactivateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeactivateUser'
type UsersServiceInterface_DeactivateUser_Call struct {
	*mock.Call
}

// DeactivateUser is a helper method to define mock.On call
//   - user int
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) DeactivateUser(user interface{}, options ...interface{}) *UsersServiceInterface_DeactivateUser_Call {
	return &UsersServiceInterface_DeactivateUser_Call{Call: _e.mock.On("DeactivateUser",
		append([]interface{}{user}, options...)...)}
}

func (_c *UsersServiceInterface_DeactivateUser_Call) Run(run func(user int, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_DeactivateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_DeactivateUser_Call) Return(_a0 error) *UsersServiceInterface_DeactivateUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UsersServiceInterface_DeactivateUser_Call) RunAndReturn(run func(int, ...gitlab.RequestOptionFunc) error) *UsersServiceInterface_DeactivateUser_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteEmail provides a mock function with given fields: email, options
func (_m *UsersServiceInterface) DeleteEmail(email int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, email)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEmail")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(email, options...)
	}
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(email, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(email, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UsersServiceInterface_DeleteEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteEmail'
type UsersServiceInterface_DeleteEmail_Call struct {
	*mock.Call
}

// DeleteEmail is a helper method to define mock.On call
//   - email int
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) DeleteEmail(email interface{}, options ...interface{}) *UsersServiceInterface_DeleteEmail_Call {
	return &UsersServiceInterface_DeleteEmail_Call{Call: _e.mock.On("DeleteEmail",
		append([]interface{}{email}, options...)...)}
}

func (_c *UsersServiceInterface_DeleteEmail_Call) Run(run func(email int, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_DeleteEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_DeleteEmail_Call) Return(_a0 *gitlab.Response, _a1 error) *UsersServiceInterface_DeleteEmail_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UsersServiceInterface_DeleteEmail_Call) RunAndReturn(run func(int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *UsersServiceInterface_DeleteEmail_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteEmailForUser provides a mock function with given fields: user, email, options
func (_m *UsersServiceInterface) DeleteEmailForUser(user int, email int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user, email)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEmailForUser")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(user, email, options...)
	}
	if rf, ok := ret.Get(0).(func(int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(user, email, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(int, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(user, email, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UsersServiceInterface_DeleteEmailForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteEmailForUser'
type UsersServiceInterface_DeleteEmailForUser_Call struct {
	*mock.Call
}

// DeleteEmailForUser is a helper method to define mock.On call
//   - user int
//   - email int
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) DeleteEmailForUser(user interface{}, email interface{}, options ...interface{}) *UsersServiceInterface_DeleteEmailForUser_Call {
	return &UsersServiceInterface_DeleteEmailForUser_Call{Call: _e.mock.On("DeleteEmailForUser",
		append([]interface{}{user, email}, options...)...)}
}

func (_c *UsersServiceInterface_DeleteEmailForUser_Call) Run(run func(user int, email int, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_DeleteEmailForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_DeleteEmailForUser_Call) Return(_a0 *gitlab.Response, _a1 error) *UsersServiceInterface_DeleteEmailForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UsersServiceInterface_DeleteEmailForUser_Call) RunAndReturn(run func(int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *UsersServiceInterface_DeleteEmailForUser_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteGPGKey provides a mock function with given fields: key, options
func (_m *UsersServiceInterface) DeleteGPGKey(key int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGPGKey")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(key, options...)
	}
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(key, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(key, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UsersServiceInterface_DeleteGPGKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteGPGKey'
type UsersServiceInterface_DeleteGPGKey_Call struct {
	*mock.Call
}

// DeleteGPGKey is a helper method to define mock.On call
//   - key int
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) DeleteGPGKey(key interface{}, options ...interface{}) *UsersServiceInterface_DeleteGPGKey_Call {
	return &UsersServiceInterface_DeleteGPGKey_Call{Call: _e.mock.On("DeleteGPGKey",
		append([]interface{}{key}, options...)...)}
}

func (_c *UsersServiceInterface_DeleteGPGKey_Call) Run(run func(key int, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_DeleteGPGKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_DeleteGPGKey_Call) Return(_a0 *gitlab.Response, _a1 error) *UsersServiceInterface_DeleteGPGKey_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UsersServiceInterface_DeleteGPGKey_Call) RunAndReturn(run func(int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *UsersServiceInterface_DeleteGPGKey_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteGPGKeyForUser provides a mock function with given fields: user, key, options
func (_m *UsersServiceInterface) DeleteGPGKeyForUser(user int, key int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteGPGKeyForUser")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(user, key, options...)
	}
	if rf, ok := ret.Get(0).(func(int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(user, key, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(int, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(user, key, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UsersServiceInterface_DeleteGPGKeyForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteGPGKeyForUser'
type UsersServiceInterface_DeleteGPGKeyForUser_Call struct {
	*mock.Call
}

// DeleteGPGKeyForUser is a helper method to define mock.On call
//   - user int
//   - key int
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) DeleteGPGKeyForUser(user interface{}, key interface{}, options ...interface{}) *UsersServiceInterface_DeleteGPGKeyForUser_Call {
	return &UsersServiceInterface_DeleteGPGKeyForUser_Call{Call: _e.mock.On("DeleteGPGKeyForUser",
		append([]interface{}{user, key}, options...)...)}
}

func (_c *UsersServiceInterface_DeleteGPGKeyForUser_Call) Run(run func(user int, key int, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_DeleteGPGKeyForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_DeleteGPGKeyForUser_Call) Return(_a0 *gitlab.Response, _a1 error) *UsersServiceInterface_DeleteGPGKeyForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UsersServiceInterface_DeleteGPGKeyForUser_Call) RunAndReturn(run func(int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *UsersServiceInterface_DeleteGPGKeyForUser_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSSHKey provides a mock function with given fields: key, options
func (_m *UsersServiceInterface) DeleteSSHKey(key int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSSHKey")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(key, options...)
	}
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(key, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(key, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UsersServiceInterface_DeleteSSHKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSSHKey'
type UsersServiceInterface_DeleteSSHKey_Call struct {
	*mock.Call
}

// DeleteSSHKey is a helper method to define mock.On call
//   - key int
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) DeleteSSHKey(key interface{}, options ...interface{}) *UsersServiceInterface_DeleteSSHKey_Call {
	return &UsersServiceInterface_DeleteSSHKey_Call{Call: _e.mock.On("DeleteSSHKey",
		append([]interface{}{key}, options...)...)}
}

func (_c *UsersServiceInterface_DeleteSSHKey_Call) Run(run func(key int, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_DeleteSSHKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_DeleteSSHKey_Call) Return(_a0 *gitlab.Response, _a1 error) *UsersServiceInterface_DeleteSSHKey_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UsersServiceInterface_DeleteSSHKey_Call) RunAndReturn(run func(int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *UsersServiceInterface_DeleteSSHKey_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSSHKeyForUser provides a mock function with given fields: user, key, options
func (_m *UsersServiceInterface) DeleteSSHKeyForUser(user int, key int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSSHKeyForUser")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(user, key, options...)
	}
	if rf, ok := ret.Get(0).(func(int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(user, key, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(int, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(user, key, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UsersServiceInterface_DeleteSSHKeyForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSSHKeyForUser'
type UsersServiceInterface_DeleteSSHKeyForUser_Call struct {
	*mock.Call
}

// DeleteSSHKeyForUser is a helper method to define mock.On call
//   - user int
//   - key int
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) DeleteSSHKeyForUser(user interface{}, key interface{}, options ...interface{}) *UsersServiceInterface_DeleteSSHKeyForUser_Call {
	return &UsersServiceInterface_DeleteSSHKeyForUser_Call{Call: _e.mock.On("DeleteSSHKeyForUser",
		append([]interface{}{user, key}, options...)...)}
}

func (_c *UsersServiceInterface_DeleteSSHKeyForUser_Call) Run(run func(user int, key int, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_DeleteSSHKeyForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_DeleteSSHKeyForUser_Call) Return(_a0 *gitlab.Response, _a1 error) *UsersServiceInterface_DeleteSSHKeyForUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UsersServiceInterface_DeleteSSHKeyForUser_Call) RunAndReturn(run func(int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *UsersServiceInterface_DeleteSSHKeyForUser_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteUser provides a mock function with given fields: user, options
func (_m *UsersServiceInterface) DeleteUser(user int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUser")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(user, options...)
	}
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(user, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(user, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UsersServiceInterface_DeleteUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteUser'
type UsersServiceInterface_DeleteUser_Call struct {
	*mock.Call
}

// DeleteUser is a helper method to define mock.On call
//   - user int
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) DeleteUser(user interface{}, options ...interface{}) *UsersServiceInterface_DeleteUser_Call {
	return &UsersServiceInterface_DeleteUser_Call{Call: _e.mock.On("DeleteUser",
		append([]interface{}{user}, options...)...)}
}

func (_c *UsersServiceInterface_DeleteUser_Call) Run(run func(user int, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_DeleteUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_DeleteUser_Call) Return(_a0 *gitlab.Response, _a1 error) *UsersServiceInterface_DeleteUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UsersServiceInterface_DeleteUser_Call) RunAndReturn(run func(int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *UsersServiceInterface_DeleteUser_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteUserIdentity provides a mock function with given fields: user, provider, options
func (_m *UsersServiceInterface) DeleteUserIdentity(user int, provider string, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user, provider)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUserIdentity")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(int, string, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(user, provider, options...)
	}
	if rf, ok := ret.Get(0).(func(int, string, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(user, provider, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(int, string, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(user, provider, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UsersServiceInterface_DeleteUserIdentity_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteUserIdentity'
type UsersServiceInterface_DeleteUserIdentity_Call struct {
	*mock.Call
}

// DeleteUserIdentity is a helper method to define mock.On call
//   - user int
//   - provider string
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) DeleteUserIdentity(user interface{}, provider interface{}, options ...interface{}) *UsersServiceInterface_DeleteUserIdentity_Call {
	return &UsersServiceInterface_DeleteUserIdentity_Call{Call: _e.mock.On("DeleteUserIdentity",
		append([]interface{}{user, provider}, options...)...)}
}

func (_c *UsersServiceInterface_DeleteUserIdentity_Call) Run(run func(user int, provider string, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_DeleteUserIdentity_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_DeleteUserIdentity_Call) Return(_a0 *gitlab.Response, _a1 error) *UsersServiceInterface_DeleteUserIdentity_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UsersServiceInterface_DeleteUserIdentity_Call) RunAndReturn(run func(int, string, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *UsersServiceInterface_DeleteUserIdentity_Call {
	_c.Call.Return(run)
	return _c
}

// DisableTwoFactor provides a mock function with given fields: user, options
func (_m *UsersServiceInterface) DisableTwoFactor(user int, options ...gitlab.RequestOptionFunc) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableTwoFactor")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) error); ok {
		r0 = rf(user, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UsersServiceInterface_DisableTwoFactor_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisableTwoFactor'
type UsersServiceInterface_DisableTwoFactor_Call struct {
	*mock.Call
}

// DisableTwoFactor is a helper method to define mock.On call
//   - user int
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) DisableTwoFactor(user interface{}, options ...interface{}) *UsersServiceInterface_DisableTwoFactor_Call {
	return &UsersServiceInterface_DisableTwoFactor_Call{Call: _e.mock.On("DisableTwoFactor",
		append([]interface{}{user}, options...)...)}
}

func (_c *UsersServiceInterface_DisableTwoFactor_Call) Run(run func(user int, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_DisableTwoFactor_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_DisableTwoFactor_Call) Return(_a0 error) *UsersServiceInterface_DisableTwoFactor_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UsersServiceInterface_DisableTwoFactor_Call) RunAndReturn(run func(int, ...gitlab.RequestOptionFunc) error) *UsersServiceInterface_DisableTwoFactor_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllImpersonationTokens provides a mock function with given fields: user, opt, options
func (_m *UsersServiceInterface) GetAllImpersonationTokens(user int, opt *gitlab.GetAllImpersonationTokensOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.ImpersonationToken, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAllImpersonationTokens")
	}

	var r0 []*gitlab.ImpersonationToken
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(int, *gitlab.GetAllImpersonationTokensOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ImpersonationToken, *gitlab.Response, error)); ok {
		return rf(user, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(int, *gitlab.GetAllImpersonationTokensOptions, ...gitlab.RequestOptionFunc) []*gitlab.ImpersonationToken); ok {
		r0 = rf(user, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.ImpersonationToken)
		}
	}

	if rf, ok := ret.Get(1).(func(int, *gitlab.GetAllImpersonationTokensOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(user, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(int, *gitlab.GetAllImpersonationTokensOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(user, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_GetAllImpersonationTokens_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllImpersonationTokens'
type UsersServiceInterface_GetAllImpersonationTokens_Call struct {
	*mock.Call
}

// GetAllImpersonationTokens is a helper method to define mock.On call
//   - user int
//   - opt *gitlab.GetAllImpersonationTokensOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) GetAllImpersonationTokens(user interface{}, opt interface{}, options ...interface{}) *UsersServiceInterface_GetAllImpersonationTokens_Call {
	return &UsersServiceInterface_GetAllImpersonationTokens_Call{Call: _e.mock.On("GetAllImpersonationTokens",
		append([]interface{}{user, opt}, options...)...)}
}

func (_c *UsersServiceInterface_GetAllImpersonationTokens_Call) Run(run func(user int, opt *gitlab.GetAllImpersonationTokensOptions, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_GetAllImpersonationTokens_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), args[1].(*gitlab.GetAllImpersonationTokensOptions), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_GetAllImpersonationTokens_Call) Return(_a0 []*gitlab.ImpersonationToken, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_GetAllImpersonationTokens_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_GetAllImpersonationTokens_Call) RunAndReturn(run func(int, *gitlab.GetAllImpersonationTokensOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ImpersonationToken, *gitlab.Response, error)) *UsersServiceInterface_GetAllImpersonationTokens_Call {
	_c.Call.Return(run)
	return _c
}

// GetEmail provides a mock function with given fields: email, options
func (_m *UsersServiceInterface) GetEmail(email int, options ...gitlab.RequestOptionFunc) (*gitlab.Email, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, email)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEmail")
	}

	var r0 *gitlab.Email
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) (*gitlab.Email, *gitlab.Response, error)); ok {
		return rf(email, options...)
	}
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) *gitlab.Email); ok {
		r0 = rf(email, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Email)
		}
	}

	if rf, ok := ret.Get(1).(func(int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(email, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(email, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_GetEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEmail'
type UsersServiceInterface_GetEmail_Call struct {
	*mock.Call
}

// GetEmail is a helper method to define mock.On call
//   - email int
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) GetEmail(email interface{}, options ...interface{}) *UsersServiceInterface_GetEmail_Call {
	return &UsersServiceInterface_GetEmail_Call{Call: _e.mock.On("GetEmail",
		append([]interface{}{email}, options...)...)}
}

func (_c *UsersServiceInterface_GetEmail_Call) Run(run func(email int, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_GetEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_GetEmail_Call) Return(_a0 *gitlab.Email, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_GetEmail_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_GetEmail_Call) RunAndReturn(run func(int, ...gitlab.RequestOptionFunc) (*gitlab.Email, *gitlab.Response, error)) *UsersServiceInterface_GetEmail_Call {
	_c.Call.Return(run)
	return _c
}

// GetGPGKey provides a mock function with given fields: key, options
func (_m *UsersServiceInterface) GetGPGKey(key int, options ...gitlab.RequestOptionFunc) (*gitlab.GPGKey, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetGPGKey")
	}

	var r0 *gitlab.GPGKey
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) (*gitlab.GPGKey, *gitlab.Response, error)); ok {
		return rf(key, options...)
	}
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) *gitlab.GPGKey); ok {
		r0 = rf(key, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.GPGKey)
		}
	}

	if rf, ok := ret.Get(1).(func(int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(key, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(key, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_GetGPGKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGPGKey'
type UsersServiceInterface_GetGPGKey_Call struct {
	*mock.Call
}

// GetGPGKey is a helper method to define mock.On call
//   - key int
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) GetGPGKey(key interface{}, options ...interface{}) *UsersServiceInterface_GetGPGKey_Call {
	return &UsersServiceInterface_GetGPGKey_Call{Call: _e.mock.On("GetGPGKey",
		append([]interface{}{key}, options...)...)}
}

func (_c *UsersServiceInterface_GetGPGKey_Call) Run(run func(key int, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_GetGPGKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_GetGPGKey_Call) Return(_a0 *gitlab.GPGKey, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_GetGPGKey_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_GetGPGKey_Call) RunAndReturn(run func(int, ...gitlab.RequestOptionFunc) (*gitlab.GPGKey, *gitlab.Response, error)) *UsersServiceInterface_GetGPGKey_Call {
	_c.Call.Return(run)
	return _c
}

// GetGPGKeyForUser provides a mock function with given fields: user, key, options
func (_m *UsersServiceInterface) GetGPGKeyForUser(user int, key int, options ...gitlab.RequestOptionFunc) (*gitlab.GPGKey, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetGPGKeyForUser")
	}

	var r0 *gitlab.GPGKey
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(int, int, ...gitlab.RequestOptionFunc) (*gitlab.GPGKey, *gitlab.Response, error)); ok {
		return rf(user, key, options...)
	}
	if rf, ok := ret.Get(0).(func(int, int, ...gitlab.RequestOptionFunc) *gitlab.GPGKey); ok {
		r0 = rf(user, key, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.GPGKey)
		}
	}

	if rf, ok := ret.Get(1).(func(int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(user, key, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(int, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(user, key, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_GetGPGKeyForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetGPGKeyForUser'
type UsersServiceInterface_GetGPGKeyForUser_Call struct {
	*mock.Call
}

// GetGPGKeyForUser is a helper method to define mock.On call
//   - user int
//   - key int
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) GetGPGKeyForUser(user interface{}, key interface{}, options ...interface{}) *UsersServiceInterface_GetGPGKeyForUser_Call {
	return &UsersServiceInterface_GetGPGKeyForUser_Call{Call: _e.mock.On("GetGPGKeyForUser",
		append([]interface{}{user, key}, options...)...)}
}

func (_c *UsersServiceInterface_GetGPGKeyForUser_Call) Run(run func(user int, key int, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_GetGPGKeyForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_GetGPGKeyForUser_Call) Return(_a0 *gitlab.GPGKey, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_GetGPGKeyForUser_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_GetGPGKeyForUser_Call) RunAndReturn(run func(int, int, ...gitlab.RequestOptionFunc) (*gitlab.GPGKey, *gitlab.Response, error)) *UsersServiceInterface_GetGPGKeyForUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetImpersonationToken provides a mock function with given fields: user, token, options
func (_m *UsersServiceInterface) GetImpersonationToken(user int, token int, options ...gitlab.RequestOptionFunc) (*gitlab.ImpersonationToken, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user, token)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetImpersonationToken")
	}

	var r0 *gitlab.ImpersonationToken
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(int, int, ...gitlab.RequestOptionFunc) (*gitlab.ImpersonationToken, *gitlab.Response, error)); ok {
		return rf(user, token, options...)
	}
	if rf, ok := ret.Get(0).(func(int, int, ...gitlab.RequestOptionFunc) *gitlab.ImpersonationToken); ok {
		r0 = rf(user, token, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.ImpersonationToken)
		}
	}

	if rf, ok := ret.Get(1).(func(int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(user, token, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(int, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(user, token, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_GetImpersonationToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetImpersonationToken'
type UsersServiceInterface_GetImpersonationToken_Call struct {
	*mock.Call
}

// GetImpersonationToken is a helper method to define mock.On call
//   - user int
//   - token int
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) GetImpersonationToken(user interface{}, token interface{}, options ...interface{}) *UsersServiceInterface_GetImpersonationToken_Call {
	return &UsersServiceInterface_GetImpersonationToken_Call{Call: _e.mock.On("GetImpersonationToken",
		append([]interface{}{user, token}, options...)...)}
}

func (_c *UsersServiceInterface_GetImpersonationToken_Call) Run(run func(user int, token int, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_GetImpersonationToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_GetImpersonationToken_Call) Return(_a0 *gitlab.ImpersonationToken, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_GetImpersonationToken_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_GetImpersonationToken_Call) RunAndReturn(run func(int, int, ...gitlab.RequestOptionFunc) (*gitlab.ImpersonationToken, *gitlab.Response, error)) *UsersServiceInterface_GetImpersonationToken_Call {
	_c.Call.Return(run)
	return _c
}

// GetSSHKey provides a mock function with given fields: key, options
func (_m *UsersServiceInterface) GetSSHKey(key int, options ...gitlab.RequestOptionFunc) (*gitlab.SSHKey, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSSHKey")
	}

	var r0 *gitlab.SSHKey
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) (*gitlab.SSHKey, *gitlab.Response, error)); ok {
		return rf(key, options...)
	}
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) *gitlab.SSHKey); ok {
		r0 = rf(key, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.SSHKey)
		}
	}

	if rf, ok := ret.Get(1).(func(int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(key, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(key, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_GetSSHKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSSHKey'
type UsersServiceInterface_GetSSHKey_Call struct {
	*mock.Call
}

// GetSSHKey is a helper method to define mock.On call
//   - key int
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) GetSSHKey(key interface{}, options ...interface{}) *UsersServiceInterface_GetSSHKey_Call {
	return &UsersServiceInterface_GetSSHKey_Call{Call: _e.mock.On("GetSSHKey",
		append([]interface{}{key}, options...)...)}
}

func (_c *UsersServiceInterface_GetSSHKey_Call) Run(run func(key int, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_GetSSHKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_GetSSHKey_Call) Return(_a0 *gitlab.SSHKey, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_GetSSHKey_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_GetSSHKey_Call) RunAndReturn(run func(int, ...gitlab.RequestOptionFunc) (*gitlab.SSHKey, *gitlab.Response, error)) *UsersServiceInterface_GetSSHKey_Call {
	_c.Call.Return(run)
	return _c
}

// GetSSHKeyForUser provides a mock function with given fields: user, key, options
func (_m *UsersServiceInterface) GetSSHKeyForUser(user int, key int, options ...gitlab.RequestOptionFunc) (*gitlab.SSHKey, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSSHKeyForUser")
	}

	var r0 *gitlab.SSHKey
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(int, int, ...gitlab.RequestOptionFunc) (*gitlab.SSHKey, *gitlab.Response, error)); ok {
		return rf(user, key, options...)
	}
	if rf, ok := ret.Get(0).(func(int, int, ...gitlab.RequestOptionFunc) *gitlab.SSHKey); ok {
		r0 = rf(user, key, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.SSHKey)
		}
	}

	if rf, ok := ret.Get(1).(func(int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(user, key, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(int, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(user, key, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_GetSSHKeyForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSSHKeyForUser'
type UsersServiceInterface_GetSSHKeyForUser_Call struct {
	*mock.Call
}

// GetSSHKeyForUser is a helper method to define mock.On call
//   - user int
//   - key int
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) GetSSHKeyForUser(user interface{}, key interface{}, options ...interface{}) *UsersServiceInterface_GetSSHKeyForUser_Call {
	return &UsersServiceInterface_GetSSHKeyForUser_Call{Call: _e.mock.On("GetSSHKeyForUser",
		append([]interface{}{user, key}, options...)...)}
}

func (_c *UsersServiceInterface_GetSSHKeyForUser_Call) Run(run func(user int, key int, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_GetSSHKeyForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_GetSSHKeyForUser_Call) Return(_a0 *gitlab.SSHKey, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_GetSSHKeyForUser_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_GetSSHKeyForUser_Call) RunAndReturn(run func(int, int, ...gitlab.RequestOptionFunc) (*gitlab.SSHKey, *gitlab.Response, error)) *UsersServiceInterface_GetSSHKeyForUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetUser provides a mock function with given fields: user, opt, options
func (_m *UsersServiceInterface) GetUser(user int, opt gitlab.GetUsersOptions, options ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetUser")
	}

	var r0 *gitlab.User
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(int, gitlab.GetUsersOptions, ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error)); ok {
		return rf(user, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(int, gitlab.GetUsersOptions, ...gitlab.RequestOptionFunc) *gitlab.User); ok {
		r0 = rf(user, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.User)
		}
	}

	if rf, ok := ret.Get(1).(func(int, gitlab.GetUsersOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(user, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(int, gitlab.GetUsersOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(user, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_GetUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUser'
type UsersServiceInterface_GetUser_Call struct {
	*mock.Call
}

// GetUser is a helper method to define mock.On call
//   - user int
//   - opt gitlab.GetUsersOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) GetUser(user interface{}, opt interface{}, options ...interface{}) *UsersServiceInterface_GetUser_Call {
	return &UsersServiceInterface_GetUser_Call{Call: _e.mock.On("GetUser",
		append([]interface{}{user, opt}, options...)...)}
}

func (_c *UsersServiceInterface_GetUser_Call) Run(run func(user int, opt gitlab.GetUsersOptions, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_GetUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), args[1].(gitlab.GetUsersOptions), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_GetUser_Call) Return(_a0 *gitlab.User, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_GetUser_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_GetUser_Call) RunAndReturn(run func(int, gitlab.GetUsersOptions, ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error)) *UsersServiceInterface_GetUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserActivities provides a mock function with given fields: opt, options
func (_m *UsersServiceInterface) GetUserActivities(opt *gitlab.GetUserActivitiesOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.UserActivity, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetUserActivities")
	}

	var r0 []*gitlab.UserActivity
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(*gitlab.GetUserActivitiesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.UserActivity, *gitlab.Response, error)); ok {
		return rf(opt, options...)
	}
	if rf, ok := ret.Get(0).(func(*gitlab.GetUserActivitiesOptions, ...gitlab.RequestOptionFunc) []*gitlab.UserActivity); ok {
		r0 = rf(opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.UserActivity)
		}
	}

	if rf, ok := ret.Get(1).(func(*gitlab.GetUserActivitiesOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(*gitlab.GetUserActivitiesOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_GetUserActivities_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserActivities'
type UsersServiceInterface_GetUserActivities_Call struct {
	*mock.Call
}

// GetUserActivities is a helper method to define mock.On call
//   - opt *gitlab.GetUserActivitiesOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) GetUserActivities(opt interface{}, options ...interface{}) *UsersServiceInterface_GetUserActivities_Call {
	return &UsersServiceInterface_GetUserActivities_Call{Call: _e.mock.On("GetUserActivities",
		append([]interface{}{opt}, options...)...)}
}

func (_c *UsersServiceInterface_GetUserActivities_Call) Run(run func(opt *gitlab.GetUserActivitiesOptions, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_GetUserActivities_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(*gitlab.GetUserActivitiesOptions), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_GetUserActivities_Call) Return(_a0 []*gitlab.UserActivity, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_GetUserActivities_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_GetUserActivities_Call) RunAndReturn(run func(*gitlab.GetUserActivitiesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.UserActivity, *gitlab.Response, error)) *UsersServiceInterface_GetUserActivities_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserAssociationsCount provides a mock function with given fields: user, options
func (_m *UsersServiceInterface) GetUserAssociationsCount(user int, options ...gitlab.RequestOptionFunc) (*gitlab.UserAssociationsCount, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetUserAssociationsCount")
	}

	var r0 *gitlab.UserAssociationsCount
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) (*gitlab.UserAssociationsCount, *gitlab.Response, error)); ok {
		return rf(user, options...)
	}
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) *gitlab.UserAssociationsCount); ok {
		r0 = rf(user, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.UserAssociationsCount)
		}
	}

	if rf, ok := ret.Get(1).(func(int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(user, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(user, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_GetUserAssociationsCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserAssociationsCount'
type UsersServiceInterface_GetUserAssociationsCount_Call struct {
	*mock.Call
}

// GetUserAssociationsCount is a helper method to define mock.On call
//   - user int
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) GetUserAssociationsCount(user interface{}, options ...interface{}) *UsersServiceInterface_GetUserAssociationsCount_Call {
	return &UsersServiceInterface_GetUserAssociationsCount_Call{Call: _e.mock.On("GetUserAssociationsCount",
		append([]interface{}{user}, options...)...)}
}

func (_c *UsersServiceInterface_GetUserAssociationsCount_Call) Run(run func(user int, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_GetUserAssociationsCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_GetUserAssociationsCount_Call) Return(_a0 *gitlab.UserAssociationsCount, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_GetUserAssociationsCount_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_GetUserAssociationsCount_Call) RunAndReturn(run func(int, ...gitlab.RequestOptionFunc) (*gitlab.UserAssociationsCount, *gitlab.Response, error)) *UsersServiceInterface_GetUserAssociationsCount_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserMemberships provides a mock function with given fields: user, opt, options
func (_m *UsersServiceInterface) GetUserMemberships(user int, opt *gitlab.GetUserMembershipOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.UserMembership, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetUserMemberships")
	}

	var r0 []*gitlab.UserMembership
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(int, *gitlab.GetUserMembershipOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.UserMembership, *gitlab.Response, error)); ok {
		return rf(user, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(int, *gitlab.GetUserMembershipOptions, ...gitlab.RequestOptionFunc) []*gitlab.UserMembership); ok {
		r0 = rf(user, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.UserMembership)
		}
	}

	if rf, ok := ret.Get(1).(func(int, *gitlab.GetUserMembershipOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(user, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(int, *gitlab.GetUserMembershipOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(user, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_GetUserMemberships_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserMemberships'
type UsersServiceInterface_GetUserMemberships_Call struct {
	*mock.Call
}

// GetUserMemberships is a helper method to define mock.On call
//   - user int
//   - opt *gitlab.GetUserMembershipOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) GetUserMemberships(user interface{}, opt interface{}, options ...interface{}) *UsersServiceInterface_GetUserMemberships_Call {
	return &UsersServiceInterface_GetUserMemberships_Call{Call: _e.mock.On("GetUserMemberships",
		append([]interface{}{user, opt}, options...)...)}
}

func (_c *UsersServiceInterface_GetUserMemberships_Call) Run(run func(user int, opt *gitlab.GetUserMembershipOptions, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_GetUserMemberships_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), args[1].(*gitlab.GetUserMembershipOptions), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_GetUserMemberships_Call) Return(_a0 []*gitlab.UserMembership, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_GetUserMemberships_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_GetUserMemberships_Call) RunAndReturn(run func(int, *gitlab.GetUserMembershipOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.UserMembership, *gitlab.Response, error)) *UsersServiceInterface_GetUserMemberships_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserStatus provides a mock function with given fields: user, options
func (_m *UsersServiceInterface) GetUserStatus(user int, options ...gitlab.RequestOptionFunc) (*gitlab.UserStatus, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetUserStatus")
	}

	var r0 *gitlab.UserStatus
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) (*gitlab.UserStatus, *gitlab.Response, error)); ok {
		return rf(user, options...)
	}
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) *gitlab.UserStatus); ok {
		r0 = rf(user, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.UserStatus)
		}
	}

	if rf, ok := ret.Get(1).(func(int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(user, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(user, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_GetUserStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserStatus'
type UsersServiceInterface_GetUserStatus_Call struct {
	*mock.Call
}

// GetUserStatus is a helper method to define mock.On call
//   - user int
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) GetUserStatus(user interface{}, options ...interface{}) *UsersServiceInterface_GetUserStatus_Call {
	return &UsersServiceInterface_GetUserStatus_Call{Call: _e.mock.On("GetUserStatus",
		append([]interface{}{user}, options...)...)}
}

func (_c *UsersServiceInterface_GetUserStatus_Call) Run(run func(user int, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_GetUserStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_GetUserStatus_Call) Return(_a0 *gitlab.UserStatus, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_GetUserStatus_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_GetUserStatus_Call) RunAndReturn(run func(int, ...gitlab.RequestOptionFunc) (*gitlab.UserStatus, *gitlab.Response, error)) *UsersServiceInterface_GetUserStatus_Call {
	_c.Call.Return(run)
	return _c
}

// ListEmails provides a mock function with given fields: options
func (_m *UsersServiceInterface) ListEmails(options ...gitlab.RequestOptionFunc) ([]*gitlab.Email, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEmails")
	}

	var r0 []*gitlab.Email
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(...gitlab.RequestOptionFunc) ([]*gitlab.Email, *gitlab.Response, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...gitlab.RequestOptionFunc) []*gitlab.Email); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Email)
		}
	}

	if rf, ok := ret.Get(1).(func(...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_ListEmails_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListEmails'
type UsersServiceInterface_ListEmails_Call struct {
	*mock.Call
}

// ListEmails is a helper method to define mock.On call
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) ListEmails(options ...interface{}) *UsersServiceInterface_ListEmails_Call {
	return &UsersServiceInterface_ListEmails_Call{Call: _e.mock.On("ListEmails",
		append([]interface{}{}, options...)...)}
}

func (_c *UsersServiceInterface_ListEmails_Call) Run(run func(options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_ListEmails_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_ListEmails_Call) Return(_a0 []*gitlab.Email, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_ListEmails_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_ListEmails_Call) RunAndReturn(run func(...gitlab.RequestOptionFunc) ([]*gitlab.Email, *gitlab.Response, error)) *UsersServiceInterface_ListEmails_Call {
	_c.Call.Return(run)
	return _c
}

// ListEmailsForUser provides a mock function with given fields: user, opt, options
func (_m *UsersServiceInterface) ListEmailsForUser(user int, opt *gitlab.ListEmailsForUserOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Email, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEmailsForUser")
	}

	var r0 []*gitlab.Email
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(int, *gitlab.ListEmailsForUserOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Email, *gitlab.Response, error)); ok {
		return rf(user, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(int, *gitlab.ListEmailsForUserOptions, ...gitlab.RequestOptionFunc) []*gitlab.Email); ok {
		r0 = rf(user, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Email)
		}
	}

	if rf, ok := ret.Get(1).(func(int, *gitlab.ListEmailsForUserOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(user, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(int, *gitlab.ListEmailsForUserOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(user, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_ListEmailsForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListEmailsForUser'
type UsersServiceInterface_ListEmailsForUser_Call struct {
	*mock.Call
}

// ListEmailsForUser is a helper method to define mock.On call
//   - user int
//   - opt *gitlab.ListEmailsForUserOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) ListEmailsForUser(user interface{}, opt interface{}, options ...interface{}) *UsersServiceInterface_ListEmailsForUser_Call {
	return &UsersServiceInterface_ListEmailsForUser_Call{Call: _e.mock.On("ListEmailsForUser",
		append([]interface{}{user, opt}, options...)...)}
}

func (_c *UsersServiceInterface_ListEmailsForUser_Call) Run(run func(user int, opt *gitlab.ListEmailsForUserOptions, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_ListEmailsForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), args[1].(*gitlab.ListEmailsForUserOptions), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_ListEmailsForUser_Call) Return(_a0 []*gitlab.Email, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_ListEmailsForUser_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_ListEmailsForUser_Call) RunAndReturn(run func(int, *gitlab.ListEmailsForUserOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Email, *gitlab.Response, error)) *UsersServiceInterface_ListEmailsForUser_Call {
	_c.Call.Return(run)
	return _c
}

// ListGPGKeys provides a mock function with given fields: options
func (_m *UsersServiceInterface) ListGPGKeys(options ...gitlab.RequestOptionFunc) ([]*gitlab.GPGKey, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListGPGKeys")
	}

	var r0 []*gitlab.GPGKey
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(...gitlab.RequestOptionFunc) ([]*gitlab.GPGKey, *gitlab.Response, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...gitlab.RequestOptionFunc) []*gitlab.GPGKey); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.GPGKey)
		}
	}

	if rf, ok := ret.Get(1).(func(...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_ListGPGKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListGPGKeys'
type UsersServiceInterface_ListGPGKeys_Call struct {
	*mock.Call
}

// ListGPGKeys is a helper method to define mock.On call
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) ListGPGKeys(options ...interface{}) *UsersServiceInterface_ListGPGKeys_Call {
	return &UsersServiceInterface_ListGPGKeys_Call{Call: _e.mock.On("ListGPGKeys",
		append([]interface{}{}, options...)...)}
}

func (_c *UsersServiceInterface_ListGPGKeys_Call) Run(run func(options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_ListGPGKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_ListGPGKeys_Call) Return(_a0 []*gitlab.GPGKey, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_ListGPGKeys_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_ListGPGKeys_Call) RunAndReturn(run func(...gitlab.RequestOptionFunc) ([]*gitlab.GPGKey, *gitlab.Response, error)) *UsersServiceInterface_ListGPGKeys_Call {
	_c.Call.Return(run)
	return _c
}

// ListGPGKeysForUser provides a mock function with given fields: user, options
func (_m *UsersServiceInterface) ListGPGKeysForUser(user int, options ...gitlab.RequestOptionFunc) ([]*gitlab.GPGKey, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListGPGKeysForUser")
	}

	var r0 []*gitlab.GPGKey
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) ([]*gitlab.GPGKey, *gitlab.Response, error)); ok {
		return rf(user, options...)
	}
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) []*gitlab.GPGKey); ok {
		r0 = rf(user, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.GPGKey)
		}
	}

	if rf, ok := ret.Get(1).(func(int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(user, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(user, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_ListGPGKeysForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListGPGKeysForUser'
type UsersServiceInterface_ListGPGKeysForUser_Call struct {
	*mock.Call
}

// ListGPGKeysForUser is a helper method to define mock.On call
//   - user int
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) ListGPGKeysForUser(user interface{}, options ...interface{}) *UsersServiceInterface_ListGPGKeysForUser_Call {
	return &UsersServiceInterface_ListGPGKeysForUser_Call{Call: _e.mock.On("ListGPGKeysForUser",
		append([]interface{}{user}, options...)...)}
}

func (_c *UsersServiceInterface_ListGPGKeysForUser_Call) Run(run func(user int, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_ListGPGKeysForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_ListGPGKeysForUser_Call) Return(_a0 []*gitlab.GPGKey, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_ListGPGKeysForUser_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_ListGPGKeysForUser_Call) RunAndReturn(run func(int, ...gitlab.RequestOptionFunc) ([]*gitlab.GPGKey, *gitlab.Response, error)) *UsersServiceInterface_ListGPGKeysForUser_Call {
	_c.Call.Return(run)
	return _c
}

// ListSSHKeys provides a mock function with given fields: opt, options
func (_m *UsersServiceInterface) ListSSHKeys(opt *gitlab.ListSSHKeysOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.SSHKey, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSSHKeys")
	}

	var r0 []*gitlab.SSHKey
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(*gitlab.ListSSHKeysOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.SSHKey, *gitlab.Response, error)); ok {
		return rf(opt, options...)
	}
	if rf, ok := ret.Get(0).(func(*gitlab.ListSSHKeysOptions, ...gitlab.RequestOptionFunc) []*gitlab.SSHKey); ok {
		r0 = rf(opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.SSHKey)
		}
	}

	if rf, ok := ret.Get(1).(func(*gitlab.ListSSHKeysOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(*gitlab.ListSSHKeysOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_ListSSHKeys_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListSSHKeys'
type UsersServiceInterface_ListSSHKeys_Call struct {
	*mock.Call
}

// ListSSHKeys is a helper method to define mock.On call
//   - opt *gitlab.ListSSHKeysOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) ListSSHKeys(opt interface{}, options ...interface{}) *UsersServiceInterface_ListSSHKeys_Call {
	return &UsersServiceInterface_ListSSHKeys_Call{Call: _e.mock.On("ListSSHKeys",
		append([]interface{}{opt}, options...)...)}
}

func (_c *UsersServiceInterface_ListSSHKeys_Call) Run(run func(opt *gitlab.ListSSHKeysOptions, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_ListSSHKeys_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(*gitlab.ListSSHKeysOptions), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_ListSSHKeys_Call) Return(_a0 []*gitlab.SSHKey, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_ListSSHKeys_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_ListSSHKeys_Call) RunAndReturn(run func(*gitlab.ListSSHKeysOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.SSHKey, *gitlab.Response, error)) *UsersServiceInterface_ListSSHKeys_Call {
	_c.Call.Return(run)
	return _c
}

// ListSSHKeysForUser provides a mock function with given fields: uid, opt, options
func (_m *UsersServiceInterface) ListSSHKeysForUser(uid interface{}, opt *gitlab.ListSSHKeysForUserOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.SSHKey, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, uid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSSHKeysForUser")
	}

	var r0 []*gitlab.SSHKey
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListSSHKeysForUserOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.SSHKey, *gitlab.Response, error)); ok {
		return rf(uid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListSSHKeysForUserOptions, ...gitlab.RequestOptionFunc) []*gitlab.SSHKey); ok {
		r0 = rf(uid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.SSHKey)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListSSHKeysForUserOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(uid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListSSHKeysForUserOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(uid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_ListSSHKeysForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListSSHKeysForUser'
type UsersServiceInterface_ListSSHKeysForUser_Call struct {
	*mock.Call
}

// ListSSHKeysForUser is a helper method to define mock.On call
//   - uid interface{}
//   - opt *gitlab.ListSSHKeysForUserOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) ListSSHKeysForUser(uid interface{}, opt interface{}, options ...interface{}) *UsersServiceInterface_ListSSHKeysForUser_Call {
	return &UsersServiceInterface_ListSSHKeysForUser_Call{Call: _e.mock.On("ListSSHKeysForUser",
		append([]interface{}{uid, opt}, options...)...)}
}

func (_c *UsersServiceInterface_ListSSHKeysForUser_Call) Run(run func(uid interface{}, opt *gitlab.ListSSHKeysForUserOptions, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_ListSSHKeysForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListSSHKeysForUserOptions), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_ListSSHKeysForUser_Call) Return(_a0 []*gitlab.SSHKey, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_ListSSHKeysForUser_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_ListSSHKeysForUser_Call) RunAndReturn(run func(interface{}, *gitlab.ListSSHKeysForUserOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.SSHKey, *gitlab.Response, error)) *UsersServiceInterface_ListSSHKeysForUser_Call {
	_c.Call.Return(run)
	return _c
}

// ListServiceAccounts provides a mock function with given fields: opt, options
func (_m *UsersServiceInterface) ListServiceAccounts(opt *gitlab.ListServiceAccountsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.ServiceAccount, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListServiceAccounts")
	}

	var r0 []*gitlab.ServiceAccount
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(*gitlab.ListServiceAccountsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ServiceAccount, *gitlab.Response, error)); ok {
		return rf(opt, options...)
	}
	if rf, ok := ret.Get(0).(func(*gitlab.ListServiceAccountsOptions, ...gitlab.RequestOptionFunc) []*gitlab.ServiceAccount); ok {
		r0 = rf(opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.ServiceAccount)
		}
	}

	if rf, ok := ret.Get(1).(func(*gitlab.ListServiceAccountsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(*gitlab.ListServiceAccountsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_ListServiceAccounts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListServiceAccounts'
type UsersServiceInterface_ListServiceAccounts_Call struct {
	*mock.Call
}

// ListServiceAccounts is a helper method to define mock.On call
//   - opt *gitlab.ListServiceAccountsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) ListServiceAccounts(opt interface{}, options ...interface{}) *UsersServiceInterface_ListServiceAccounts_Call {
	return &UsersServiceInterface_ListServiceAccounts_Call{Call: _e.mock.On("ListServiceAccounts",
		append([]interface{}{opt}, options...)...)}
}

func (_c *UsersServiceInterface_ListServiceAccounts_Call) Run(run func(opt *gitlab.ListServiceAccountsOptions, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_ListServiceAccounts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(*gitlab.ListServiceAccountsOptions), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_ListServiceAccounts_Call) Return(_a0 []*gitlab.ServiceAccount, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_ListServiceAccounts_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_ListServiceAccounts_Call) RunAndReturn(run func(*gitlab.ListServiceAccountsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ServiceAccount, *gitlab.Response, error)) *UsersServiceInterface_ListServiceAccounts_Call {
	_c.Call.Return(run)
	return _c
}

// ListUserContributionEvents provides a mock function with given fields: uid, opt, options
func (_m *UsersServiceInterface) ListUserContributionEvents(uid interface{}, opt *gitlab.ListContributionEventsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.ContributionEvent, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, uid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListUserContributionEvents")
	}

	var r0 []*gitlab.ContributionEvent
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListContributionEventsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ContributionEvent, *gitlab.Response, error)); ok {
		return rf(uid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListContributionEventsOptions, ...gitlab.RequestOptionFunc) []*gitlab.ContributionEvent); ok {
		r0 = rf(uid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.ContributionEvent)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListContributionEventsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(uid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListContributionEventsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(uid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_ListUserContributionEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListUserContributionEvents'
type UsersServiceInterface_ListUserContributionEvents_Call struct {
	*mock.Call
}

// ListUserContributionEvents is a helper method to define mock.On call
//   - uid interface{}
//   - opt *gitlab.ListContributionEventsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) ListUserContributionEvents(uid interface{}, opt interface{}, options ...interface{}) *UsersServiceInterface_ListUserContributionEvents_Call {
	return &UsersServiceInterface_ListUserContributionEvents_Call{Call: _e.mock.On("ListUserContributionEvents",
		append([]interface{}{uid, opt}, options...)...)}
}

func (_c *UsersServiceInterface_ListUserContributionEvents_Call) Run(run func(uid interface{}, opt *gitlab.ListContributionEventsOptions, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_ListUserContributionEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListContributionEventsOptions), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_ListUserContributionEvents_Call) Return(_a0 []*gitlab.ContributionEvent, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_ListUserContributionEvents_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_ListUserContributionEvents_Call) RunAndReturn(run func(interface{}, *gitlab.ListContributionEventsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ContributionEvent, *gitlab.Response, error)) *UsersServiceInterface_ListUserContributionEvents_Call {
	_c.Call.Return(run)
	return _c
}

// ListUsers provides a mock function with given fields: opt, options
func (_m *UsersServiceInterface) ListUsers(opt *gitlab.ListUsersOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.User, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListUsers")
	}

	var r0 []*gitlab.User
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(*gitlab.ListUsersOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.User, *gitlab.Response, error)); ok {
		return rf(opt, options...)
	}
	if rf, ok := ret.Get(0).(func(*gitlab.ListUsersOptions, ...gitlab.RequestOptionFunc) []*gitlab.User); ok {
		r0 = rf(opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.User)
		}
	}

	if rf, ok := ret.Get(1).(func(*gitlab.ListUsersOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(*gitlab.ListUsersOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_ListUsers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListUsers'
type UsersServiceInterface_ListUsers_Call struct {
	*mock.Call
}

// ListUsers is a helper method to define mock.On call
//   - opt *gitlab.ListUsersOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) ListUsers(opt interface{}, options ...interface{}) *UsersServiceInterface_ListUsers_Call {
	return &UsersServiceInterface_ListUsers_Call{Call: _e.mock.On("ListUsers",
		append([]interface{}{opt}, options...)...)}
}

func (_c *UsersServiceInterface_ListUsers_Call) Run(run func(opt *gitlab.ListUsersOptions, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_ListUsers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(*gitlab.ListUsersOptions), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_ListUsers_Call) Return(_a0 []*gitlab.User, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_ListUsers_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_ListUsers_Call) RunAndReturn(run func(*gitlab.ListUsersOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.User, *gitlab.Response, error)) *UsersServiceInterface_ListUsers_Call {
	_c.Call.Return(run)
	return _c
}

// ModifyUser provides a mock function with given fields: user, opt, options
func (_m *UsersServiceInterface) ModifyUser(user int, opt *gitlab.ModifyUserOptions, options ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ModifyUser")
	}

	var r0 *gitlab.User
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(int, *gitlab.ModifyUserOptions, ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error)); ok {
		return rf(user, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(int, *gitlab.ModifyUserOptions, ...gitlab.RequestOptionFunc) *gitlab.User); ok {
		r0 = rf(user, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.User)
		}
	}

	if rf, ok := ret.Get(1).(func(int, *gitlab.ModifyUserOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(user, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(int, *gitlab.ModifyUserOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(user, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_ModifyUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ModifyUser'
type UsersServiceInterface_ModifyUser_Call struct {
	*mock.Call
}

// ModifyUser is a helper method to define mock.On call
//   - user int
//   - opt *gitlab.ModifyUserOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) ModifyUser(user interface{}, opt interface{}, options ...interface{}) *UsersServiceInterface_ModifyUser_Call {
	return &UsersServiceInterface_ModifyUser_Call{Call: _e.mock.On("ModifyUser",
		append([]interface{}{user, opt}, options...)...)}
}

func (_c *UsersServiceInterface_ModifyUser_Call) Run(run func(user int, opt *gitlab.ModifyUserOptions, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_ModifyUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), args[1].(*gitlab.ModifyUserOptions), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_ModifyUser_Call) Return(_a0 *gitlab.User, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_ModifyUser_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_ModifyUser_Call) RunAndReturn(run func(int, *gitlab.ModifyUserOptions, ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error)) *UsersServiceInterface_ModifyUser_Call {
	_c.Call.Return(run)
	return _c
}

// RejectUser provides a mock function with given fields: user, options
func (_m *UsersServiceInterface) RejectUser(user int, options ...gitlab.RequestOptionFunc) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RejectUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) error); ok {
		r0 = rf(user, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UsersServiceInterface_RejectUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RejectUser'
type UsersServiceInterface_RejectUser_Call struct {
	*mock.Call
}

// RejectUser is a helper method to define mock.On call
//   - user int
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) RejectUser(user interface{}, options ...interface{}) *UsersServiceInterface_RejectUser_Call {
	return &UsersServiceInterface_RejectUser_Call{Call: _e.mock.On("RejectUser",
		append([]interface{}{user}, options...)...)}
}

func (_c *UsersServiceInterface_RejectUser_Call) Run(run func(user int, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_RejectUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_RejectUser_Call) Return(_a0 error) *UsersServiceInterface_RejectUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UsersServiceInterface_RejectUser_Call) RunAndReturn(run func(int, ...gitlab.RequestOptionFunc) error) *UsersServiceInterface_RejectUser_Call {
	_c.Call.Return(run)
	return _c
}

// RevokeImpersonationToken provides a mock function with given fields: user, token, options
func (_m *UsersServiceInterface) RevokeImpersonationToken(user int, token int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user, token)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RevokeImpersonationToken")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(user, token, options...)
	}
	if rf, ok := ret.Get(0).(func(int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(user, token, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(int, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(user, token, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UsersServiceInterface_RevokeImpersonationToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RevokeImpersonationToken'
type UsersServiceInterface_RevokeImpersonationToken_Call struct {
	*mock.Call
}

// RevokeImpersonationToken is a helper method to define mock.On call
//   - user int
//   - token int
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) RevokeImpersonationToken(user interface{}, token interface{}, options ...interface{}) *UsersServiceInterface_RevokeImpersonationToken_Call {
	return &UsersServiceInterface_RevokeImpersonationToken_Call{Call: _e.mock.On("RevokeImpersonationToken",
		append([]interface{}{user, token}, options...)...)}
}

func (_c *UsersServiceInterface_RevokeImpersonationToken_Call) Run(run func(user int, token int, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_RevokeImpersonationToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_RevokeImpersonationToken_Call) Return(_a0 *gitlab.Response, _a1 error) *UsersServiceInterface_RevokeImpersonationToken_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *UsersServiceInterface_RevokeImpersonationToken_Call) RunAndReturn(run func(int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *UsersServiceInterface_RevokeImpersonationToken_Call {
	_c.Call.Return(run)
	return _c
}

// SetUserStatus provides a mock function with given fields: opt, options
func (_m *UsersServiceInterface) SetUserStatus(opt *gitlab.UserStatusOptions, options ...gitlab.RequestOptionFunc) (*gitlab.UserStatus, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetUserStatus")
	}

	var r0 *gitlab.UserStatus
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(*gitlab.UserStatusOptions, ...gitlab.RequestOptionFunc) (*gitlab.UserStatus, *gitlab.Response, error)); ok {
		return rf(opt, options...)
	}
	if rf, ok := ret.Get(0).(func(*gitlab.UserStatusOptions, ...gitlab.RequestOptionFunc) *gitlab.UserStatus); ok {
		r0 = rf(opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.UserStatus)
		}
	}

	if rf, ok := ret.Get(1).(func(*gitlab.UserStatusOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(*gitlab.UserStatusOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_SetUserStatus_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetUserStatus'
type UsersServiceInterface_SetUserStatus_Call struct {
	*mock.Call
}

// SetUserStatus is a helper method to define mock.On call
//   - opt *gitlab.UserStatusOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) SetUserStatus(opt interface{}, options ...interface{}) *UsersServiceInterface_SetUserStatus_Call {
	return &UsersServiceInterface_SetUserStatus_Call{Call: _e.mock.On("SetUserStatus",
		append([]interface{}{opt}, options...)...)}
}

func (_c *UsersServiceInterface_SetUserStatus_Call) Run(run func(opt *gitlab.UserStatusOptions, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_SetUserStatus_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(*gitlab.UserStatusOptions), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_SetUserStatus_Call) Return(_a0 *gitlab.UserStatus, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_SetUserStatus_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_SetUserStatus_Call) RunAndReturn(run func(*gitlab.UserStatusOptions, ...gitlab.RequestOptionFunc) (*gitlab.UserStatus, *gitlab.Response, error)) *UsersServiceInterface_SetUserStatus_Call {
	_c.Call.Return(run)
	return _c
}

// UnbanUser provides a mock function with given fields: user, options
func (_m *UsersServiceInterface) UnbanUser(user int, options ...gitlab.RequestOptionFunc) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnbanUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) error); ok {
		r0 = rf(user, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UsersServiceInterface_UnbanUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnbanUser'
type UsersServiceInterface_UnbanUser_Call struct {
	*mock.Call
}

// UnbanUser is a helper method to define mock.On call
//   - user int
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) UnbanUser(user interface{}, options ...interface{}) *UsersServiceInterface_UnbanUser_Call {
	return &UsersServiceInterface_UnbanUser_Call{Call: _e.mock.On("UnbanUser",
		append([]interface{}{user}, options...)...)}
}

func (_c *UsersServiceInterface_UnbanUser_Call) Run(run func(user int, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_UnbanUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_UnbanUser_Call) Return(_a0 error) *UsersServiceInterface_UnbanUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UsersServiceInterface_UnbanUser_Call) RunAndReturn(run func(int, ...gitlab.RequestOptionFunc) error) *UsersServiceInterface_UnbanUser_Call {
	_c.Call.Return(run)
	return _c
}

// UnblockUser provides a mock function with given fields: user, options
func (_m *UsersServiceInterface) UnblockUser(user int, options ...gitlab.RequestOptionFunc) error {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnblockUser")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) error); ok {
		r0 = rf(user, options...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UsersServiceInterface_UnblockUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnblockUser'
type UsersServiceInterface_UnblockUser_Call struct {
	*mock.Call
}

// UnblockUser is a helper method to define mock.On call
//   - user int
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) UnblockUser(user interface{}, options ...interface{}) *UsersServiceInterface_UnblockUser_Call {
	return &UsersServiceInterface_UnblockUser_Call{Call: _e.mock.On("UnblockUser",
		append([]interface{}{user}, options...)...)}
}

func (_c *UsersServiceInterface_UnblockUser_Call) Run(run func(user int, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_UnblockUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_UnblockUser_Call) Return(_a0 error) *UsersServiceInterface_UnblockUser_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *UsersServiceInterface_UnblockUser_Call) RunAndReturn(run func(int, ...gitlab.RequestOptionFunc) error) *UsersServiceInterface_UnblockUser_Call {
	_c.Call.Return(run)
	return _c
}

// UploadAvatar provides a mock function with given fields: avatar, filename, options
func (_m *UsersServiceInterface) UploadAvatar(avatar io.Reader, filename string, options ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, avatar, filename)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UploadAvatar")
	}

	var r0 *gitlab.User
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(io.Reader, string, ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error)); ok {
		return rf(avatar, filename, options...)
	}
	if rf, ok := ret.Get(0).(func(io.Reader, string, ...gitlab.RequestOptionFunc) *gitlab.User); ok {
		r0 = rf(avatar, filename, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.User)
		}
	}

	if rf, ok := ret.Get(1).(func(io.Reader, string, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(avatar, filename, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(io.Reader, string, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(avatar, filename, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// UsersServiceInterface_UploadAvatar_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UploadAvatar'
type UsersServiceInterface_UploadAvatar_Call struct {
	*mock.Call
}

// UploadAvatar is a helper method to define mock.On call
//   - avatar io.Reader
//   - filename string
//   - options ...gitlab.RequestOptionFunc
func (_e *UsersServiceInterface_Expecter) UploadAvatar(avatar interface{}, filename interface{}, options ...interface{}) *UsersServiceInterface_UploadAvatar_Call {
	return &UsersServiceInterface_UploadAvatar_Call{Call: _e.mock.On("UploadAvatar",
		append([]interface{}{avatar, filename}, options...)...)}
}

func (_c *UsersServiceInterface_UploadAvatar_Call) Run(run func(avatar io.Reader, filename string, options ...gitlab.RequestOptionFunc)) *UsersServiceInterface_UploadAvatar_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(io.Reader), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *UsersServiceInterface_UploadAvatar_Call) Return(_a0 *gitlab.User, _a1 *gitlab.Response, _a2 error) *UsersServiceInterface_UploadAvatar_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *UsersServiceInterface_UploadAvatar_Call) RunAndReturn(run func(io.Reader, string, ...gitlab.RequestOptionFunc) (*gitlab.User, *gitlab.Response, error)) *UsersServiceInterface_UploadAvatar_Call {
	_c.Call.Return(run)
	return _c
}

// NewUsersServiceInterface creates a new instance of UsersServiceInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewUsersServiceInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *UsersServiceInterface {
	mock := &UsersServiceInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

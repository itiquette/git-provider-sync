// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	bytes "bytes"
	io "io"

	gitlab "gitlab.com/gitlab-org/api/client-go"

	mock "github.com/stretchr/testify/mock"
)

// ProjectsServiceInterface is an autogenerated mock type for the ProjectsServiceInterface type
type ProjectsServiceInterface struct {
	mock.Mock
}

type ProjectsServiceInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *ProjectsServiceInterface) EXPECT() *ProjectsServiceInterface_Expecter {
	return &ProjectsServiceInterface_Expecter{mock: &_m.Mock}
}

// AddProjectHook provides a mock function with given fields: pid, opt, options
func (_m *ProjectsServiceInterface) AddProjectHook(pid interface{}, opt *gitlab.AddProjectHookOptions, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectHook, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddProjectHook")
	}

	var r0 *gitlab.ProjectHook
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.AddProjectHookOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectHook, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.AddProjectHookOptions, ...gitlab.RequestOptionFunc) *gitlab.ProjectHook); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.ProjectHook)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.AddProjectHookOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.AddProjectHookOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_AddProjectHook_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddProjectHook'
type ProjectsServiceInterface_AddProjectHook_Call struct {
	*mock.Call
}

// AddProjectHook is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.AddProjectHookOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) AddProjectHook(pid interface{}, opt interface{}, options ...interface{}) *ProjectsServiceInterface_AddProjectHook_Call {
	return &ProjectsServiceInterface_AddProjectHook_Call{Call: _e.mock.On("AddProjectHook",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ProjectsServiceInterface_AddProjectHook_Call) Run(run func(pid interface{}, opt *gitlab.AddProjectHookOptions, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_AddProjectHook_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.AddProjectHookOptions), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_AddProjectHook_Call) Return(_a0 *gitlab.ProjectHook, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_AddProjectHook_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_AddProjectHook_Call) RunAndReturn(run func(interface{}, *gitlab.AddProjectHookOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectHook, *gitlab.Response, error)) *ProjectsServiceInterface_AddProjectHook_Call {
	_c.Call.Return(run)
	return _c
}

// AddProjectPushRule provides a mock function with given fields: pid, opt, options
func (_m *ProjectsServiceInterface) AddProjectPushRule(pid interface{}, opt *gitlab.AddProjectPushRuleOptions, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectPushRules, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddProjectPushRule")
	}

	var r0 *gitlab.ProjectPushRules
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.AddProjectPushRuleOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectPushRules, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.AddProjectPushRuleOptions, ...gitlab.RequestOptionFunc) *gitlab.ProjectPushRules); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.ProjectPushRules)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.AddProjectPushRuleOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.AddProjectPushRuleOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_AddProjectPushRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddProjectPushRule'
type ProjectsServiceInterface_AddProjectPushRule_Call struct {
	*mock.Call
}

// AddProjectPushRule is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.AddProjectPushRuleOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) AddProjectPushRule(pid interface{}, opt interface{}, options ...interface{}) *ProjectsServiceInterface_AddProjectPushRule_Call {
	return &ProjectsServiceInterface_AddProjectPushRule_Call{Call: _e.mock.On("AddProjectPushRule",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ProjectsServiceInterface_AddProjectPushRule_Call) Run(run func(pid interface{}, opt *gitlab.AddProjectPushRuleOptions, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_AddProjectPushRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.AddProjectPushRuleOptions), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_AddProjectPushRule_Call) Return(_a0 *gitlab.ProjectPushRules, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_AddProjectPushRule_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_AddProjectPushRule_Call) RunAndReturn(run func(interface{}, *gitlab.AddProjectPushRuleOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectPushRules, *gitlab.Response, error)) *ProjectsServiceInterface_AddProjectPushRule_Call {
	_c.Call.Return(run)
	return _c
}

// ArchiveProject provides a mock function with given fields: pid, options
func (_m *ProjectsServiceInterface) ArchiveProject(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ArchiveProject")
	}

	var r0 *gitlab.Project
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Project); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_ArchiveProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ArchiveProject'
type ProjectsServiceInterface_ArchiveProject_Call struct {
	*mock.Call
}

// ArchiveProject is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) ArchiveProject(pid interface{}, options ...interface{}) *ProjectsServiceInterface_ArchiveProject_Call {
	return &ProjectsServiceInterface_ArchiveProject_Call{Call: _e.mock.On("ArchiveProject",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ProjectsServiceInterface_ArchiveProject_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_ArchiveProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_ArchiveProject_Call) Return(_a0 *gitlab.Project, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_ArchiveProject_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_ArchiveProject_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *ProjectsServiceInterface_ArchiveProject_Call {
	_c.Call.Return(run)
	return _c
}

// ChangeAllowedApprovers provides a mock function with given fields: pid, opt, options
func (_m *ProjectsServiceInterface) ChangeAllowedApprovers(pid interface{}, opt *gitlab.ChangeAllowedApproversOptions, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovals, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChangeAllowedApprovers")
	}

	var r0 *gitlab.ProjectApprovals
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ChangeAllowedApproversOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovals, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ChangeAllowedApproversOptions, ...gitlab.RequestOptionFunc) *gitlab.ProjectApprovals); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.ProjectApprovals)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ChangeAllowedApproversOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ChangeAllowedApproversOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_ChangeAllowedApprovers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChangeAllowedApprovers'
type ProjectsServiceInterface_ChangeAllowedApprovers_Call struct {
	*mock.Call
}

// ChangeAllowedApprovers is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.ChangeAllowedApproversOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) ChangeAllowedApprovers(pid interface{}, opt interface{}, options ...interface{}) *ProjectsServiceInterface_ChangeAllowedApprovers_Call {
	return &ProjectsServiceInterface_ChangeAllowedApprovers_Call{Call: _e.mock.On("ChangeAllowedApprovers",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ProjectsServiceInterface_ChangeAllowedApprovers_Call) Run(run func(pid interface{}, opt *gitlab.ChangeAllowedApproversOptions, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_ChangeAllowedApprovers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ChangeAllowedApproversOptions), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_ChangeAllowedApprovers_Call) Return(_a0 *gitlab.ProjectApprovals, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_ChangeAllowedApprovers_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_ChangeAllowedApprovers_Call) RunAndReturn(run func(interface{}, *gitlab.ChangeAllowedApproversOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovals, *gitlab.Response, error)) *ProjectsServiceInterface_ChangeAllowedApprovers_Call {
	_c.Call.Return(run)
	return _c
}

// ChangeApprovalConfiguration provides a mock function with given fields: pid, opt, options
func (_m *ProjectsServiceInterface) ChangeApprovalConfiguration(pid interface{}, opt *gitlab.ChangeApprovalConfigurationOptions, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovals, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ChangeApprovalConfiguration")
	}

	var r0 *gitlab.ProjectApprovals
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ChangeApprovalConfigurationOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovals, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ChangeApprovalConfigurationOptions, ...gitlab.RequestOptionFunc) *gitlab.ProjectApprovals); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.ProjectApprovals)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ChangeApprovalConfigurationOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ChangeApprovalConfigurationOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_ChangeApprovalConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChangeApprovalConfiguration'
type ProjectsServiceInterface_ChangeApprovalConfiguration_Call struct {
	*mock.Call
}

// ChangeApprovalConfiguration is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.ChangeApprovalConfigurationOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) ChangeApprovalConfiguration(pid interface{}, opt interface{}, options ...interface{}) *ProjectsServiceInterface_ChangeApprovalConfiguration_Call {
	return &ProjectsServiceInterface_ChangeApprovalConfiguration_Call{Call: _e.mock.On("ChangeApprovalConfiguration",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ProjectsServiceInterface_ChangeApprovalConfiguration_Call) Run(run func(pid interface{}, opt *gitlab.ChangeApprovalConfigurationOptions, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_ChangeApprovalConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ChangeApprovalConfigurationOptions), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_ChangeApprovalConfiguration_Call) Return(_a0 *gitlab.ProjectApprovals, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_ChangeApprovalConfiguration_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_ChangeApprovalConfiguration_Call) RunAndReturn(run func(interface{}, *gitlab.ChangeApprovalConfigurationOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovals, *gitlab.Response, error)) *ProjectsServiceInterface_ChangeApprovalConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// ConfigureProjectPullMirror provides a mock function with given fields: pid, opt, options
func (_m *ProjectsServiceInterface) ConfigureProjectPullMirror(pid interface{}, opt *gitlab.ConfigureProjectPullMirrorOptions, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectPullMirrorDetails, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ConfigureProjectPullMirror")
	}

	var r0 *gitlab.ProjectPullMirrorDetails
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ConfigureProjectPullMirrorOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectPullMirrorDetails, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ConfigureProjectPullMirrorOptions, ...gitlab.RequestOptionFunc) *gitlab.ProjectPullMirrorDetails); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.ProjectPullMirrorDetails)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ConfigureProjectPullMirrorOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ConfigureProjectPullMirrorOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_ConfigureProjectPullMirror_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConfigureProjectPullMirror'
type ProjectsServiceInterface_ConfigureProjectPullMirror_Call struct {
	*mock.Call
}

// ConfigureProjectPullMirror is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.ConfigureProjectPullMirrorOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) ConfigureProjectPullMirror(pid interface{}, opt interface{}, options ...interface{}) *ProjectsServiceInterface_ConfigureProjectPullMirror_Call {
	return &ProjectsServiceInterface_ConfigureProjectPullMirror_Call{Call: _e.mock.On("ConfigureProjectPullMirror",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ProjectsServiceInterface_ConfigureProjectPullMirror_Call) Run(run func(pid interface{}, opt *gitlab.ConfigureProjectPullMirrorOptions, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_ConfigureProjectPullMirror_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ConfigureProjectPullMirrorOptions), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_ConfigureProjectPullMirror_Call) Return(_a0 *gitlab.ProjectPullMirrorDetails, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_ConfigureProjectPullMirror_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_ConfigureProjectPullMirror_Call) RunAndReturn(run func(interface{}, *gitlab.ConfigureProjectPullMirrorOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectPullMirrorDetails, *gitlab.Response, error)) *ProjectsServiceInterface_ConfigureProjectPullMirror_Call {
	_c.Call.Return(run)
	return _c
}

// CreateProject provides a mock function with given fields: opt, options
func (_m *ProjectsServiceInterface) CreateProject(opt *gitlab.CreateProjectOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateProject")
	}

	var r0 *gitlab.Project
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(*gitlab.CreateProjectOptions, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)); ok {
		return rf(opt, options...)
	}
	if rf, ok := ret.Get(0).(func(*gitlab.CreateProjectOptions, ...gitlab.RequestOptionFunc) *gitlab.Project); ok {
		r0 = rf(opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(*gitlab.CreateProjectOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(*gitlab.CreateProjectOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_CreateProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateProject'
type ProjectsServiceInterface_CreateProject_Call struct {
	*mock.Call
}

// CreateProject is a helper method to define mock.On call
//   - opt *gitlab.CreateProjectOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) CreateProject(opt interface{}, options ...interface{}) *ProjectsServiceInterface_CreateProject_Call {
	return &ProjectsServiceInterface_CreateProject_Call{Call: _e.mock.On("CreateProject",
		append([]interface{}{opt}, options...)...)}
}

func (_c *ProjectsServiceInterface_CreateProject_Call) Run(run func(opt *gitlab.CreateProjectOptions, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_CreateProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(*gitlab.CreateProjectOptions), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_CreateProject_Call) Return(_a0 *gitlab.Project, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_CreateProject_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_CreateProject_Call) RunAndReturn(run func(*gitlab.CreateProjectOptions, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *ProjectsServiceInterface_CreateProject_Call {
	_c.Call.Return(run)
	return _c
}

// CreateProjectApprovalRule provides a mock function with given fields: pid, opt, options
func (_m *ProjectsServiceInterface) CreateProjectApprovalRule(pid interface{}, opt *gitlab.CreateProjectLevelRuleOptions, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovalRule, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateProjectApprovalRule")
	}

	var r0 *gitlab.ProjectApprovalRule
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.CreateProjectLevelRuleOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovalRule, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.CreateProjectLevelRuleOptions, ...gitlab.RequestOptionFunc) *gitlab.ProjectApprovalRule); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.ProjectApprovalRule)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.CreateProjectLevelRuleOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.CreateProjectLevelRuleOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_CreateProjectApprovalRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateProjectApprovalRule'
type ProjectsServiceInterface_CreateProjectApprovalRule_Call struct {
	*mock.Call
}

// CreateProjectApprovalRule is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.CreateProjectLevelRuleOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) CreateProjectApprovalRule(pid interface{}, opt interface{}, options ...interface{}) *ProjectsServiceInterface_CreateProjectApprovalRule_Call {
	return &ProjectsServiceInterface_CreateProjectApprovalRule_Call{Call: _e.mock.On("CreateProjectApprovalRule",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ProjectsServiceInterface_CreateProjectApprovalRule_Call) Run(run func(pid interface{}, opt *gitlab.CreateProjectLevelRuleOptions, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_CreateProjectApprovalRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.CreateProjectLevelRuleOptions), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_CreateProjectApprovalRule_Call) Return(_a0 *gitlab.ProjectApprovalRule, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_CreateProjectApprovalRule_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_CreateProjectApprovalRule_Call) RunAndReturn(run func(interface{}, *gitlab.CreateProjectLevelRuleOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovalRule, *gitlab.Response, error)) *ProjectsServiceInterface_CreateProjectApprovalRule_Call {
	_c.Call.Return(run)
	return _c
}

// CreateProjectForUser provides a mock function with given fields: user, opt, options
func (_m *ProjectsServiceInterface) CreateProjectForUser(user int, opt *gitlab.CreateProjectForUserOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, user, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateProjectForUser")
	}

	var r0 *gitlab.Project
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(int, *gitlab.CreateProjectForUserOptions, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)); ok {
		return rf(user, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(int, *gitlab.CreateProjectForUserOptions, ...gitlab.RequestOptionFunc) *gitlab.Project); ok {
		r0 = rf(user, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(int, *gitlab.CreateProjectForUserOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(user, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(int, *gitlab.CreateProjectForUserOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(user, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_CreateProjectForUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateProjectForUser'
type ProjectsServiceInterface_CreateProjectForUser_Call struct {
	*mock.Call
}

// CreateProjectForUser is a helper method to define mock.On call
//   - user int
//   - opt *gitlab.CreateProjectForUserOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) CreateProjectForUser(user interface{}, opt interface{}, options ...interface{}) *ProjectsServiceInterface_CreateProjectForUser_Call {
	return &ProjectsServiceInterface_CreateProjectForUser_Call{Call: _e.mock.On("CreateProjectForUser",
		append([]interface{}{user, opt}, options...)...)}
}

func (_c *ProjectsServiceInterface_CreateProjectForUser_Call) Run(run func(user int, opt *gitlab.CreateProjectForUserOptions, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_CreateProjectForUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), args[1].(*gitlab.CreateProjectForUserOptions), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_CreateProjectForUser_Call) Return(_a0 *gitlab.Project, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_CreateProjectForUser_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_CreateProjectForUser_Call) RunAndReturn(run func(int, *gitlab.CreateProjectForUserOptions, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *ProjectsServiceInterface_CreateProjectForUser_Call {
	_c.Call.Return(run)
	return _c
}

// CreateProjectForkRelation provides a mock function with given fields: pid, fork, options
func (_m *ProjectsServiceInterface) CreateProjectForkRelation(pid interface{}, fork int, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectForkRelation, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, fork)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateProjectForkRelation")
	}

	var r0 *gitlab.ProjectForkRelation
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.ProjectForkRelation, *gitlab.Response, error)); ok {
		return rf(pid, fork, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.ProjectForkRelation); ok {
		r0 = rf(pid, fork, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.ProjectForkRelation)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, fork, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, fork, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_CreateProjectForkRelation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateProjectForkRelation'
type ProjectsServiceInterface_CreateProjectForkRelation_Call struct {
	*mock.Call
}

// CreateProjectForkRelation is a helper method to define mock.On call
//   - pid interface{}
//   - fork int
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) CreateProjectForkRelation(pid interface{}, fork interface{}, options ...interface{}) *ProjectsServiceInterface_CreateProjectForkRelation_Call {
	return &ProjectsServiceInterface_CreateProjectForkRelation_Call{Call: _e.mock.On("CreateProjectForkRelation",
		append([]interface{}{pid, fork}, options...)...)}
}

func (_c *ProjectsServiceInterface_CreateProjectForkRelation_Call) Run(run func(pid interface{}, fork int, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_CreateProjectForkRelation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_CreateProjectForkRelation_Call) Return(_a0 *gitlab.ProjectForkRelation, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_CreateProjectForkRelation_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_CreateProjectForkRelation_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.ProjectForkRelation, *gitlab.Response, error)) *ProjectsServiceInterface_CreateProjectForkRelation_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteProject provides a mock function with given fields: pid, opt, options
func (_m *ProjectsServiceInterface) DeleteProject(pid interface{}, opt *gitlab.DeleteProjectOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteProject")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.DeleteProjectOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.DeleteProjectOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.DeleteProjectOptions, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, opt, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProjectsServiceInterface_DeleteProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteProject'
type ProjectsServiceInterface_DeleteProject_Call struct {
	*mock.Call
}

// DeleteProject is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.DeleteProjectOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) DeleteProject(pid interface{}, opt interface{}, options ...interface{}) *ProjectsServiceInterface_DeleteProject_Call {
	return &ProjectsServiceInterface_DeleteProject_Call{Call: _e.mock.On("DeleteProject",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ProjectsServiceInterface_DeleteProject_Call) Run(run func(pid interface{}, opt *gitlab.DeleteProjectOptions, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_DeleteProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.DeleteProjectOptions), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_DeleteProject_Call) Return(_a0 *gitlab.Response, _a1 error) *ProjectsServiceInterface_DeleteProject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProjectsServiceInterface_DeleteProject_Call) RunAndReturn(run func(interface{}, *gitlab.DeleteProjectOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ProjectsServiceInterface_DeleteProject_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteProjectApprovalRule provides a mock function with given fields: pid, approvalRule, options
func (_m *ProjectsServiceInterface) DeleteProjectApprovalRule(pid interface{}, approvalRule int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, approvalRule)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteProjectApprovalRule")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, approvalRule, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, approvalRule, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, approvalRule, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProjectsServiceInterface_DeleteProjectApprovalRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteProjectApprovalRule'
type ProjectsServiceInterface_DeleteProjectApprovalRule_Call struct {
	*mock.Call
}

// DeleteProjectApprovalRule is a helper method to define mock.On call
//   - pid interface{}
//   - approvalRule int
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) DeleteProjectApprovalRule(pid interface{}, approvalRule interface{}, options ...interface{}) *ProjectsServiceInterface_DeleteProjectApprovalRule_Call {
	return &ProjectsServiceInterface_DeleteProjectApprovalRule_Call{Call: _e.mock.On("DeleteProjectApprovalRule",
		append([]interface{}{pid, approvalRule}, options...)...)}
}

func (_c *ProjectsServiceInterface_DeleteProjectApprovalRule_Call) Run(run func(pid interface{}, approvalRule int, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_DeleteProjectApprovalRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_DeleteProjectApprovalRule_Call) Return(_a0 *gitlab.Response, _a1 error) *ProjectsServiceInterface_DeleteProjectApprovalRule_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProjectsServiceInterface_DeleteProjectApprovalRule_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ProjectsServiceInterface_DeleteProjectApprovalRule_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteProjectCustomHeader provides a mock function with given fields: pid, hook, key, options
func (_m *ProjectsServiceInterface) DeleteProjectCustomHeader(pid interface{}, hook int, key string, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, hook, key)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteProjectCustomHeader")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, hook, key, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, hook, key, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, string, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, hook, key, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProjectsServiceInterface_DeleteProjectCustomHeader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteProjectCustomHeader'
type ProjectsServiceInterface_DeleteProjectCustomHeader_Call struct {
	*mock.Call
}

// DeleteProjectCustomHeader is a helper method to define mock.On call
//   - pid interface{}
//   - hook int
//   - key string
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) DeleteProjectCustomHeader(pid interface{}, hook interface{}, key interface{}, options ...interface{}) *ProjectsServiceInterface_DeleteProjectCustomHeader_Call {
	return &ProjectsServiceInterface_DeleteProjectCustomHeader_Call{Call: _e.mock.On("DeleteProjectCustomHeader",
		append([]interface{}{pid, hook, key}, options...)...)}
}

func (_c *ProjectsServiceInterface_DeleteProjectCustomHeader_Call) Run(run func(pid interface{}, hook int, key string, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_DeleteProjectCustomHeader_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_DeleteProjectCustomHeader_Call) Return(_a0 *gitlab.Response, _a1 error) *ProjectsServiceInterface_DeleteProjectCustomHeader_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProjectsServiceInterface_DeleteProjectCustomHeader_Call) RunAndReturn(run func(interface{}, int, string, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ProjectsServiceInterface_DeleteProjectCustomHeader_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteProjectForkRelation provides a mock function with given fields: pid, options
func (_m *ProjectsServiceInterface) DeleteProjectForkRelation(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteProjectForkRelation")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProjectsServiceInterface_DeleteProjectForkRelation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteProjectForkRelation'
type ProjectsServiceInterface_DeleteProjectForkRelation_Call struct {
	*mock.Call
}

// DeleteProjectForkRelation is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) DeleteProjectForkRelation(pid interface{}, options ...interface{}) *ProjectsServiceInterface_DeleteProjectForkRelation_Call {
	return &ProjectsServiceInterface_DeleteProjectForkRelation_Call{Call: _e.mock.On("DeleteProjectForkRelation",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ProjectsServiceInterface_DeleteProjectForkRelation_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_DeleteProjectForkRelation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_DeleteProjectForkRelation_Call) Return(_a0 *gitlab.Response, _a1 error) *ProjectsServiceInterface_DeleteProjectForkRelation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProjectsServiceInterface_DeleteProjectForkRelation_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ProjectsServiceInterface_DeleteProjectForkRelation_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteProjectHook provides a mock function with given fields: pid, hook, options
func (_m *ProjectsServiceInterface) DeleteProjectHook(pid interface{}, hook int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, hook)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteProjectHook")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, hook, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, hook, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, hook, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProjectsServiceInterface_DeleteProjectHook_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteProjectHook'
type ProjectsServiceInterface_DeleteProjectHook_Call struct {
	*mock.Call
}

// DeleteProjectHook is a helper method to define mock.On call
//   - pid interface{}
//   - hook int
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) DeleteProjectHook(pid interface{}, hook interface{}, options ...interface{}) *ProjectsServiceInterface_DeleteProjectHook_Call {
	return &ProjectsServiceInterface_DeleteProjectHook_Call{Call: _e.mock.On("DeleteProjectHook",
		append([]interface{}{pid, hook}, options...)...)}
}

func (_c *ProjectsServiceInterface_DeleteProjectHook_Call) Run(run func(pid interface{}, hook int, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_DeleteProjectHook_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_DeleteProjectHook_Call) Return(_a0 *gitlab.Response, _a1 error) *ProjectsServiceInterface_DeleteProjectHook_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProjectsServiceInterface_DeleteProjectHook_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ProjectsServiceInterface_DeleteProjectHook_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteProjectPushRule provides a mock function with given fields: pid, options
func (_m *ProjectsServiceInterface) DeleteProjectPushRule(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteProjectPushRule")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProjectsServiceInterface_DeleteProjectPushRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteProjectPushRule'
type ProjectsServiceInterface_DeleteProjectPushRule_Call struct {
	*mock.Call
}

// DeleteProjectPushRule is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) DeleteProjectPushRule(pid interface{}, options ...interface{}) *ProjectsServiceInterface_DeleteProjectPushRule_Call {
	return &ProjectsServiceInterface_DeleteProjectPushRule_Call{Call: _e.mock.On("DeleteProjectPushRule",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ProjectsServiceInterface_DeleteProjectPushRule_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_DeleteProjectPushRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_DeleteProjectPushRule_Call) Return(_a0 *gitlab.Response, _a1 error) *ProjectsServiceInterface_DeleteProjectPushRule_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProjectsServiceInterface_DeleteProjectPushRule_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ProjectsServiceInterface_DeleteProjectPushRule_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSharedProjectFromGroup provides a mock function with given fields: pid, groupID, options
func (_m *ProjectsServiceInterface) DeleteSharedProjectFromGroup(pid interface{}, groupID int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, groupID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSharedProjectFromGroup")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, groupID, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, groupID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, groupID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProjectsServiceInterface_DeleteSharedProjectFromGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSharedProjectFromGroup'
type ProjectsServiceInterface_DeleteSharedProjectFromGroup_Call struct {
	*mock.Call
}

// DeleteSharedProjectFromGroup is a helper method to define mock.On call
//   - pid interface{}
//   - groupID int
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) DeleteSharedProjectFromGroup(pid interface{}, groupID interface{}, options ...interface{}) *ProjectsServiceInterface_DeleteSharedProjectFromGroup_Call {
	return &ProjectsServiceInterface_DeleteSharedProjectFromGroup_Call{Call: _e.mock.On("DeleteSharedProjectFromGroup",
		append([]interface{}{pid, groupID}, options...)...)}
}

func (_c *ProjectsServiceInterface_DeleteSharedProjectFromGroup_Call) Run(run func(pid interface{}, groupID int, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_DeleteSharedProjectFromGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_DeleteSharedProjectFromGroup_Call) Return(_a0 *gitlab.Response, _a1 error) *ProjectsServiceInterface_DeleteSharedProjectFromGroup_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProjectsServiceInterface_DeleteSharedProjectFromGroup_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ProjectsServiceInterface_DeleteSharedProjectFromGroup_Call {
	_c.Call.Return(run)
	return _c
}

// DownloadAvatar provides a mock function with given fields: pid, options
func (_m *ProjectsServiceInterface) DownloadAvatar(pid interface{}, options ...gitlab.RequestOptionFunc) (*bytes.Reader, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DownloadAvatar")
	}

	var r0 *bytes.Reader
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*bytes.Reader, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *bytes.Reader); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bytes.Reader)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_DownloadAvatar_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DownloadAvatar'
type ProjectsServiceInterface_DownloadAvatar_Call struct {
	*mock.Call
}

// DownloadAvatar is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) DownloadAvatar(pid interface{}, options ...interface{}) *ProjectsServiceInterface_DownloadAvatar_Call {
	return &ProjectsServiceInterface_DownloadAvatar_Call{Call: _e.mock.On("DownloadAvatar",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ProjectsServiceInterface_DownloadAvatar_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_DownloadAvatar_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_DownloadAvatar_Call) Return(_a0 *bytes.Reader, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_DownloadAvatar_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_DownloadAvatar_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*bytes.Reader, *gitlab.Response, error)) *ProjectsServiceInterface_DownloadAvatar_Call {
	_c.Call.Return(run)
	return _c
}

// EditProject provides a mock function with given fields: pid, opt, options
func (_m *ProjectsServiceInterface) EditProject(pid interface{}, opt *gitlab.EditProjectOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EditProject")
	}

	var r0 *gitlab.Project
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.EditProjectOptions, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.EditProjectOptions, ...gitlab.RequestOptionFunc) *gitlab.Project); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.EditProjectOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.EditProjectOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_EditProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EditProject'
type ProjectsServiceInterface_EditProject_Call struct {
	*mock.Call
}

// EditProject is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.EditProjectOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) EditProject(pid interface{}, opt interface{}, options ...interface{}) *ProjectsServiceInterface_EditProject_Call {
	return &ProjectsServiceInterface_EditProject_Call{Call: _e.mock.On("EditProject",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ProjectsServiceInterface_EditProject_Call) Run(run func(pid interface{}, opt *gitlab.EditProjectOptions, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_EditProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.EditProjectOptions), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_EditProject_Call) Return(_a0 *gitlab.Project, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_EditProject_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_EditProject_Call) RunAndReturn(run func(interface{}, *gitlab.EditProjectOptions, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *ProjectsServiceInterface_EditProject_Call {
	_c.Call.Return(run)
	return _c
}

// EditProjectHook provides a mock function with given fields: pid, hook, opt, options
func (_m *ProjectsServiceInterface) EditProjectHook(pid interface{}, hook int, opt *gitlab.EditProjectHookOptions, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectHook, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, hook, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EditProjectHook")
	}

	var r0 *gitlab.ProjectHook
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.EditProjectHookOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectHook, *gitlab.Response, error)); ok {
		return rf(pid, hook, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.EditProjectHookOptions, ...gitlab.RequestOptionFunc) *gitlab.ProjectHook); ok {
		r0 = rf(pid, hook, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.ProjectHook)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.EditProjectHookOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, hook, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.EditProjectHookOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, hook, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_EditProjectHook_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EditProjectHook'
type ProjectsServiceInterface_EditProjectHook_Call struct {
	*mock.Call
}

// EditProjectHook is a helper method to define mock.On call
//   - pid interface{}
//   - hook int
//   - opt *gitlab.EditProjectHookOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) EditProjectHook(pid interface{}, hook interface{}, opt interface{}, options ...interface{}) *ProjectsServiceInterface_EditProjectHook_Call {
	return &ProjectsServiceInterface_EditProjectHook_Call{Call: _e.mock.On("EditProjectHook",
		append([]interface{}{pid, hook, opt}, options...)...)}
}

func (_c *ProjectsServiceInterface_EditProjectHook_Call) Run(run func(pid interface{}, hook int, opt *gitlab.EditProjectHookOptions, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_EditProjectHook_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.EditProjectHookOptions), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_EditProjectHook_Call) Return(_a0 *gitlab.ProjectHook, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_EditProjectHook_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_EditProjectHook_Call) RunAndReturn(run func(interface{}, int, *gitlab.EditProjectHookOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectHook, *gitlab.Response, error)) *ProjectsServiceInterface_EditProjectHook_Call {
	_c.Call.Return(run)
	return _c
}

// EditProjectPushRule provides a mock function with given fields: pid, opt, options
func (_m *ProjectsServiceInterface) EditProjectPushRule(pid interface{}, opt *gitlab.EditProjectPushRuleOptions, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectPushRules, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EditProjectPushRule")
	}

	var r0 *gitlab.ProjectPushRules
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.EditProjectPushRuleOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectPushRules, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.EditProjectPushRuleOptions, ...gitlab.RequestOptionFunc) *gitlab.ProjectPushRules); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.ProjectPushRules)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.EditProjectPushRuleOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.EditProjectPushRuleOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_EditProjectPushRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EditProjectPushRule'
type ProjectsServiceInterface_EditProjectPushRule_Call struct {
	*mock.Call
}

// EditProjectPushRule is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.EditProjectPushRuleOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) EditProjectPushRule(pid interface{}, opt interface{}, options ...interface{}) *ProjectsServiceInterface_EditProjectPushRule_Call {
	return &ProjectsServiceInterface_EditProjectPushRule_Call{Call: _e.mock.On("EditProjectPushRule",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ProjectsServiceInterface_EditProjectPushRule_Call) Run(run func(pid interface{}, opt *gitlab.EditProjectPushRuleOptions, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_EditProjectPushRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.EditProjectPushRuleOptions), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_EditProjectPushRule_Call) Return(_a0 *gitlab.ProjectPushRules, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_EditProjectPushRule_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_EditProjectPushRule_Call) RunAndReturn(run func(interface{}, *gitlab.EditProjectPushRuleOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectPushRules, *gitlab.Response, error)) *ProjectsServiceInterface_EditProjectPushRule_Call {
	_c.Call.Return(run)
	return _c
}

// ForkProject provides a mock function with given fields: pid, opt, options
func (_m *ProjectsServiceInterface) ForkProject(pid interface{}, opt *gitlab.ForkProjectOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ForkProject")
	}

	var r0 *gitlab.Project
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ForkProjectOptions, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ForkProjectOptions, ...gitlab.RequestOptionFunc) *gitlab.Project); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ForkProjectOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ForkProjectOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_ForkProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ForkProject'
type ProjectsServiceInterface_ForkProject_Call struct {
	*mock.Call
}

// ForkProject is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.ForkProjectOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) ForkProject(pid interface{}, opt interface{}, options ...interface{}) *ProjectsServiceInterface_ForkProject_Call {
	return &ProjectsServiceInterface_ForkProject_Call{Call: _e.mock.On("ForkProject",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ProjectsServiceInterface_ForkProject_Call) Run(run func(pid interface{}, opt *gitlab.ForkProjectOptions, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_ForkProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ForkProjectOptions), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_ForkProject_Call) Return(_a0 *gitlab.Project, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_ForkProject_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_ForkProject_Call) RunAndReturn(run func(interface{}, *gitlab.ForkProjectOptions, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *ProjectsServiceInterface_ForkProject_Call {
	_c.Call.Return(run)
	return _c
}

// GetApprovalConfiguration provides a mock function with given fields: pid, options
func (_m *ProjectsServiceInterface) GetApprovalConfiguration(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovals, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetApprovalConfiguration")
	}

	var r0 *gitlab.ProjectApprovals
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovals, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.ProjectApprovals); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.ProjectApprovals)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_GetApprovalConfiguration_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetApprovalConfiguration'
type ProjectsServiceInterface_GetApprovalConfiguration_Call struct {
	*mock.Call
}

// GetApprovalConfiguration is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) GetApprovalConfiguration(pid interface{}, options ...interface{}) *ProjectsServiceInterface_GetApprovalConfiguration_Call {
	return &ProjectsServiceInterface_GetApprovalConfiguration_Call{Call: _e.mock.On("GetApprovalConfiguration",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ProjectsServiceInterface_GetApprovalConfiguration_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_GetApprovalConfiguration_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_GetApprovalConfiguration_Call) Return(_a0 *gitlab.ProjectApprovals, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_GetApprovalConfiguration_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_GetApprovalConfiguration_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovals, *gitlab.Response, error)) *ProjectsServiceInterface_GetApprovalConfiguration_Call {
	_c.Call.Return(run)
	return _c
}

// GetProject provides a mock function with given fields: pid, opt, options
func (_m *ProjectsServiceInterface) GetProject(pid interface{}, opt *gitlab.GetProjectOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetProject")
	}

	var r0 *gitlab.Project
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.GetProjectOptions, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.GetProjectOptions, ...gitlab.RequestOptionFunc) *gitlab.Project); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.GetProjectOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.GetProjectOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_GetProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProject'
type ProjectsServiceInterface_GetProject_Call struct {
	*mock.Call
}

// GetProject is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.GetProjectOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) GetProject(pid interface{}, opt interface{}, options ...interface{}) *ProjectsServiceInterface_GetProject_Call {
	return &ProjectsServiceInterface_GetProject_Call{Call: _e.mock.On("GetProject",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ProjectsServiceInterface_GetProject_Call) Run(run func(pid interface{}, opt *gitlab.GetProjectOptions, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_GetProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.GetProjectOptions), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_GetProject_Call) Return(_a0 *gitlab.Project, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_GetProject_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_GetProject_Call) RunAndReturn(run func(interface{}, *gitlab.GetProjectOptions, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *ProjectsServiceInterface_GetProject_Call {
	_c.Call.Return(run)
	return _c
}

// GetProjectApprovalRule provides a mock function with given fields: pid, ruleID, options
func (_m *ProjectsServiceInterface) GetProjectApprovalRule(pid interface{}, ruleID int, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovalRule, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, ruleID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetProjectApprovalRule")
	}

	var r0 *gitlab.ProjectApprovalRule
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovalRule, *gitlab.Response, error)); ok {
		return rf(pid, ruleID, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.ProjectApprovalRule); ok {
		r0 = rf(pid, ruleID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.ProjectApprovalRule)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, ruleID, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, ruleID, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_GetProjectApprovalRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProjectApprovalRule'
type ProjectsServiceInterface_GetProjectApprovalRule_Call struct {
	*mock.Call
}

// GetProjectApprovalRule is a helper method to define mock.On call
//   - pid interface{}
//   - ruleID int
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) GetProjectApprovalRule(pid interface{}, ruleID interface{}, options ...interface{}) *ProjectsServiceInterface_GetProjectApprovalRule_Call {
	return &ProjectsServiceInterface_GetProjectApprovalRule_Call{Call: _e.mock.On("GetProjectApprovalRule",
		append([]interface{}{pid, ruleID}, options...)...)}
}

func (_c *ProjectsServiceInterface_GetProjectApprovalRule_Call) Run(run func(pid interface{}, ruleID int, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_GetProjectApprovalRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_GetProjectApprovalRule_Call) Return(_a0 *gitlab.ProjectApprovalRule, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_GetProjectApprovalRule_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_GetProjectApprovalRule_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovalRule, *gitlab.Response, error)) *ProjectsServiceInterface_GetProjectApprovalRule_Call {
	_c.Call.Return(run)
	return _c
}

// GetProjectApprovalRules provides a mock function with given fields: pid, opt, options
func (_m *ProjectsServiceInterface) GetProjectApprovalRules(pid interface{}, opt *gitlab.GetProjectApprovalRulesListsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectApprovalRule, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetProjectApprovalRules")
	}

	var r0 []*gitlab.ProjectApprovalRule
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.GetProjectApprovalRulesListsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectApprovalRule, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.GetProjectApprovalRulesListsOptions, ...gitlab.RequestOptionFunc) []*gitlab.ProjectApprovalRule); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.ProjectApprovalRule)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.GetProjectApprovalRulesListsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.GetProjectApprovalRulesListsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_GetProjectApprovalRules_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProjectApprovalRules'
type ProjectsServiceInterface_GetProjectApprovalRules_Call struct {
	*mock.Call
}

// GetProjectApprovalRules is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.GetProjectApprovalRulesListsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) GetProjectApprovalRules(pid interface{}, opt interface{}, options ...interface{}) *ProjectsServiceInterface_GetProjectApprovalRules_Call {
	return &ProjectsServiceInterface_GetProjectApprovalRules_Call{Call: _e.mock.On("GetProjectApprovalRules",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ProjectsServiceInterface_GetProjectApprovalRules_Call) Run(run func(pid interface{}, opt *gitlab.GetProjectApprovalRulesListsOptions, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_GetProjectApprovalRules_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.GetProjectApprovalRulesListsOptions), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_GetProjectApprovalRules_Call) Return(_a0 []*gitlab.ProjectApprovalRule, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_GetProjectApprovalRules_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_GetProjectApprovalRules_Call) RunAndReturn(run func(interface{}, *gitlab.GetProjectApprovalRulesListsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectApprovalRule, *gitlab.Response, error)) *ProjectsServiceInterface_GetProjectApprovalRules_Call {
	_c.Call.Return(run)
	return _c
}

// GetProjectHook provides a mock function with given fields: pid, hook, options
func (_m *ProjectsServiceInterface) GetProjectHook(pid interface{}, hook int, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectHook, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, hook)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetProjectHook")
	}

	var r0 *gitlab.ProjectHook
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.ProjectHook, *gitlab.Response, error)); ok {
		return rf(pid, hook, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.ProjectHook); ok {
		r0 = rf(pid, hook, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.ProjectHook)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, hook, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, hook, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_GetProjectHook_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProjectHook'
type ProjectsServiceInterface_GetProjectHook_Call struct {
	*mock.Call
}

// GetProjectHook is a helper method to define mock.On call
//   - pid interface{}
//   - hook int
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) GetProjectHook(pid interface{}, hook interface{}, options ...interface{}) *ProjectsServiceInterface_GetProjectHook_Call {
	return &ProjectsServiceInterface_GetProjectHook_Call{Call: _e.mock.On("GetProjectHook",
		append([]interface{}{pid, hook}, options...)...)}
}

func (_c *ProjectsServiceInterface_GetProjectHook_Call) Run(run func(pid interface{}, hook int, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_GetProjectHook_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_GetProjectHook_Call) Return(_a0 *gitlab.ProjectHook, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_GetProjectHook_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_GetProjectHook_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.ProjectHook, *gitlab.Response, error)) *ProjectsServiceInterface_GetProjectHook_Call {
	_c.Call.Return(run)
	return _c
}

// GetProjectLanguages provides a mock function with given fields: pid, options
func (_m *ProjectsServiceInterface) GetProjectLanguages(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectLanguages, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetProjectLanguages")
	}

	var r0 *gitlab.ProjectLanguages
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.ProjectLanguages, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.ProjectLanguages); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.ProjectLanguages)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_GetProjectLanguages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProjectLanguages'
type ProjectsServiceInterface_GetProjectLanguages_Call struct {
	*mock.Call
}

// GetProjectLanguages is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) GetProjectLanguages(pid interface{}, options ...interface{}) *ProjectsServiceInterface_GetProjectLanguages_Call {
	return &ProjectsServiceInterface_GetProjectLanguages_Call{Call: _e.mock.On("GetProjectLanguages",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ProjectsServiceInterface_GetProjectLanguages_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_GetProjectLanguages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_GetProjectLanguages_Call) Return(_a0 *gitlab.ProjectLanguages, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_GetProjectLanguages_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_GetProjectLanguages_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.ProjectLanguages, *gitlab.Response, error)) *ProjectsServiceInterface_GetProjectLanguages_Call {
	_c.Call.Return(run)
	return _c
}

// GetProjectPullMirrorDetails provides a mock function with given fields: pid, options
func (_m *ProjectsServiceInterface) GetProjectPullMirrorDetails(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectPullMirrorDetails, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetProjectPullMirrorDetails")
	}

	var r0 *gitlab.ProjectPullMirrorDetails
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.ProjectPullMirrorDetails, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.ProjectPullMirrorDetails); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.ProjectPullMirrorDetails)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_GetProjectPullMirrorDetails_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProjectPullMirrorDetails'
type ProjectsServiceInterface_GetProjectPullMirrorDetails_Call struct {
	*mock.Call
}

// GetProjectPullMirrorDetails is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) GetProjectPullMirrorDetails(pid interface{}, options ...interface{}) *ProjectsServiceInterface_GetProjectPullMirrorDetails_Call {
	return &ProjectsServiceInterface_GetProjectPullMirrorDetails_Call{Call: _e.mock.On("GetProjectPullMirrorDetails",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ProjectsServiceInterface_GetProjectPullMirrorDetails_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_GetProjectPullMirrorDetails_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_GetProjectPullMirrorDetails_Call) Return(_a0 *gitlab.ProjectPullMirrorDetails, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_GetProjectPullMirrorDetails_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_GetProjectPullMirrorDetails_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.ProjectPullMirrorDetails, *gitlab.Response, error)) *ProjectsServiceInterface_GetProjectPullMirrorDetails_Call {
	_c.Call.Return(run)
	return _c
}

// GetProjectPushRules provides a mock function with given fields: pid, options
func (_m *ProjectsServiceInterface) GetProjectPushRules(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectPushRules, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetProjectPushRules")
	}

	var r0 *gitlab.ProjectPushRules
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.ProjectPushRules, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.ProjectPushRules); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.ProjectPushRules)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_GetProjectPushRules_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProjectPushRules'
type ProjectsServiceInterface_GetProjectPushRules_Call struct {
	*mock.Call
}

// GetProjectPushRules is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) GetProjectPushRules(pid interface{}, options ...interface{}) *ProjectsServiceInterface_GetProjectPushRules_Call {
	return &ProjectsServiceInterface_GetProjectPushRules_Call{Call: _e.mock.On("GetProjectPushRules",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ProjectsServiceInterface_GetProjectPushRules_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_GetProjectPushRules_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_GetProjectPushRules_Call) Return(_a0 *gitlab.ProjectPushRules, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_GetProjectPushRules_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_GetProjectPushRules_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.ProjectPushRules, *gitlab.Response, error)) *ProjectsServiceInterface_GetProjectPushRules_Call {
	_c.Call.Return(run)
	return _c
}

// GetRepositoryStorage provides a mock function with given fields: pid, options
func (_m *ProjectsServiceInterface) GetRepositoryStorage(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectReposityStorage, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRepositoryStorage")
	}

	var r0 *gitlab.ProjectReposityStorage
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.ProjectReposityStorage, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.ProjectReposityStorage); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.ProjectReposityStorage)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_GetRepositoryStorage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRepositoryStorage'
type ProjectsServiceInterface_GetRepositoryStorage_Call struct {
	*mock.Call
}

// GetRepositoryStorage is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) GetRepositoryStorage(pid interface{}, options ...interface{}) *ProjectsServiceInterface_GetRepositoryStorage_Call {
	return &ProjectsServiceInterface_GetRepositoryStorage_Call{Call: _e.mock.On("GetRepositoryStorage",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ProjectsServiceInterface_GetRepositoryStorage_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_GetRepositoryStorage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_GetRepositoryStorage_Call) Return(_a0 *gitlab.ProjectReposityStorage, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_GetRepositoryStorage_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_GetRepositoryStorage_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.ProjectReposityStorage, *gitlab.Response, error)) *ProjectsServiceInterface_GetRepositoryStorage_Call {
	_c.Call.Return(run)
	return _c
}

// ListProjectForks provides a mock function with given fields: pid, opt, options
func (_m *ProjectsServiceInterface) ListProjectForks(pid interface{}, opt *gitlab.ListProjectsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListProjectForks")
	}

	var r0 []*gitlab.Project
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) []*gitlab.Project); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_ListProjectForks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListProjectForks'
type ProjectsServiceInterface_ListProjectForks_Call struct {
	*mock.Call
}

// ListProjectForks is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.ListProjectsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) ListProjectForks(pid interface{}, opt interface{}, options ...interface{}) *ProjectsServiceInterface_ListProjectForks_Call {
	return &ProjectsServiceInterface_ListProjectForks_Call{Call: _e.mock.On("ListProjectForks",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ProjectsServiceInterface_ListProjectForks_Call) Run(run func(pid interface{}, opt *gitlab.ListProjectsOptions, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_ListProjectForks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListProjectsOptions), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_ListProjectForks_Call) Return(_a0 []*gitlab.Project, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_ListProjectForks_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_ListProjectForks_Call) RunAndReturn(run func(interface{}, *gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)) *ProjectsServiceInterface_ListProjectForks_Call {
	_c.Call.Return(run)
	return _c
}

// ListProjectHooks provides a mock function with given fields: pid, opt, options
func (_m *ProjectsServiceInterface) ListProjectHooks(pid interface{}, opt *gitlab.ListProjectHooksOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectHook, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListProjectHooks")
	}

	var r0 []*gitlab.ProjectHook
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListProjectHooksOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectHook, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListProjectHooksOptions, ...gitlab.RequestOptionFunc) []*gitlab.ProjectHook); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.ProjectHook)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListProjectHooksOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListProjectHooksOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_ListProjectHooks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListProjectHooks'
type ProjectsServiceInterface_ListProjectHooks_Call struct {
	*mock.Call
}

// ListProjectHooks is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.ListProjectHooksOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) ListProjectHooks(pid interface{}, opt interface{}, options ...interface{}) *ProjectsServiceInterface_ListProjectHooks_Call {
	return &ProjectsServiceInterface_ListProjectHooks_Call{Call: _e.mock.On("ListProjectHooks",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ProjectsServiceInterface_ListProjectHooks_Call) Run(run func(pid interface{}, opt *gitlab.ListProjectHooksOptions, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_ListProjectHooks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListProjectHooksOptions), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_ListProjectHooks_Call) Return(_a0 []*gitlab.ProjectHook, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_ListProjectHooks_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_ListProjectHooks_Call) RunAndReturn(run func(interface{}, *gitlab.ListProjectHooksOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectHook, *gitlab.Response, error)) *ProjectsServiceInterface_ListProjectHooks_Call {
	_c.Call.Return(run)
	return _c
}

// ListProjects provides a mock function with given fields: opt, options
func (_m *ProjectsServiceInterface) ListProjects(opt *gitlab.ListProjectsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListProjects")
	}

	var r0 []*gitlab.Project
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(*gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)); ok {
		return rf(opt, options...)
	}
	if rf, ok := ret.Get(0).(func(*gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) []*gitlab.Project); ok {
		r0 = rf(opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(*gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(*gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_ListProjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListProjects'
type ProjectsServiceInterface_ListProjects_Call struct {
	*mock.Call
}

// ListProjects is a helper method to define mock.On call
//   - opt *gitlab.ListProjectsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) ListProjects(opt interface{}, options ...interface{}) *ProjectsServiceInterface_ListProjects_Call {
	return &ProjectsServiceInterface_ListProjects_Call{Call: _e.mock.On("ListProjects",
		append([]interface{}{opt}, options...)...)}
}

func (_c *ProjectsServiceInterface_ListProjects_Call) Run(run func(opt *gitlab.ListProjectsOptions, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_ListProjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(*gitlab.ListProjectsOptions), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_ListProjects_Call) Return(_a0 []*gitlab.Project, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_ListProjects_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_ListProjects_Call) RunAndReturn(run func(*gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)) *ProjectsServiceInterface_ListProjects_Call {
	_c.Call.Return(run)
	return _c
}

// ListProjectsGroups provides a mock function with given fields: pid, opt, options
func (_m *ProjectsServiceInterface) ListProjectsGroups(pid interface{}, opt *gitlab.ListProjectGroupOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectGroup, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListProjectsGroups")
	}

	var r0 []*gitlab.ProjectGroup
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListProjectGroupOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectGroup, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListProjectGroupOptions, ...gitlab.RequestOptionFunc) []*gitlab.ProjectGroup); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.ProjectGroup)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListProjectGroupOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListProjectGroupOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_ListProjectsGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListProjectsGroups'
type ProjectsServiceInterface_ListProjectsGroups_Call struct {
	*mock.Call
}

// ListProjectsGroups is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.ListProjectGroupOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) ListProjectsGroups(pid interface{}, opt interface{}, options ...interface{}) *ProjectsServiceInterface_ListProjectsGroups_Call {
	return &ProjectsServiceInterface_ListProjectsGroups_Call{Call: _e.mock.On("ListProjectsGroups",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ProjectsServiceInterface_ListProjectsGroups_Call) Run(run func(pid interface{}, opt *gitlab.ListProjectGroupOptions, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_ListProjectsGroups_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListProjectGroupOptions), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_ListProjectsGroups_Call) Return(_a0 []*gitlab.ProjectGroup, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_ListProjectsGroups_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_ListProjectsGroups_Call) RunAndReturn(run func(interface{}, *gitlab.ListProjectGroupOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectGroup, *gitlab.Response, error)) *ProjectsServiceInterface_ListProjectsGroups_Call {
	_c.Call.Return(run)
	return _c
}

// ListProjectsInvitedGroups provides a mock function with given fields: pid, opt, options
func (_m *ProjectsServiceInterface) ListProjectsInvitedGroups(pid interface{}, opt *gitlab.ListProjectInvidedGroupOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectGroup, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListProjectsInvitedGroups")
	}

	var r0 []*gitlab.ProjectGroup
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListProjectInvidedGroupOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectGroup, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListProjectInvidedGroupOptions, ...gitlab.RequestOptionFunc) []*gitlab.ProjectGroup); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.ProjectGroup)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListProjectInvidedGroupOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListProjectInvidedGroupOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_ListProjectsInvitedGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListProjectsInvitedGroups'
type ProjectsServiceInterface_ListProjectsInvitedGroups_Call struct {
	*mock.Call
}

// ListProjectsInvitedGroups is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.ListProjectInvidedGroupOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) ListProjectsInvitedGroups(pid interface{}, opt interface{}, options ...interface{}) *ProjectsServiceInterface_ListProjectsInvitedGroups_Call {
	return &ProjectsServiceInterface_ListProjectsInvitedGroups_Call{Call: _e.mock.On("ListProjectsInvitedGroups",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ProjectsServiceInterface_ListProjectsInvitedGroups_Call) Run(run func(pid interface{}, opt *gitlab.ListProjectInvidedGroupOptions, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_ListProjectsInvitedGroups_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListProjectInvidedGroupOptions), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_ListProjectsInvitedGroups_Call) Return(_a0 []*gitlab.ProjectGroup, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_ListProjectsInvitedGroups_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_ListProjectsInvitedGroups_Call) RunAndReturn(run func(interface{}, *gitlab.ListProjectInvidedGroupOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectGroup, *gitlab.Response, error)) *ProjectsServiceInterface_ListProjectsInvitedGroups_Call {
	_c.Call.Return(run)
	return _c
}

// ListProjectsUsers provides a mock function with given fields: pid, opt, options
func (_m *ProjectsServiceInterface) ListProjectsUsers(pid interface{}, opt *gitlab.ListProjectUserOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectUser, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListProjectsUsers")
	}

	var r0 []*gitlab.ProjectUser
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListProjectUserOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectUser, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListProjectUserOptions, ...gitlab.RequestOptionFunc) []*gitlab.ProjectUser); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.ProjectUser)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListProjectUserOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListProjectUserOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_ListProjectsUsers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListProjectsUsers'
type ProjectsServiceInterface_ListProjectsUsers_Call struct {
	*mock.Call
}

// ListProjectsUsers is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.ListProjectUserOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) ListProjectsUsers(pid interface{}, opt interface{}, options ...interface{}) *ProjectsServiceInterface_ListProjectsUsers_Call {
	return &ProjectsServiceInterface_ListProjectsUsers_Call{Call: _e.mock.On("ListProjectsUsers",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ProjectsServiceInterface_ListProjectsUsers_Call) Run(run func(pid interface{}, opt *gitlab.ListProjectUserOptions, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_ListProjectsUsers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListProjectUserOptions), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_ListProjectsUsers_Call) Return(_a0 []*gitlab.ProjectUser, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_ListProjectsUsers_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_ListProjectsUsers_Call) RunAndReturn(run func(interface{}, *gitlab.ListProjectUserOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.ProjectUser, *gitlab.Response, error)) *ProjectsServiceInterface_ListProjectsUsers_Call {
	_c.Call.Return(run)
	return _c
}

// ListUserContributedProjects provides a mock function with given fields: uid, opt, options
func (_m *ProjectsServiceInterface) ListUserContributedProjects(uid interface{}, opt *gitlab.ListProjectsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, uid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListUserContributedProjects")
	}

	var r0 []*gitlab.Project
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)); ok {
		return rf(uid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) []*gitlab.Project); ok {
		r0 = rf(uid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(uid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(uid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_ListUserContributedProjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListUserContributedProjects'
type ProjectsServiceInterface_ListUserContributedProjects_Call struct {
	*mock.Call
}

// ListUserContributedProjects is a helper method to define mock.On call
//   - uid interface{}
//   - opt *gitlab.ListProjectsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) ListUserContributedProjects(uid interface{}, opt interface{}, options ...interface{}) *ProjectsServiceInterface_ListUserContributedProjects_Call {
	return &ProjectsServiceInterface_ListUserContributedProjects_Call{Call: _e.mock.On("ListUserContributedProjects",
		append([]interface{}{uid, opt}, options...)...)}
}

func (_c *ProjectsServiceInterface_ListUserContributedProjects_Call) Run(run func(uid interface{}, opt *gitlab.ListProjectsOptions, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_ListUserContributedProjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListProjectsOptions), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_ListUserContributedProjects_Call) Return(_a0 []*gitlab.Project, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_ListUserContributedProjects_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_ListUserContributedProjects_Call) RunAndReturn(run func(interface{}, *gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)) *ProjectsServiceInterface_ListUserContributedProjects_Call {
	_c.Call.Return(run)
	return _c
}

// ListUserProjects provides a mock function with given fields: uid, opt, options
func (_m *ProjectsServiceInterface) ListUserProjects(uid interface{}, opt *gitlab.ListProjectsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, uid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListUserProjects")
	}

	var r0 []*gitlab.Project
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)); ok {
		return rf(uid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) []*gitlab.Project); ok {
		r0 = rf(uid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(uid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(uid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_ListUserProjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListUserProjects'
type ProjectsServiceInterface_ListUserProjects_Call struct {
	*mock.Call
}

// ListUserProjects is a helper method to define mock.On call
//   - uid interface{}
//   - opt *gitlab.ListProjectsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) ListUserProjects(uid interface{}, opt interface{}, options ...interface{}) *ProjectsServiceInterface_ListUserProjects_Call {
	return &ProjectsServiceInterface_ListUserProjects_Call{Call: _e.mock.On("ListUserProjects",
		append([]interface{}{uid, opt}, options...)...)}
}

func (_c *ProjectsServiceInterface_ListUserProjects_Call) Run(run func(uid interface{}, opt *gitlab.ListProjectsOptions, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_ListUserProjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListProjectsOptions), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_ListUserProjects_Call) Return(_a0 []*gitlab.Project, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_ListUserProjects_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_ListUserProjects_Call) RunAndReturn(run func(interface{}, *gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)) *ProjectsServiceInterface_ListUserProjects_Call {
	_c.Call.Return(run)
	return _c
}

// ListUserStarredProjects provides a mock function with given fields: uid, opt, options
func (_m *ProjectsServiceInterface) ListUserStarredProjects(uid interface{}, opt *gitlab.ListProjectsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, uid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListUserStarredProjects")
	}

	var r0 []*gitlab.Project
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)); ok {
		return rf(uid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) []*gitlab.Project); ok {
		r0 = rf(uid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(uid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(uid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_ListUserStarredProjects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListUserStarredProjects'
type ProjectsServiceInterface_ListUserStarredProjects_Call struct {
	*mock.Call
}

// ListUserStarredProjects is a helper method to define mock.On call
//   - uid interface{}
//   - opt *gitlab.ListProjectsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) ListUserStarredProjects(uid interface{}, opt interface{}, options ...interface{}) *ProjectsServiceInterface_ListUserStarredProjects_Call {
	return &ProjectsServiceInterface_ListUserStarredProjects_Call{Call: _e.mock.On("ListUserStarredProjects",
		append([]interface{}{uid, opt}, options...)...)}
}

func (_c *ProjectsServiceInterface_ListUserStarredProjects_Call) Run(run func(uid interface{}, opt *gitlab.ListProjectsOptions, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_ListUserStarredProjects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListProjectsOptions), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_ListUserStarredProjects_Call) Return(_a0 []*gitlab.Project, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_ListUserStarredProjects_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_ListUserStarredProjects_Call) RunAndReturn(run func(interface{}, *gitlab.ListProjectsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)) *ProjectsServiceInterface_ListUserStarredProjects_Call {
	_c.Call.Return(run)
	return _c
}

// SetProjectCustomHeader provides a mock function with given fields: pid, hook, key, opt, options
func (_m *ProjectsServiceInterface) SetProjectCustomHeader(pid interface{}, hook int, key string, opt *gitlab.SetHookCustomHeaderOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, hook, key, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetProjectCustomHeader")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, string, *gitlab.SetHookCustomHeaderOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, hook, key, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, string, *gitlab.SetHookCustomHeaderOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, hook, key, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, string, *gitlab.SetHookCustomHeaderOptions, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, hook, key, opt, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProjectsServiceInterface_SetProjectCustomHeader_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetProjectCustomHeader'
type ProjectsServiceInterface_SetProjectCustomHeader_Call struct {
	*mock.Call
}

// SetProjectCustomHeader is a helper method to define mock.On call
//   - pid interface{}
//   - hook int
//   - key string
//   - opt *gitlab.SetHookCustomHeaderOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) SetProjectCustomHeader(pid interface{}, hook interface{}, key interface{}, opt interface{}, options ...interface{}) *ProjectsServiceInterface_SetProjectCustomHeader_Call {
	return &ProjectsServiceInterface_SetProjectCustomHeader_Call{Call: _e.mock.On("SetProjectCustomHeader",
		append([]interface{}{pid, hook, key, opt}, options...)...)}
}

func (_c *ProjectsServiceInterface_SetProjectCustomHeader_Call) Run(run func(pid interface{}, hook int, key string, opt *gitlab.SetHookCustomHeaderOptions, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_SetProjectCustomHeader_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(string), args[3].(*gitlab.SetHookCustomHeaderOptions), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_SetProjectCustomHeader_Call) Return(_a0 *gitlab.Response, _a1 error) *ProjectsServiceInterface_SetProjectCustomHeader_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProjectsServiceInterface_SetProjectCustomHeader_Call) RunAndReturn(run func(interface{}, int, string, *gitlab.SetHookCustomHeaderOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ProjectsServiceInterface_SetProjectCustomHeader_Call {
	_c.Call.Return(run)
	return _c
}

// ShareProjectWithGroup provides a mock function with given fields: pid, opt, options
func (_m *ProjectsServiceInterface) ShareProjectWithGroup(pid interface{}, opt *gitlab.ShareWithGroupOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ShareProjectWithGroup")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ShareWithGroupOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ShareWithGroupOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ShareWithGroupOptions, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, opt, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProjectsServiceInterface_ShareProjectWithGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ShareProjectWithGroup'
type ProjectsServiceInterface_ShareProjectWithGroup_Call struct {
	*mock.Call
}

// ShareProjectWithGroup is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.ShareWithGroupOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) ShareProjectWithGroup(pid interface{}, opt interface{}, options ...interface{}) *ProjectsServiceInterface_ShareProjectWithGroup_Call {
	return &ProjectsServiceInterface_ShareProjectWithGroup_Call{Call: _e.mock.On("ShareProjectWithGroup",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ProjectsServiceInterface_ShareProjectWithGroup_Call) Run(run func(pid interface{}, opt *gitlab.ShareWithGroupOptions, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_ShareProjectWithGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ShareWithGroupOptions), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_ShareProjectWithGroup_Call) Return(_a0 *gitlab.Response, _a1 error) *ProjectsServiceInterface_ShareProjectWithGroup_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProjectsServiceInterface_ShareProjectWithGroup_Call) RunAndReturn(run func(interface{}, *gitlab.ShareWithGroupOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ProjectsServiceInterface_ShareProjectWithGroup_Call {
	_c.Call.Return(run)
	return _c
}

// StarProject provides a mock function with given fields: pid, options
func (_m *ProjectsServiceInterface) StarProject(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StarProject")
	}

	var r0 *gitlab.Project
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Project); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_StarProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StarProject'
type ProjectsServiceInterface_StarProject_Call struct {
	*mock.Call
}

// StarProject is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) StarProject(pid interface{}, options ...interface{}) *ProjectsServiceInterface_StarProject_Call {
	return &ProjectsServiceInterface_StarProject_Call{Call: _e.mock.On("StarProject",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ProjectsServiceInterface_StarProject_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_StarProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_StarProject_Call) Return(_a0 *gitlab.Project, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_StarProject_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_StarProject_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *ProjectsServiceInterface_StarProject_Call {
	_c.Call.Return(run)
	return _c
}

// StartHousekeepingProject provides a mock function with given fields: pid, options
func (_m *ProjectsServiceInterface) StartHousekeepingProject(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartHousekeepingProject")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProjectsServiceInterface_StartHousekeepingProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartHousekeepingProject'
type ProjectsServiceInterface_StartHousekeepingProject_Call struct {
	*mock.Call
}

// StartHousekeepingProject is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) StartHousekeepingProject(pid interface{}, options ...interface{}) *ProjectsServiceInterface_StartHousekeepingProject_Call {
	return &ProjectsServiceInterface_StartHousekeepingProject_Call{Call: _e.mock.On("StartHousekeepingProject",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ProjectsServiceInterface_StartHousekeepingProject_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_StartHousekeepingProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_StartHousekeepingProject_Call) Return(_a0 *gitlab.Response, _a1 error) *ProjectsServiceInterface_StartHousekeepingProject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProjectsServiceInterface_StartHousekeepingProject_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ProjectsServiceInterface_StartHousekeepingProject_Call {
	_c.Call.Return(run)
	return _c
}

// StartMirroringProject provides a mock function with given fields: pid, options
func (_m *ProjectsServiceInterface) StartMirroringProject(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for StartMirroringProject")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProjectsServiceInterface_StartMirroringProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartMirroringProject'
type ProjectsServiceInterface_StartMirroringProject_Call struct {
	*mock.Call
}

// StartMirroringProject is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) StartMirroringProject(pid interface{}, options ...interface{}) *ProjectsServiceInterface_StartMirroringProject_Call {
	return &ProjectsServiceInterface_StartMirroringProject_Call{Call: _e.mock.On("StartMirroringProject",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ProjectsServiceInterface_StartMirroringProject_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_StartMirroringProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_StartMirroringProject_Call) Return(_a0 *gitlab.Response, _a1 error) *ProjectsServiceInterface_StartMirroringProject_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProjectsServiceInterface_StartMirroringProject_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ProjectsServiceInterface_StartMirroringProject_Call {
	_c.Call.Return(run)
	return _c
}

// TransferProject provides a mock function with given fields: pid, opt, options
func (_m *ProjectsServiceInterface) TransferProject(pid interface{}, opt *gitlab.TransferProjectOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TransferProject")
	}

	var r0 *gitlab.Project
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.TransferProjectOptions, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.TransferProjectOptions, ...gitlab.RequestOptionFunc) *gitlab.Project); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.TransferProjectOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.TransferProjectOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_TransferProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TransferProject'
type ProjectsServiceInterface_TransferProject_Call struct {
	*mock.Call
}

// TransferProject is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.TransferProjectOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) TransferProject(pid interface{}, opt interface{}, options ...interface{}) *ProjectsServiceInterface_TransferProject_Call {
	return &ProjectsServiceInterface_TransferProject_Call{Call: _e.mock.On("TransferProject",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *ProjectsServiceInterface_TransferProject_Call) Run(run func(pid interface{}, opt *gitlab.TransferProjectOptions, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_TransferProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.TransferProjectOptions), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_TransferProject_Call) Return(_a0 *gitlab.Project, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_TransferProject_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_TransferProject_Call) RunAndReturn(run func(interface{}, *gitlab.TransferProjectOptions, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *ProjectsServiceInterface_TransferProject_Call {
	_c.Call.Return(run)
	return _c
}

// TriggerTestProjectHook provides a mock function with given fields: pid, hook, event, options
func (_m *ProjectsServiceInterface) TriggerTestProjectHook(pid interface{}, hook int, event gitlab.ProjectHookEvent, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, hook, event)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for TriggerTestProjectHook")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, gitlab.ProjectHookEvent, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, hook, event, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, gitlab.ProjectHookEvent, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, hook, event, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, gitlab.ProjectHookEvent, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, hook, event, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProjectsServiceInterface_TriggerTestProjectHook_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TriggerTestProjectHook'
type ProjectsServiceInterface_TriggerTestProjectHook_Call struct {
	*mock.Call
}

// TriggerTestProjectHook is a helper method to define mock.On call
//   - pid interface{}
//   - hook int
//   - event gitlab.ProjectHookEvent
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) TriggerTestProjectHook(pid interface{}, hook interface{}, event interface{}, options ...interface{}) *ProjectsServiceInterface_TriggerTestProjectHook_Call {
	return &ProjectsServiceInterface_TriggerTestProjectHook_Call{Call: _e.mock.On("TriggerTestProjectHook",
		append([]interface{}{pid, hook, event}, options...)...)}
}

func (_c *ProjectsServiceInterface_TriggerTestProjectHook_Call) Run(run func(pid interface{}, hook int, event gitlab.ProjectHookEvent, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_TriggerTestProjectHook_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(gitlab.ProjectHookEvent), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_TriggerTestProjectHook_Call) Return(_a0 *gitlab.Response, _a1 error) *ProjectsServiceInterface_TriggerTestProjectHook_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ProjectsServiceInterface_TriggerTestProjectHook_Call) RunAndReturn(run func(interface{}, int, gitlab.ProjectHookEvent, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *ProjectsServiceInterface_TriggerTestProjectHook_Call {
	_c.Call.Return(run)
	return _c
}

// UnarchiveProject provides a mock function with given fields: pid, options
func (_m *ProjectsServiceInterface) UnarchiveProject(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnarchiveProject")
	}

	var r0 *gitlab.Project
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Project); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_UnarchiveProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnarchiveProject'
type ProjectsServiceInterface_UnarchiveProject_Call struct {
	*mock.Call
}

// UnarchiveProject is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) UnarchiveProject(pid interface{}, options ...interface{}) *ProjectsServiceInterface_UnarchiveProject_Call {
	return &ProjectsServiceInterface_UnarchiveProject_Call{Call: _e.mock.On("UnarchiveProject",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ProjectsServiceInterface_UnarchiveProject_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_UnarchiveProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_UnarchiveProject_Call) Return(_a0 *gitlab.Project, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_UnarchiveProject_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_UnarchiveProject_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *ProjectsServiceInterface_UnarchiveProject_Call {
	_c.Call.Return(run)
	return _c
}

// UnstarProject provides a mock function with given fields: pid, options
func (_m *ProjectsServiceInterface) UnstarProject(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnstarProject")
	}

	var r0 *gitlab.Project
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Project); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_UnstarProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnstarProject'
type ProjectsServiceInterface_UnstarProject_Call struct {
	*mock.Call
}

// UnstarProject is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) UnstarProject(pid interface{}, options ...interface{}) *ProjectsServiceInterface_UnstarProject_Call {
	return &ProjectsServiceInterface_UnstarProject_Call{Call: _e.mock.On("UnstarProject",
		append([]interface{}{pid}, options...)...)}
}

func (_c *ProjectsServiceInterface_UnstarProject_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_UnstarProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_UnstarProject_Call) Return(_a0 *gitlab.Project, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_UnstarProject_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_UnstarProject_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *ProjectsServiceInterface_UnstarProject_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateProjectApprovalRule provides a mock function with given fields: pid, approvalRule, opt, options
func (_m *ProjectsServiceInterface) UpdateProjectApprovalRule(pid interface{}, approvalRule int, opt *gitlab.UpdateProjectLevelRuleOptions, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovalRule, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, approvalRule, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProjectApprovalRule")
	}

	var r0 *gitlab.ProjectApprovalRule
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.UpdateProjectLevelRuleOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovalRule, *gitlab.Response, error)); ok {
		return rf(pid, approvalRule, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.UpdateProjectLevelRuleOptions, ...gitlab.RequestOptionFunc) *gitlab.ProjectApprovalRule); ok {
		r0 = rf(pid, approvalRule, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.ProjectApprovalRule)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.UpdateProjectLevelRuleOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, approvalRule, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.UpdateProjectLevelRuleOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, approvalRule, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_UpdateProjectApprovalRule_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateProjectApprovalRule'
type ProjectsServiceInterface_UpdateProjectApprovalRule_Call struct {
	*mock.Call
}

// UpdateProjectApprovalRule is a helper method to define mock.On call
//   - pid interface{}
//   - approvalRule int
//   - opt *gitlab.UpdateProjectLevelRuleOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) UpdateProjectApprovalRule(pid interface{}, approvalRule interface{}, opt interface{}, options ...interface{}) *ProjectsServiceInterface_UpdateProjectApprovalRule_Call {
	return &ProjectsServiceInterface_UpdateProjectApprovalRule_Call{Call: _e.mock.On("UpdateProjectApprovalRule",
		append([]interface{}{pid, approvalRule, opt}, options...)...)}
}

func (_c *ProjectsServiceInterface_UpdateProjectApprovalRule_Call) Run(run func(pid interface{}, approvalRule int, opt *gitlab.UpdateProjectLevelRuleOptions, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_UpdateProjectApprovalRule_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.UpdateProjectLevelRuleOptions), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_UpdateProjectApprovalRule_Call) Return(_a0 *gitlab.ProjectApprovalRule, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_UpdateProjectApprovalRule_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_UpdateProjectApprovalRule_Call) RunAndReturn(run func(interface{}, int, *gitlab.UpdateProjectLevelRuleOptions, ...gitlab.RequestOptionFunc) (*gitlab.ProjectApprovalRule, *gitlab.Response, error)) *ProjectsServiceInterface_UpdateProjectApprovalRule_Call {
	_c.Call.Return(run)
	return _c
}

// UploadAvatar provides a mock function with given fields: pid, avatar, filename, options
func (_m *ProjectsServiceInterface) UploadAvatar(pid interface{}, avatar io.Reader, filename string, options ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, avatar, filename)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UploadAvatar")
	}

	var r0 *gitlab.Project
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, io.Reader, string, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)); ok {
		return rf(pid, avatar, filename, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, io.Reader, string, ...gitlab.RequestOptionFunc) *gitlab.Project); ok {
		r0 = rf(pid, avatar, filename, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, io.Reader, string, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, avatar, filename, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, io.Reader, string, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, avatar, filename, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_UploadAvatar_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UploadAvatar'
type ProjectsServiceInterface_UploadAvatar_Call struct {
	*mock.Call
}

// UploadAvatar is a helper method to define mock.On call
//   - pid interface{}
//   - avatar io.Reader
//   - filename string
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) UploadAvatar(pid interface{}, avatar interface{}, filename interface{}, options ...interface{}) *ProjectsServiceInterface_UploadAvatar_Call {
	return &ProjectsServiceInterface_UploadAvatar_Call{Call: _e.mock.On("UploadAvatar",
		append([]interface{}{pid, avatar, filename}, options...)...)}
}

func (_c *ProjectsServiceInterface_UploadAvatar_Call) Run(run func(pid interface{}, avatar io.Reader, filename string, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_UploadAvatar_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(io.Reader), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_UploadAvatar_Call) Return(_a0 *gitlab.Project, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_UploadAvatar_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_UploadAvatar_Call) RunAndReturn(run func(interface{}, io.Reader, string, ...gitlab.RequestOptionFunc) (*gitlab.Project, *gitlab.Response, error)) *ProjectsServiceInterface_UploadAvatar_Call {
	_c.Call.Return(run)
	return _c
}

// UploadFile provides a mock function with given fields: pid, content, filename, options
func (_m *ProjectsServiceInterface) UploadFile(pid interface{}, content io.Reader, filename string, options ...gitlab.RequestOptionFunc) (*gitlab.ProjectFile, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, content, filename)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UploadFile")
	}

	var r0 *gitlab.ProjectFile
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, io.Reader, string, ...gitlab.RequestOptionFunc) (*gitlab.ProjectFile, *gitlab.Response, error)); ok {
		return rf(pid, content, filename, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, io.Reader, string, ...gitlab.RequestOptionFunc) *gitlab.ProjectFile); ok {
		r0 = rf(pid, content, filename, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.ProjectFile)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, io.Reader, string, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, content, filename, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, io.Reader, string, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, content, filename, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ProjectsServiceInterface_UploadFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UploadFile'
type ProjectsServiceInterface_UploadFile_Call struct {
	*mock.Call
}

// UploadFile is a helper method to define mock.On call
//   - pid interface{}
//   - content io.Reader
//   - filename string
//   - options ...gitlab.RequestOptionFunc
func (_e *ProjectsServiceInterface_Expecter) UploadFile(pid interface{}, content interface{}, filename interface{}, options ...interface{}) *ProjectsServiceInterface_UploadFile_Call {
	return &ProjectsServiceInterface_UploadFile_Call{Call: _e.mock.On("UploadFile",
		append([]interface{}{pid, content, filename}, options...)...)}
}

func (_c *ProjectsServiceInterface_UploadFile_Call) Run(run func(pid interface{}, content io.Reader, filename string, options ...gitlab.RequestOptionFunc)) *ProjectsServiceInterface_UploadFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(io.Reader), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *ProjectsServiceInterface_UploadFile_Call) Return(_a0 *gitlab.ProjectFile, _a1 *gitlab.Response, _a2 error) *ProjectsServiceInterface_UploadFile_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *ProjectsServiceInterface_UploadFile_Call) RunAndReturn(run func(interface{}, io.Reader, string, ...gitlab.RequestOptionFunc) (*gitlab.ProjectFile, *gitlab.Response, error)) *ProjectsServiceInterface_UploadFile_Call {
	_c.Call.Return(run)
	return _c
}

// NewProjectsServiceInterface creates a new instance of ProjectsServiceInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewProjectsServiceInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *ProjectsServiceInterface {
	mock := &ProjectsServiceInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

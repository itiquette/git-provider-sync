// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"
	gitlab "gitlab.com/gitlab-org/api/client-go"
)

// PersonalAccessTokensServiceInterface is an autogenerated mock type for the PersonalAccessTokensServiceInterface type
type PersonalAccessTokensServiceInterface struct {
	mock.Mock
}

type PersonalAccessTokensServiceInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *PersonalAccessTokensServiceInterface) EXPECT() *PersonalAccessTokensServiceInterface_Expecter {
	return &PersonalAccessTokensServiceInterface_Expecter{mock: &_m.Mock}
}

// GetSinglePersonalAccessToken provides a mock function with given fields: options
func (_m *PersonalAccessTokensServiceInterface) GetSinglePersonalAccessToken(options ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSinglePersonalAccessToken")
	}

	var r0 *gitlab.PersonalAccessToken
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...gitlab.RequestOptionFunc) *gitlab.PersonalAccessToken); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.PersonalAccessToken)
		}
	}

	if rf, ok := ret.Get(1).(func(...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PersonalAccessTokensServiceInterface_GetSinglePersonalAccessToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSinglePersonalAccessToken'
type PersonalAccessTokensServiceInterface_GetSinglePersonalAccessToken_Call struct {
	*mock.Call
}

// GetSinglePersonalAccessToken is a helper method to define mock.On call
//   - options ...gitlab.RequestOptionFunc
func (_e *PersonalAccessTokensServiceInterface_Expecter) GetSinglePersonalAccessToken(options ...interface{}) *PersonalAccessTokensServiceInterface_GetSinglePersonalAccessToken_Call {
	return &PersonalAccessTokensServiceInterface_GetSinglePersonalAccessToken_Call{Call: _e.mock.On("GetSinglePersonalAccessToken",
		append([]interface{}{}, options...)...)}
}

func (_c *PersonalAccessTokensServiceInterface_GetSinglePersonalAccessToken_Call) Run(run func(options ...gitlab.RequestOptionFunc)) *PersonalAccessTokensServiceInterface_GetSinglePersonalAccessToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *PersonalAccessTokensServiceInterface_GetSinglePersonalAccessToken_Call) Return(_a0 *gitlab.PersonalAccessToken, _a1 *gitlab.Response, _a2 error) *PersonalAccessTokensServiceInterface_GetSinglePersonalAccessToken_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *PersonalAccessTokensServiceInterface_GetSinglePersonalAccessToken_Call) RunAndReturn(run func(...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error)) *PersonalAccessTokensServiceInterface_GetSinglePersonalAccessToken_Call {
	_c.Call.Return(run)
	return _c
}

// GetSinglePersonalAccessTokenByID provides a mock function with given fields: token, options
func (_m *PersonalAccessTokensServiceInterface) GetSinglePersonalAccessTokenByID(token int, options ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, token)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSinglePersonalAccessTokenByID")
	}

	var r0 *gitlab.PersonalAccessToken
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error)); ok {
		return rf(token, options...)
	}
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) *gitlab.PersonalAccessToken); ok {
		r0 = rf(token, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.PersonalAccessToken)
		}
	}

	if rf, ok := ret.Get(1).(func(int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(token, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(token, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PersonalAccessTokensServiceInterface_GetSinglePersonalAccessTokenByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSinglePersonalAccessTokenByID'
type PersonalAccessTokensServiceInterface_GetSinglePersonalAccessTokenByID_Call struct {
	*mock.Call
}

// GetSinglePersonalAccessTokenByID is a helper method to define mock.On call
//   - token int
//   - options ...gitlab.RequestOptionFunc
func (_e *PersonalAccessTokensServiceInterface_Expecter) GetSinglePersonalAccessTokenByID(token interface{}, options ...interface{}) *PersonalAccessTokensServiceInterface_GetSinglePersonalAccessTokenByID_Call {
	return &PersonalAccessTokensServiceInterface_GetSinglePersonalAccessTokenByID_Call{Call: _e.mock.On("GetSinglePersonalAccessTokenByID",
		append([]interface{}{token}, options...)...)}
}

func (_c *PersonalAccessTokensServiceInterface_GetSinglePersonalAccessTokenByID_Call) Run(run func(token int, options ...gitlab.RequestOptionFunc)) *PersonalAccessTokensServiceInterface_GetSinglePersonalAccessTokenByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *PersonalAccessTokensServiceInterface_GetSinglePersonalAccessTokenByID_Call) Return(_a0 *gitlab.PersonalAccessToken, _a1 *gitlab.Response, _a2 error) *PersonalAccessTokensServiceInterface_GetSinglePersonalAccessTokenByID_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *PersonalAccessTokensServiceInterface_GetSinglePersonalAccessTokenByID_Call) RunAndReturn(run func(int, ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error)) *PersonalAccessTokensServiceInterface_GetSinglePersonalAccessTokenByID_Call {
	_c.Call.Return(run)
	return _c
}

// ListPersonalAccessTokens provides a mock function with given fields: opt, options
func (_m *PersonalAccessTokensServiceInterface) ListPersonalAccessTokens(opt *gitlab.ListPersonalAccessTokensOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.PersonalAccessToken, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListPersonalAccessTokens")
	}

	var r0 []*gitlab.PersonalAccessToken
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(*gitlab.ListPersonalAccessTokensOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.PersonalAccessToken, *gitlab.Response, error)); ok {
		return rf(opt, options...)
	}
	if rf, ok := ret.Get(0).(func(*gitlab.ListPersonalAccessTokensOptions, ...gitlab.RequestOptionFunc) []*gitlab.PersonalAccessToken); ok {
		r0 = rf(opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.PersonalAccessToken)
		}
	}

	if rf, ok := ret.Get(1).(func(*gitlab.ListPersonalAccessTokensOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(*gitlab.ListPersonalAccessTokensOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PersonalAccessTokensServiceInterface_ListPersonalAccessTokens_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListPersonalAccessTokens'
type PersonalAccessTokensServiceInterface_ListPersonalAccessTokens_Call struct {
	*mock.Call
}

// ListPersonalAccessTokens is a helper method to define mock.On call
//   - opt *gitlab.ListPersonalAccessTokensOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *PersonalAccessTokensServiceInterface_Expecter) ListPersonalAccessTokens(opt interface{}, options ...interface{}) *PersonalAccessTokensServiceInterface_ListPersonalAccessTokens_Call {
	return &PersonalAccessTokensServiceInterface_ListPersonalAccessTokens_Call{Call: _e.mock.On("ListPersonalAccessTokens",
		append([]interface{}{opt}, options...)...)}
}

func (_c *PersonalAccessTokensServiceInterface_ListPersonalAccessTokens_Call) Run(run func(opt *gitlab.ListPersonalAccessTokensOptions, options ...gitlab.RequestOptionFunc)) *PersonalAccessTokensServiceInterface_ListPersonalAccessTokens_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(*gitlab.ListPersonalAccessTokensOptions), variadicArgs...)
	})
	return _c
}

func (_c *PersonalAccessTokensServiceInterface_ListPersonalAccessTokens_Call) Return(_a0 []*gitlab.PersonalAccessToken, _a1 *gitlab.Response, _a2 error) *PersonalAccessTokensServiceInterface_ListPersonalAccessTokens_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *PersonalAccessTokensServiceInterface_ListPersonalAccessTokens_Call) RunAndReturn(run func(*gitlab.ListPersonalAccessTokensOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.PersonalAccessToken, *gitlab.Response, error)) *PersonalAccessTokensServiceInterface_ListPersonalAccessTokens_Call {
	_c.Call.Return(run)
	return _c
}

// RevokePersonalAccessToken provides a mock function with given fields: token, options
func (_m *PersonalAccessTokensServiceInterface) RevokePersonalAccessToken(token int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, token)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RevokePersonalAccessToken")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(token, options...)
	}
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(token, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(token, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PersonalAccessTokensServiceInterface_RevokePersonalAccessToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RevokePersonalAccessToken'
type PersonalAccessTokensServiceInterface_RevokePersonalAccessToken_Call struct {
	*mock.Call
}

// RevokePersonalAccessToken is a helper method to define mock.On call
//   - token int
//   - options ...gitlab.RequestOptionFunc
func (_e *PersonalAccessTokensServiceInterface_Expecter) RevokePersonalAccessToken(token interface{}, options ...interface{}) *PersonalAccessTokensServiceInterface_RevokePersonalAccessToken_Call {
	return &PersonalAccessTokensServiceInterface_RevokePersonalAccessToken_Call{Call: _e.mock.On("RevokePersonalAccessToken",
		append([]interface{}{token}, options...)...)}
}

func (_c *PersonalAccessTokensServiceInterface_RevokePersonalAccessToken_Call) Run(run func(token int, options ...gitlab.RequestOptionFunc)) *PersonalAccessTokensServiceInterface_RevokePersonalAccessToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *PersonalAccessTokensServiceInterface_RevokePersonalAccessToken_Call) Return(_a0 *gitlab.Response, _a1 error) *PersonalAccessTokensServiceInterface_RevokePersonalAccessToken_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *PersonalAccessTokensServiceInterface_RevokePersonalAccessToken_Call) RunAndReturn(run func(int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *PersonalAccessTokensServiceInterface_RevokePersonalAccessToken_Call {
	_c.Call.Return(run)
	return _c
}

// RevokePersonalAccessTokenByID provides a mock function with given fields: token, options
func (_m *PersonalAccessTokensServiceInterface) RevokePersonalAccessTokenByID(token int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, token)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RevokePersonalAccessTokenByID")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(token, options...)
	}
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(token, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(token, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PersonalAccessTokensServiceInterface_RevokePersonalAccessTokenByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RevokePersonalAccessTokenByID'
type PersonalAccessTokensServiceInterface_RevokePersonalAccessTokenByID_Call struct {
	*mock.Call
}

// RevokePersonalAccessTokenByID is a helper method to define mock.On call
//   - token int
//   - options ...gitlab.RequestOptionFunc
func (_e *PersonalAccessTokensServiceInterface_Expecter) RevokePersonalAccessTokenByID(token interface{}, options ...interface{}) *PersonalAccessTokensServiceInterface_RevokePersonalAccessTokenByID_Call {
	return &PersonalAccessTokensServiceInterface_RevokePersonalAccessTokenByID_Call{Call: _e.mock.On("RevokePersonalAccessTokenByID",
		append([]interface{}{token}, options...)...)}
}

func (_c *PersonalAccessTokensServiceInterface_RevokePersonalAccessTokenByID_Call) Run(run func(token int, options ...gitlab.RequestOptionFunc)) *PersonalAccessTokensServiceInterface_RevokePersonalAccessTokenByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *PersonalAccessTokensServiceInterface_RevokePersonalAccessTokenByID_Call) Return(_a0 *gitlab.Response, _a1 error) *PersonalAccessTokensServiceInterface_RevokePersonalAccessTokenByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *PersonalAccessTokensServiceInterface_RevokePersonalAccessTokenByID_Call) RunAndReturn(run func(int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *PersonalAccessTokensServiceInterface_RevokePersonalAccessTokenByID_Call {
	_c.Call.Return(run)
	return _c
}

// RevokePersonalAccessTokenSelf provides a mock function with given fields: options
func (_m *PersonalAccessTokensServiceInterface) RevokePersonalAccessTokenSelf(options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RevokePersonalAccessTokenSelf")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PersonalAccessTokensServiceInterface_RevokePersonalAccessTokenSelf_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RevokePersonalAccessTokenSelf'
type PersonalAccessTokensServiceInterface_RevokePersonalAccessTokenSelf_Call struct {
	*mock.Call
}

// RevokePersonalAccessTokenSelf is a helper method to define mock.On call
//   - options ...gitlab.RequestOptionFunc
func (_e *PersonalAccessTokensServiceInterface_Expecter) RevokePersonalAccessTokenSelf(options ...interface{}) *PersonalAccessTokensServiceInterface_RevokePersonalAccessTokenSelf_Call {
	return &PersonalAccessTokensServiceInterface_RevokePersonalAccessTokenSelf_Call{Call: _e.mock.On("RevokePersonalAccessTokenSelf",
		append([]interface{}{}, options...)...)}
}

func (_c *PersonalAccessTokensServiceInterface_RevokePersonalAccessTokenSelf_Call) Run(run func(options ...gitlab.RequestOptionFunc)) *PersonalAccessTokensServiceInterface_RevokePersonalAccessTokenSelf_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *PersonalAccessTokensServiceInterface_RevokePersonalAccessTokenSelf_Call) Return(_a0 *gitlab.Response, _a1 error) *PersonalAccessTokensServiceInterface_RevokePersonalAccessTokenSelf_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *PersonalAccessTokensServiceInterface_RevokePersonalAccessTokenSelf_Call) RunAndReturn(run func(...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *PersonalAccessTokensServiceInterface_RevokePersonalAccessTokenSelf_Call {
	_c.Call.Return(run)
	return _c
}

// RotatePersonalAccessToken provides a mock function with given fields: token, opt, options
func (_m *PersonalAccessTokensServiceInterface) RotatePersonalAccessToken(token int, opt *gitlab.RotatePersonalAccessTokenOptions, options ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, token, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RotatePersonalAccessToken")
	}

	var r0 *gitlab.PersonalAccessToken
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(int, *gitlab.RotatePersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error)); ok {
		return rf(token, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(int, *gitlab.RotatePersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) *gitlab.PersonalAccessToken); ok {
		r0 = rf(token, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.PersonalAccessToken)
		}
	}

	if rf, ok := ret.Get(1).(func(int, *gitlab.RotatePersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(token, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(int, *gitlab.RotatePersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(token, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PersonalAccessTokensServiceInterface_RotatePersonalAccessToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RotatePersonalAccessToken'
type PersonalAccessTokensServiceInterface_RotatePersonalAccessToken_Call struct {
	*mock.Call
}

// RotatePersonalAccessToken is a helper method to define mock.On call
//   - token int
//   - opt *gitlab.RotatePersonalAccessTokenOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *PersonalAccessTokensServiceInterface_Expecter) RotatePersonalAccessToken(token interface{}, opt interface{}, options ...interface{}) *PersonalAccessTokensServiceInterface_RotatePersonalAccessToken_Call {
	return &PersonalAccessTokensServiceInterface_RotatePersonalAccessToken_Call{Call: _e.mock.On("RotatePersonalAccessToken",
		append([]interface{}{token, opt}, options...)...)}
}

func (_c *PersonalAccessTokensServiceInterface_RotatePersonalAccessToken_Call) Run(run func(token int, opt *gitlab.RotatePersonalAccessTokenOptions, options ...gitlab.RequestOptionFunc)) *PersonalAccessTokensServiceInterface_RotatePersonalAccessToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), args[1].(*gitlab.RotatePersonalAccessTokenOptions), variadicArgs...)
	})
	return _c
}

func (_c *PersonalAccessTokensServiceInterface_RotatePersonalAccessToken_Call) Return(_a0 *gitlab.PersonalAccessToken, _a1 *gitlab.Response, _a2 error) *PersonalAccessTokensServiceInterface_RotatePersonalAccessToken_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *PersonalAccessTokensServiceInterface_RotatePersonalAccessToken_Call) RunAndReturn(run func(int, *gitlab.RotatePersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error)) *PersonalAccessTokensServiceInterface_RotatePersonalAccessToken_Call {
	_c.Call.Return(run)
	return _c
}

// RotatePersonalAccessTokenByID provides a mock function with given fields: token, opt, options
func (_m *PersonalAccessTokensServiceInterface) RotatePersonalAccessTokenByID(token int, opt *gitlab.RotatePersonalAccessTokenOptions, options ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, token, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RotatePersonalAccessTokenByID")
	}

	var r0 *gitlab.PersonalAccessToken
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(int, *gitlab.RotatePersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error)); ok {
		return rf(token, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(int, *gitlab.RotatePersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) *gitlab.PersonalAccessToken); ok {
		r0 = rf(token, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.PersonalAccessToken)
		}
	}

	if rf, ok := ret.Get(1).(func(int, *gitlab.RotatePersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(token, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(int, *gitlab.RotatePersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(token, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PersonalAccessTokensServiceInterface_RotatePersonalAccessTokenByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RotatePersonalAccessTokenByID'
type PersonalAccessTokensServiceInterface_RotatePersonalAccessTokenByID_Call struct {
	*mock.Call
}

// RotatePersonalAccessTokenByID is a helper method to define mock.On call
//   - token int
//   - opt *gitlab.RotatePersonalAccessTokenOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *PersonalAccessTokensServiceInterface_Expecter) RotatePersonalAccessTokenByID(token interface{}, opt interface{}, options ...interface{}) *PersonalAccessTokensServiceInterface_RotatePersonalAccessTokenByID_Call {
	return &PersonalAccessTokensServiceInterface_RotatePersonalAccessTokenByID_Call{Call: _e.mock.On("RotatePersonalAccessTokenByID",
		append([]interface{}{token, opt}, options...)...)}
}

func (_c *PersonalAccessTokensServiceInterface_RotatePersonalAccessTokenByID_Call) Run(run func(token int, opt *gitlab.RotatePersonalAccessTokenOptions, options ...gitlab.RequestOptionFunc)) *PersonalAccessTokensServiceInterface_RotatePersonalAccessTokenByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), args[1].(*gitlab.RotatePersonalAccessTokenOptions), variadicArgs...)
	})
	return _c
}

func (_c *PersonalAccessTokensServiceInterface_RotatePersonalAccessTokenByID_Call) Return(_a0 *gitlab.PersonalAccessToken, _a1 *gitlab.Response, _a2 error) *PersonalAccessTokensServiceInterface_RotatePersonalAccessTokenByID_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *PersonalAccessTokensServiceInterface_RotatePersonalAccessTokenByID_Call) RunAndReturn(run func(int, *gitlab.RotatePersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error)) *PersonalAccessTokensServiceInterface_RotatePersonalAccessTokenByID_Call {
	_c.Call.Return(run)
	return _c
}

// RotatePersonalAccessTokenSelf provides a mock function with given fields: opt, options
func (_m *PersonalAccessTokensServiceInterface) RotatePersonalAccessTokenSelf(opt *gitlab.RotatePersonalAccessTokenOptions, options ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RotatePersonalAccessTokenSelf")
	}

	var r0 *gitlab.PersonalAccessToken
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(*gitlab.RotatePersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error)); ok {
		return rf(opt, options...)
	}
	if rf, ok := ret.Get(0).(func(*gitlab.RotatePersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) *gitlab.PersonalAccessToken); ok {
		r0 = rf(opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.PersonalAccessToken)
		}
	}

	if rf, ok := ret.Get(1).(func(*gitlab.RotatePersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(*gitlab.RotatePersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// PersonalAccessTokensServiceInterface_RotatePersonalAccessTokenSelf_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RotatePersonalAccessTokenSelf'
type PersonalAccessTokensServiceInterface_RotatePersonalAccessTokenSelf_Call struct {
	*mock.Call
}

// RotatePersonalAccessTokenSelf is a helper method to define mock.On call
//   - opt *gitlab.RotatePersonalAccessTokenOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *PersonalAccessTokensServiceInterface_Expecter) RotatePersonalAccessTokenSelf(opt interface{}, options ...interface{}) *PersonalAccessTokensServiceInterface_RotatePersonalAccessTokenSelf_Call {
	return &PersonalAccessTokensServiceInterface_RotatePersonalAccessTokenSelf_Call{Call: _e.mock.On("RotatePersonalAccessTokenSelf",
		append([]interface{}{opt}, options...)...)}
}

func (_c *PersonalAccessTokensServiceInterface_RotatePersonalAccessTokenSelf_Call) Run(run func(opt *gitlab.RotatePersonalAccessTokenOptions, options ...gitlab.RequestOptionFunc)) *PersonalAccessTokensServiceInterface_RotatePersonalAccessTokenSelf_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(*gitlab.RotatePersonalAccessTokenOptions), variadicArgs...)
	})
	return _c
}

func (_c *PersonalAccessTokensServiceInterface_RotatePersonalAccessTokenSelf_Call) Return(_a0 *gitlab.PersonalAccessToken, _a1 *gitlab.Response, _a2 error) *PersonalAccessTokensServiceInterface_RotatePersonalAccessTokenSelf_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *PersonalAccessTokensServiceInterface_RotatePersonalAccessTokenSelf_Call) RunAndReturn(run func(*gitlab.RotatePersonalAccessTokenOptions, ...gitlab.RequestOptionFunc) (*gitlab.PersonalAccessToken, *gitlab.Response, error)) *PersonalAccessTokensServiceInterface_RotatePersonalAccessTokenSelf_Call {
	_c.Call.Return(run)
	return _c
}

// NewPersonalAccessTokensServiceInterface creates a new instance of PersonalAccessTokensServiceInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPersonalAccessTokensServiceInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *PersonalAccessTokensServiceInterface {
	mock := &PersonalAccessTokensServiceInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

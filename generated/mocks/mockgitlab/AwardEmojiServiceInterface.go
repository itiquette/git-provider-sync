// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"
	gitlab "gitlab.com/gitlab-org/api/client-go"
)

// AwardEmojiServiceInterface is an autogenerated mock type for the AwardEmojiServiceInterface type
type AwardEmojiServiceInterface struct {
	mock.Mock
}

type AwardEmojiServiceInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *AwardEmojiServiceInterface) EXPECT() *AwardEmojiServiceInterface_Expecter {
	return &AwardEmojiServiceInterface_Expecter{mock: &_m.Mock}
}

// CreateIssueAwardEmoji provides a mock function with given fields: pid, issueIID, opt, options
func (_m *AwardEmojiServiceInterface) CreateIssueAwardEmoji(pid interface{}, issueIID int, opt *gitlab.CreateAwardEmojiOptions, options ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issueIID, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIssueAwardEmoji")
	}

	var r0 *gitlab.AwardEmoji
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error)); ok {
		return rf(pid, issueIID, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) *gitlab.AwardEmoji); ok {
		r0 = rf(pid, issueIID, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.AwardEmoji)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issueIID, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issueIID, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AwardEmojiServiceInterface_CreateIssueAwardEmoji_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateIssueAwardEmoji'
type AwardEmojiServiceInterface_CreateIssueAwardEmoji_Call struct {
	*mock.Call
}

// CreateIssueAwardEmoji is a helper method to define mock.On call
//   - pid interface{}
//   - issueIID int
//   - opt *gitlab.CreateAwardEmojiOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *AwardEmojiServiceInterface_Expecter) CreateIssueAwardEmoji(pid interface{}, issueIID interface{}, opt interface{}, options ...interface{}) *AwardEmojiServiceInterface_CreateIssueAwardEmoji_Call {
	return &AwardEmojiServiceInterface_CreateIssueAwardEmoji_Call{Call: _e.mock.On("CreateIssueAwardEmoji",
		append([]interface{}{pid, issueIID, opt}, options...)...)}
}

func (_c *AwardEmojiServiceInterface_CreateIssueAwardEmoji_Call) Run(run func(pid interface{}, issueIID int, opt *gitlab.CreateAwardEmojiOptions, options ...gitlab.RequestOptionFunc)) *AwardEmojiServiceInterface_CreateIssueAwardEmoji_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.CreateAwardEmojiOptions), variadicArgs...)
	})
	return _c
}

func (_c *AwardEmojiServiceInterface_CreateIssueAwardEmoji_Call) Return(_a0 *gitlab.AwardEmoji, _a1 *gitlab.Response, _a2 error) *AwardEmojiServiceInterface_CreateIssueAwardEmoji_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *AwardEmojiServiceInterface_CreateIssueAwardEmoji_Call) RunAndReturn(run func(interface{}, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error)) *AwardEmojiServiceInterface_CreateIssueAwardEmoji_Call {
	_c.Call.Return(run)
	return _c
}

// CreateIssuesAwardEmojiOnNote provides a mock function with given fields: pid, issueID, noteID, opt, options
func (_m *AwardEmojiServiceInterface) CreateIssuesAwardEmojiOnNote(pid interface{}, issueID int, noteID int, opt *gitlab.CreateAwardEmojiOptions, options ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issueID, noteID, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIssuesAwardEmojiOnNote")
	}

	var r0 *gitlab.AwardEmoji
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error)); ok {
		return rf(pid, issueID, noteID, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) *gitlab.AwardEmoji); ok {
		r0 = rf(pid, issueID, noteID, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.AwardEmoji)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issueID, noteID, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issueID, noteID, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AwardEmojiServiceInterface_CreateIssuesAwardEmojiOnNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateIssuesAwardEmojiOnNote'
type AwardEmojiServiceInterface_CreateIssuesAwardEmojiOnNote_Call struct {
	*mock.Call
}

// CreateIssuesAwardEmojiOnNote is a helper method to define mock.On call
//   - pid interface{}
//   - issueID int
//   - noteID int
//   - opt *gitlab.CreateAwardEmojiOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *AwardEmojiServiceInterface_Expecter) CreateIssuesAwardEmojiOnNote(pid interface{}, issueID interface{}, noteID interface{}, opt interface{}, options ...interface{}) *AwardEmojiServiceInterface_CreateIssuesAwardEmojiOnNote_Call {
	return &AwardEmojiServiceInterface_CreateIssuesAwardEmojiOnNote_Call{Call: _e.mock.On("CreateIssuesAwardEmojiOnNote",
		append([]interface{}{pid, issueID, noteID, opt}, options...)...)}
}

func (_c *AwardEmojiServiceInterface_CreateIssuesAwardEmojiOnNote_Call) Run(run func(pid interface{}, issueID int, noteID int, opt *gitlab.CreateAwardEmojiOptions, options ...gitlab.RequestOptionFunc)) *AwardEmojiServiceInterface_CreateIssuesAwardEmojiOnNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), args[3].(*gitlab.CreateAwardEmojiOptions), variadicArgs...)
	})
	return _c
}

func (_c *AwardEmojiServiceInterface_CreateIssuesAwardEmojiOnNote_Call) Return(_a0 *gitlab.AwardEmoji, _a1 *gitlab.Response, _a2 error) *AwardEmojiServiceInterface_CreateIssuesAwardEmojiOnNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *AwardEmojiServiceInterface_CreateIssuesAwardEmojiOnNote_Call) RunAndReturn(run func(interface{}, int, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error)) *AwardEmojiServiceInterface_CreateIssuesAwardEmojiOnNote_Call {
	_c.Call.Return(run)
	return _c
}

// CreateMergeRequestAwardEmoji provides a mock function with given fields: pid, mergeRequestIID, opt, options
func (_m *AwardEmojiServiceInterface) CreateMergeRequestAwardEmoji(pid interface{}, mergeRequestIID int, opt *gitlab.CreateAwardEmojiOptions, options ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequestIID, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateMergeRequestAwardEmoji")
	}

	var r0 *gitlab.AwardEmoji
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequestIID, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) *gitlab.AwardEmoji); ok {
		r0 = rf(pid, mergeRequestIID, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.AwardEmoji)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequestIID, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequestIID, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AwardEmojiServiceInterface_CreateMergeRequestAwardEmoji_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMergeRequestAwardEmoji'
type AwardEmojiServiceInterface_CreateMergeRequestAwardEmoji_Call struct {
	*mock.Call
}

// CreateMergeRequestAwardEmoji is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequestIID int
//   - opt *gitlab.CreateAwardEmojiOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *AwardEmojiServiceInterface_Expecter) CreateMergeRequestAwardEmoji(pid interface{}, mergeRequestIID interface{}, opt interface{}, options ...interface{}) *AwardEmojiServiceInterface_CreateMergeRequestAwardEmoji_Call {
	return &AwardEmojiServiceInterface_CreateMergeRequestAwardEmoji_Call{Call: _e.mock.On("CreateMergeRequestAwardEmoji",
		append([]interface{}{pid, mergeRequestIID, opt}, options...)...)}
}

func (_c *AwardEmojiServiceInterface_CreateMergeRequestAwardEmoji_Call) Run(run func(pid interface{}, mergeRequestIID int, opt *gitlab.CreateAwardEmojiOptions, options ...gitlab.RequestOptionFunc)) *AwardEmojiServiceInterface_CreateMergeRequestAwardEmoji_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.CreateAwardEmojiOptions), variadicArgs...)
	})
	return _c
}

func (_c *AwardEmojiServiceInterface_CreateMergeRequestAwardEmoji_Call) Return(_a0 *gitlab.AwardEmoji, _a1 *gitlab.Response, _a2 error) *AwardEmojiServiceInterface_CreateMergeRequestAwardEmoji_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *AwardEmojiServiceInterface_CreateMergeRequestAwardEmoji_Call) RunAndReturn(run func(interface{}, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error)) *AwardEmojiServiceInterface_CreateMergeRequestAwardEmoji_Call {
	_c.Call.Return(run)
	return _c
}

// CreateMergeRequestAwardEmojiOnNote provides a mock function with given fields: pid, mergeRequestIID, noteID, opt, options
func (_m *AwardEmojiServiceInterface) CreateMergeRequestAwardEmojiOnNote(pid interface{}, mergeRequestIID int, noteID int, opt *gitlab.CreateAwardEmojiOptions, options ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequestIID, noteID, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateMergeRequestAwardEmojiOnNote")
	}

	var r0 *gitlab.AwardEmoji
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequestIID, noteID, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) *gitlab.AwardEmoji); ok {
		r0 = rf(pid, mergeRequestIID, noteID, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.AwardEmoji)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequestIID, noteID, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequestIID, noteID, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AwardEmojiServiceInterface_CreateMergeRequestAwardEmojiOnNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMergeRequestAwardEmojiOnNote'
type AwardEmojiServiceInterface_CreateMergeRequestAwardEmojiOnNote_Call struct {
	*mock.Call
}

// CreateMergeRequestAwardEmojiOnNote is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequestIID int
//   - noteID int
//   - opt *gitlab.CreateAwardEmojiOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *AwardEmojiServiceInterface_Expecter) CreateMergeRequestAwardEmojiOnNote(pid interface{}, mergeRequestIID interface{}, noteID interface{}, opt interface{}, options ...interface{}) *AwardEmojiServiceInterface_CreateMergeRequestAwardEmojiOnNote_Call {
	return &AwardEmojiServiceInterface_CreateMergeRequestAwardEmojiOnNote_Call{Call: _e.mock.On("CreateMergeRequestAwardEmojiOnNote",
		append([]interface{}{pid, mergeRequestIID, noteID, opt}, options...)...)}
}

func (_c *AwardEmojiServiceInterface_CreateMergeRequestAwardEmojiOnNote_Call) Run(run func(pid interface{}, mergeRequestIID int, noteID int, opt *gitlab.CreateAwardEmojiOptions, options ...gitlab.RequestOptionFunc)) *AwardEmojiServiceInterface_CreateMergeRequestAwardEmojiOnNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), args[3].(*gitlab.CreateAwardEmojiOptions), variadicArgs...)
	})
	return _c
}

func (_c *AwardEmojiServiceInterface_CreateMergeRequestAwardEmojiOnNote_Call) Return(_a0 *gitlab.AwardEmoji, _a1 *gitlab.Response, _a2 error) *AwardEmojiServiceInterface_CreateMergeRequestAwardEmojiOnNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *AwardEmojiServiceInterface_CreateMergeRequestAwardEmojiOnNote_Call) RunAndReturn(run func(interface{}, int, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error)) *AwardEmojiServiceInterface_CreateMergeRequestAwardEmojiOnNote_Call {
	_c.Call.Return(run)
	return _c
}

// CreateSnippetAwardEmoji provides a mock function with given fields: pid, snippetID, opt, options
func (_m *AwardEmojiServiceInterface) CreateSnippetAwardEmoji(pid interface{}, snippetID int, opt *gitlab.CreateAwardEmojiOptions, options ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, snippetID, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSnippetAwardEmoji")
	}

	var r0 *gitlab.AwardEmoji
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error)); ok {
		return rf(pid, snippetID, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) *gitlab.AwardEmoji); ok {
		r0 = rf(pid, snippetID, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.AwardEmoji)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, snippetID, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, snippetID, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AwardEmojiServiceInterface_CreateSnippetAwardEmoji_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSnippetAwardEmoji'
type AwardEmojiServiceInterface_CreateSnippetAwardEmoji_Call struct {
	*mock.Call
}

// CreateSnippetAwardEmoji is a helper method to define mock.On call
//   - pid interface{}
//   - snippetID int
//   - opt *gitlab.CreateAwardEmojiOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *AwardEmojiServiceInterface_Expecter) CreateSnippetAwardEmoji(pid interface{}, snippetID interface{}, opt interface{}, options ...interface{}) *AwardEmojiServiceInterface_CreateSnippetAwardEmoji_Call {
	return &AwardEmojiServiceInterface_CreateSnippetAwardEmoji_Call{Call: _e.mock.On("CreateSnippetAwardEmoji",
		append([]interface{}{pid, snippetID, opt}, options...)...)}
}

func (_c *AwardEmojiServiceInterface_CreateSnippetAwardEmoji_Call) Run(run func(pid interface{}, snippetID int, opt *gitlab.CreateAwardEmojiOptions, options ...gitlab.RequestOptionFunc)) *AwardEmojiServiceInterface_CreateSnippetAwardEmoji_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.CreateAwardEmojiOptions), variadicArgs...)
	})
	return _c
}

func (_c *AwardEmojiServiceInterface_CreateSnippetAwardEmoji_Call) Return(_a0 *gitlab.AwardEmoji, _a1 *gitlab.Response, _a2 error) *AwardEmojiServiceInterface_CreateSnippetAwardEmoji_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *AwardEmojiServiceInterface_CreateSnippetAwardEmoji_Call) RunAndReturn(run func(interface{}, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error)) *AwardEmojiServiceInterface_CreateSnippetAwardEmoji_Call {
	_c.Call.Return(run)
	return _c
}

// CreateSnippetAwardEmojiOnNote provides a mock function with given fields: pid, snippetIID, noteID, opt, options
func (_m *AwardEmojiServiceInterface) CreateSnippetAwardEmojiOnNote(pid interface{}, snippetIID int, noteID int, opt *gitlab.CreateAwardEmojiOptions, options ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, snippetIID, noteID, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSnippetAwardEmojiOnNote")
	}

	var r0 *gitlab.AwardEmoji
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error)); ok {
		return rf(pid, snippetIID, noteID, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) *gitlab.AwardEmoji); ok {
		r0 = rf(pid, snippetIID, noteID, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.AwardEmoji)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, snippetIID, noteID, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, snippetIID, noteID, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AwardEmojiServiceInterface_CreateSnippetAwardEmojiOnNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSnippetAwardEmojiOnNote'
type AwardEmojiServiceInterface_CreateSnippetAwardEmojiOnNote_Call struct {
	*mock.Call
}

// CreateSnippetAwardEmojiOnNote is a helper method to define mock.On call
//   - pid interface{}
//   - snippetIID int
//   - noteID int
//   - opt *gitlab.CreateAwardEmojiOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *AwardEmojiServiceInterface_Expecter) CreateSnippetAwardEmojiOnNote(pid interface{}, snippetIID interface{}, noteID interface{}, opt interface{}, options ...interface{}) *AwardEmojiServiceInterface_CreateSnippetAwardEmojiOnNote_Call {
	return &AwardEmojiServiceInterface_CreateSnippetAwardEmojiOnNote_Call{Call: _e.mock.On("CreateSnippetAwardEmojiOnNote",
		append([]interface{}{pid, snippetIID, noteID, opt}, options...)...)}
}

func (_c *AwardEmojiServiceInterface_CreateSnippetAwardEmojiOnNote_Call) Run(run func(pid interface{}, snippetIID int, noteID int, opt *gitlab.CreateAwardEmojiOptions, options ...gitlab.RequestOptionFunc)) *AwardEmojiServiceInterface_CreateSnippetAwardEmojiOnNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), args[3].(*gitlab.CreateAwardEmojiOptions), variadicArgs...)
	})
	return _c
}

func (_c *AwardEmojiServiceInterface_CreateSnippetAwardEmojiOnNote_Call) Return(_a0 *gitlab.AwardEmoji, _a1 *gitlab.Response, _a2 error) *AwardEmojiServiceInterface_CreateSnippetAwardEmojiOnNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *AwardEmojiServiceInterface_CreateSnippetAwardEmojiOnNote_Call) RunAndReturn(run func(interface{}, int, int, *gitlab.CreateAwardEmojiOptions, ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error)) *AwardEmojiServiceInterface_CreateSnippetAwardEmojiOnNote_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteIssueAwardEmoji provides a mock function with given fields: pid, issueIID, awardID, options
func (_m *AwardEmojiServiceInterface) DeleteIssueAwardEmoji(pid interface{}, issueIID int, awardID int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issueIID, awardID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIssueAwardEmoji")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, issueIID, awardID, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, issueIID, awardID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, issueIID, awardID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AwardEmojiServiceInterface_DeleteIssueAwardEmoji_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteIssueAwardEmoji'
type AwardEmojiServiceInterface_DeleteIssueAwardEmoji_Call struct {
	*mock.Call
}

// DeleteIssueAwardEmoji is a helper method to define mock.On call
//   - pid interface{}
//   - issueIID int
//   - awardID int
//   - options ...gitlab.RequestOptionFunc
func (_e *AwardEmojiServiceInterface_Expecter) DeleteIssueAwardEmoji(pid interface{}, issueIID interface{}, awardID interface{}, options ...interface{}) *AwardEmojiServiceInterface_DeleteIssueAwardEmoji_Call {
	return &AwardEmojiServiceInterface_DeleteIssueAwardEmoji_Call{Call: _e.mock.On("DeleteIssueAwardEmoji",
		append([]interface{}{pid, issueIID, awardID}, options...)...)}
}

func (_c *AwardEmojiServiceInterface_DeleteIssueAwardEmoji_Call) Run(run func(pid interface{}, issueIID int, awardID int, options ...gitlab.RequestOptionFunc)) *AwardEmojiServiceInterface_DeleteIssueAwardEmoji_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), variadicArgs...)
	})
	return _c
}

func (_c *AwardEmojiServiceInterface_DeleteIssueAwardEmoji_Call) Return(_a0 *gitlab.Response, _a1 error) *AwardEmojiServiceInterface_DeleteIssueAwardEmoji_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AwardEmojiServiceInterface_DeleteIssueAwardEmoji_Call) RunAndReturn(run func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *AwardEmojiServiceInterface_DeleteIssueAwardEmoji_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteIssuesAwardEmojiOnNote provides a mock function with given fields: pid, issueID, noteID, awardID, options
func (_m *AwardEmojiServiceInterface) DeleteIssuesAwardEmojiOnNote(pid interface{}, issueID int, noteID int, awardID int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issueID, noteID, awardID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIssuesAwardEmojiOnNote")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, issueID, noteID, awardID, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, issueID, noteID, awardID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, issueID, noteID, awardID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AwardEmojiServiceInterface_DeleteIssuesAwardEmojiOnNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteIssuesAwardEmojiOnNote'
type AwardEmojiServiceInterface_DeleteIssuesAwardEmojiOnNote_Call struct {
	*mock.Call
}

// DeleteIssuesAwardEmojiOnNote is a helper method to define mock.On call
//   - pid interface{}
//   - issueID int
//   - noteID int
//   - awardID int
//   - options ...gitlab.RequestOptionFunc
func (_e *AwardEmojiServiceInterface_Expecter) DeleteIssuesAwardEmojiOnNote(pid interface{}, issueID interface{}, noteID interface{}, awardID interface{}, options ...interface{}) *AwardEmojiServiceInterface_DeleteIssuesAwardEmojiOnNote_Call {
	return &AwardEmojiServiceInterface_DeleteIssuesAwardEmojiOnNote_Call{Call: _e.mock.On("DeleteIssuesAwardEmojiOnNote",
		append([]interface{}{pid, issueID, noteID, awardID}, options...)...)}
}

func (_c *AwardEmojiServiceInterface_DeleteIssuesAwardEmojiOnNote_Call) Run(run func(pid interface{}, issueID int, noteID int, awardID int, options ...gitlab.RequestOptionFunc)) *AwardEmojiServiceInterface_DeleteIssuesAwardEmojiOnNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), args[3].(int), variadicArgs...)
	})
	return _c
}

func (_c *AwardEmojiServiceInterface_DeleteIssuesAwardEmojiOnNote_Call) Return(_a0 *gitlab.Response, _a1 error) *AwardEmojiServiceInterface_DeleteIssuesAwardEmojiOnNote_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AwardEmojiServiceInterface_DeleteIssuesAwardEmojiOnNote_Call) RunAndReturn(run func(interface{}, int, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *AwardEmojiServiceInterface_DeleteIssuesAwardEmojiOnNote_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteMergeRequestAwardEmoji provides a mock function with given fields: pid, mergeRequestIID, awardID, options
func (_m *AwardEmojiServiceInterface) DeleteMergeRequestAwardEmoji(pid interface{}, mergeRequestIID int, awardID int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequestIID, awardID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMergeRequestAwardEmoji")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, mergeRequestIID, awardID, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, mergeRequestIID, awardID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, mergeRequestIID, awardID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AwardEmojiServiceInterface_DeleteMergeRequestAwardEmoji_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteMergeRequestAwardEmoji'
type AwardEmojiServiceInterface_DeleteMergeRequestAwardEmoji_Call struct {
	*mock.Call
}

// DeleteMergeRequestAwardEmoji is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequestIID int
//   - awardID int
//   - options ...gitlab.RequestOptionFunc
func (_e *AwardEmojiServiceInterface_Expecter) DeleteMergeRequestAwardEmoji(pid interface{}, mergeRequestIID interface{}, awardID interface{}, options ...interface{}) *AwardEmojiServiceInterface_DeleteMergeRequestAwardEmoji_Call {
	return &AwardEmojiServiceInterface_DeleteMergeRequestAwardEmoji_Call{Call: _e.mock.On("DeleteMergeRequestAwardEmoji",
		append([]interface{}{pid, mergeRequestIID, awardID}, options...)...)}
}

func (_c *AwardEmojiServiceInterface_DeleteMergeRequestAwardEmoji_Call) Run(run func(pid interface{}, mergeRequestIID int, awardID int, options ...gitlab.RequestOptionFunc)) *AwardEmojiServiceInterface_DeleteMergeRequestAwardEmoji_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), variadicArgs...)
	})
	return _c
}

func (_c *AwardEmojiServiceInterface_DeleteMergeRequestAwardEmoji_Call) Return(_a0 *gitlab.Response, _a1 error) *AwardEmojiServiceInterface_DeleteMergeRequestAwardEmoji_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AwardEmojiServiceInterface_DeleteMergeRequestAwardEmoji_Call) RunAndReturn(run func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *AwardEmojiServiceInterface_DeleteMergeRequestAwardEmoji_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteMergeRequestAwardEmojiOnNote provides a mock function with given fields: pid, mergeRequestIID, noteID, awardID, options
func (_m *AwardEmojiServiceInterface) DeleteMergeRequestAwardEmojiOnNote(pid interface{}, mergeRequestIID int, noteID int, awardID int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequestIID, noteID, awardID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMergeRequestAwardEmojiOnNote")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, mergeRequestIID, noteID, awardID, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, mergeRequestIID, noteID, awardID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, mergeRequestIID, noteID, awardID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AwardEmojiServiceInterface_DeleteMergeRequestAwardEmojiOnNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteMergeRequestAwardEmojiOnNote'
type AwardEmojiServiceInterface_DeleteMergeRequestAwardEmojiOnNote_Call struct {
	*mock.Call
}

// DeleteMergeRequestAwardEmojiOnNote is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequestIID int
//   - noteID int
//   - awardID int
//   - options ...gitlab.RequestOptionFunc
func (_e *AwardEmojiServiceInterface_Expecter) DeleteMergeRequestAwardEmojiOnNote(pid interface{}, mergeRequestIID interface{}, noteID interface{}, awardID interface{}, options ...interface{}) *AwardEmojiServiceInterface_DeleteMergeRequestAwardEmojiOnNote_Call {
	return &AwardEmojiServiceInterface_DeleteMergeRequestAwardEmojiOnNote_Call{Call: _e.mock.On("DeleteMergeRequestAwardEmojiOnNote",
		append([]interface{}{pid, mergeRequestIID, noteID, awardID}, options...)...)}
}

func (_c *AwardEmojiServiceInterface_DeleteMergeRequestAwardEmojiOnNote_Call) Run(run func(pid interface{}, mergeRequestIID int, noteID int, awardID int, options ...gitlab.RequestOptionFunc)) *AwardEmojiServiceInterface_DeleteMergeRequestAwardEmojiOnNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), args[3].(int), variadicArgs...)
	})
	return _c
}

func (_c *AwardEmojiServiceInterface_DeleteMergeRequestAwardEmojiOnNote_Call) Return(_a0 *gitlab.Response, _a1 error) *AwardEmojiServiceInterface_DeleteMergeRequestAwardEmojiOnNote_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AwardEmojiServiceInterface_DeleteMergeRequestAwardEmojiOnNote_Call) RunAndReturn(run func(interface{}, int, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *AwardEmojiServiceInterface_DeleteMergeRequestAwardEmojiOnNote_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSnippetAwardEmoji provides a mock function with given fields: pid, snippetID, awardID, options
func (_m *AwardEmojiServiceInterface) DeleteSnippetAwardEmoji(pid interface{}, snippetID int, awardID int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, snippetID, awardID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSnippetAwardEmoji")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, snippetID, awardID, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, snippetID, awardID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, snippetID, awardID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AwardEmojiServiceInterface_DeleteSnippetAwardEmoji_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSnippetAwardEmoji'
type AwardEmojiServiceInterface_DeleteSnippetAwardEmoji_Call struct {
	*mock.Call
}

// DeleteSnippetAwardEmoji is a helper method to define mock.On call
//   - pid interface{}
//   - snippetID int
//   - awardID int
//   - options ...gitlab.RequestOptionFunc
func (_e *AwardEmojiServiceInterface_Expecter) DeleteSnippetAwardEmoji(pid interface{}, snippetID interface{}, awardID interface{}, options ...interface{}) *AwardEmojiServiceInterface_DeleteSnippetAwardEmoji_Call {
	return &AwardEmojiServiceInterface_DeleteSnippetAwardEmoji_Call{Call: _e.mock.On("DeleteSnippetAwardEmoji",
		append([]interface{}{pid, snippetID, awardID}, options...)...)}
}

func (_c *AwardEmojiServiceInterface_DeleteSnippetAwardEmoji_Call) Run(run func(pid interface{}, snippetID int, awardID int, options ...gitlab.RequestOptionFunc)) *AwardEmojiServiceInterface_DeleteSnippetAwardEmoji_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), variadicArgs...)
	})
	return _c
}

func (_c *AwardEmojiServiceInterface_DeleteSnippetAwardEmoji_Call) Return(_a0 *gitlab.Response, _a1 error) *AwardEmojiServiceInterface_DeleteSnippetAwardEmoji_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AwardEmojiServiceInterface_DeleteSnippetAwardEmoji_Call) RunAndReturn(run func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *AwardEmojiServiceInterface_DeleteSnippetAwardEmoji_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSnippetAwardEmojiOnNote provides a mock function with given fields: pid, snippetIID, noteID, awardID, options
func (_m *AwardEmojiServiceInterface) DeleteSnippetAwardEmojiOnNote(pid interface{}, snippetIID int, noteID int, awardID int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, snippetIID, noteID, awardID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSnippetAwardEmojiOnNote")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, snippetIID, noteID, awardID, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, snippetIID, noteID, awardID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, snippetIID, noteID, awardID, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AwardEmojiServiceInterface_DeleteSnippetAwardEmojiOnNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSnippetAwardEmojiOnNote'
type AwardEmojiServiceInterface_DeleteSnippetAwardEmojiOnNote_Call struct {
	*mock.Call
}

// DeleteSnippetAwardEmojiOnNote is a helper method to define mock.On call
//   - pid interface{}
//   - snippetIID int
//   - noteID int
//   - awardID int
//   - options ...gitlab.RequestOptionFunc
func (_e *AwardEmojiServiceInterface_Expecter) DeleteSnippetAwardEmojiOnNote(pid interface{}, snippetIID interface{}, noteID interface{}, awardID interface{}, options ...interface{}) *AwardEmojiServiceInterface_DeleteSnippetAwardEmojiOnNote_Call {
	return &AwardEmojiServiceInterface_DeleteSnippetAwardEmojiOnNote_Call{Call: _e.mock.On("DeleteSnippetAwardEmojiOnNote",
		append([]interface{}{pid, snippetIID, noteID, awardID}, options...)...)}
}

func (_c *AwardEmojiServiceInterface_DeleteSnippetAwardEmojiOnNote_Call) Run(run func(pid interface{}, snippetIID int, noteID int, awardID int, options ...gitlab.RequestOptionFunc)) *AwardEmojiServiceInterface_DeleteSnippetAwardEmojiOnNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), args[3].(int), variadicArgs...)
	})
	return _c
}

func (_c *AwardEmojiServiceInterface_DeleteSnippetAwardEmojiOnNote_Call) Return(_a0 *gitlab.Response, _a1 error) *AwardEmojiServiceInterface_DeleteSnippetAwardEmojiOnNote_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AwardEmojiServiceInterface_DeleteSnippetAwardEmojiOnNote_Call) RunAndReturn(run func(interface{}, int, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *AwardEmojiServiceInterface_DeleteSnippetAwardEmojiOnNote_Call {
	_c.Call.Return(run)
	return _c
}

// GetIssueAwardEmoji provides a mock function with given fields: pid, issueIID, awardID, options
func (_m *AwardEmojiServiceInterface) GetIssueAwardEmoji(pid interface{}, issueIID int, awardID int, options ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issueIID, awardID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIssueAwardEmoji")
	}

	var r0 *gitlab.AwardEmoji
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error)); ok {
		return rf(pid, issueIID, awardID, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) *gitlab.AwardEmoji); ok {
		r0 = rf(pid, issueIID, awardID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.AwardEmoji)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issueIID, awardID, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issueIID, awardID, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AwardEmojiServiceInterface_GetIssueAwardEmoji_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIssueAwardEmoji'
type AwardEmojiServiceInterface_GetIssueAwardEmoji_Call struct {
	*mock.Call
}

// GetIssueAwardEmoji is a helper method to define mock.On call
//   - pid interface{}
//   - issueIID int
//   - awardID int
//   - options ...gitlab.RequestOptionFunc
func (_e *AwardEmojiServiceInterface_Expecter) GetIssueAwardEmoji(pid interface{}, issueIID interface{}, awardID interface{}, options ...interface{}) *AwardEmojiServiceInterface_GetIssueAwardEmoji_Call {
	return &AwardEmojiServiceInterface_GetIssueAwardEmoji_Call{Call: _e.mock.On("GetIssueAwardEmoji",
		append([]interface{}{pid, issueIID, awardID}, options...)...)}
}

func (_c *AwardEmojiServiceInterface_GetIssueAwardEmoji_Call) Run(run func(pid interface{}, issueIID int, awardID int, options ...gitlab.RequestOptionFunc)) *AwardEmojiServiceInterface_GetIssueAwardEmoji_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), variadicArgs...)
	})
	return _c
}

func (_c *AwardEmojiServiceInterface_GetIssueAwardEmoji_Call) Return(_a0 *gitlab.AwardEmoji, _a1 *gitlab.Response, _a2 error) *AwardEmojiServiceInterface_GetIssueAwardEmoji_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *AwardEmojiServiceInterface_GetIssueAwardEmoji_Call) RunAndReturn(run func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error)) *AwardEmojiServiceInterface_GetIssueAwardEmoji_Call {
	_c.Call.Return(run)
	return _c
}

// GetIssuesAwardEmojiOnNote provides a mock function with given fields: pid, issueID, noteID, awardID, options
func (_m *AwardEmojiServiceInterface) GetIssuesAwardEmojiOnNote(pid interface{}, issueID int, noteID int, awardID int, options ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issueID, noteID, awardID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIssuesAwardEmojiOnNote")
	}

	var r0 *gitlab.AwardEmoji
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, int, ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error)); ok {
		return rf(pid, issueID, noteID, awardID, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, int, ...gitlab.RequestOptionFunc) *gitlab.AwardEmoji); ok {
		r0 = rf(pid, issueID, noteID, awardID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.AwardEmoji)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issueID, noteID, awardID, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, int, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issueID, noteID, awardID, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AwardEmojiServiceInterface_GetIssuesAwardEmojiOnNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIssuesAwardEmojiOnNote'
type AwardEmojiServiceInterface_GetIssuesAwardEmojiOnNote_Call struct {
	*mock.Call
}

// GetIssuesAwardEmojiOnNote is a helper method to define mock.On call
//   - pid interface{}
//   - issueID int
//   - noteID int
//   - awardID int
//   - options ...gitlab.RequestOptionFunc
func (_e *AwardEmojiServiceInterface_Expecter) GetIssuesAwardEmojiOnNote(pid interface{}, issueID interface{}, noteID interface{}, awardID interface{}, options ...interface{}) *AwardEmojiServiceInterface_GetIssuesAwardEmojiOnNote_Call {
	return &AwardEmojiServiceInterface_GetIssuesAwardEmojiOnNote_Call{Call: _e.mock.On("GetIssuesAwardEmojiOnNote",
		append([]interface{}{pid, issueID, noteID, awardID}, options...)...)}
}

func (_c *AwardEmojiServiceInterface_GetIssuesAwardEmojiOnNote_Call) Run(run func(pid interface{}, issueID int, noteID int, awardID int, options ...gitlab.RequestOptionFunc)) *AwardEmojiServiceInterface_GetIssuesAwardEmojiOnNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), args[3].(int), variadicArgs...)
	})
	return _c
}

func (_c *AwardEmojiServiceInterface_GetIssuesAwardEmojiOnNote_Call) Return(_a0 *gitlab.AwardEmoji, _a1 *gitlab.Response, _a2 error) *AwardEmojiServiceInterface_GetIssuesAwardEmojiOnNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *AwardEmojiServiceInterface_GetIssuesAwardEmojiOnNote_Call) RunAndReturn(run func(interface{}, int, int, int, ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error)) *AwardEmojiServiceInterface_GetIssuesAwardEmojiOnNote_Call {
	_c.Call.Return(run)
	return _c
}

// GetMergeRequestAwardEmoji provides a mock function with given fields: pid, mergeRequestIID, awardID, options
func (_m *AwardEmojiServiceInterface) GetMergeRequestAwardEmoji(pid interface{}, mergeRequestIID int, awardID int, options ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequestIID, awardID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMergeRequestAwardEmoji")
	}

	var r0 *gitlab.AwardEmoji
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequestIID, awardID, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) *gitlab.AwardEmoji); ok {
		r0 = rf(pid, mergeRequestIID, awardID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.AwardEmoji)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequestIID, awardID, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequestIID, awardID, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AwardEmojiServiceInterface_GetMergeRequestAwardEmoji_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMergeRequestAwardEmoji'
type AwardEmojiServiceInterface_GetMergeRequestAwardEmoji_Call struct {
	*mock.Call
}

// GetMergeRequestAwardEmoji is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequestIID int
//   - awardID int
//   - options ...gitlab.RequestOptionFunc
func (_e *AwardEmojiServiceInterface_Expecter) GetMergeRequestAwardEmoji(pid interface{}, mergeRequestIID interface{}, awardID interface{}, options ...interface{}) *AwardEmojiServiceInterface_GetMergeRequestAwardEmoji_Call {
	return &AwardEmojiServiceInterface_GetMergeRequestAwardEmoji_Call{Call: _e.mock.On("GetMergeRequestAwardEmoji",
		append([]interface{}{pid, mergeRequestIID, awardID}, options...)...)}
}

func (_c *AwardEmojiServiceInterface_GetMergeRequestAwardEmoji_Call) Run(run func(pid interface{}, mergeRequestIID int, awardID int, options ...gitlab.RequestOptionFunc)) *AwardEmojiServiceInterface_GetMergeRequestAwardEmoji_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), variadicArgs...)
	})
	return _c
}

func (_c *AwardEmojiServiceInterface_GetMergeRequestAwardEmoji_Call) Return(_a0 *gitlab.AwardEmoji, _a1 *gitlab.Response, _a2 error) *AwardEmojiServiceInterface_GetMergeRequestAwardEmoji_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *AwardEmojiServiceInterface_GetMergeRequestAwardEmoji_Call) RunAndReturn(run func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error)) *AwardEmojiServiceInterface_GetMergeRequestAwardEmoji_Call {
	_c.Call.Return(run)
	return _c
}

// GetMergeRequestAwardEmojiOnNote provides a mock function with given fields: pid, mergeRequestIID, noteID, awardID, options
func (_m *AwardEmojiServiceInterface) GetMergeRequestAwardEmojiOnNote(pid interface{}, mergeRequestIID int, noteID int, awardID int, options ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequestIID, noteID, awardID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMergeRequestAwardEmojiOnNote")
	}

	var r0 *gitlab.AwardEmoji
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, int, ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequestIID, noteID, awardID, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, int, ...gitlab.RequestOptionFunc) *gitlab.AwardEmoji); ok {
		r0 = rf(pid, mergeRequestIID, noteID, awardID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.AwardEmoji)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequestIID, noteID, awardID, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, int, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequestIID, noteID, awardID, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AwardEmojiServiceInterface_GetMergeRequestAwardEmojiOnNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMergeRequestAwardEmojiOnNote'
type AwardEmojiServiceInterface_GetMergeRequestAwardEmojiOnNote_Call struct {
	*mock.Call
}

// GetMergeRequestAwardEmojiOnNote is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequestIID int
//   - noteID int
//   - awardID int
//   - options ...gitlab.RequestOptionFunc
func (_e *AwardEmojiServiceInterface_Expecter) GetMergeRequestAwardEmojiOnNote(pid interface{}, mergeRequestIID interface{}, noteID interface{}, awardID interface{}, options ...interface{}) *AwardEmojiServiceInterface_GetMergeRequestAwardEmojiOnNote_Call {
	return &AwardEmojiServiceInterface_GetMergeRequestAwardEmojiOnNote_Call{Call: _e.mock.On("GetMergeRequestAwardEmojiOnNote",
		append([]interface{}{pid, mergeRequestIID, noteID, awardID}, options...)...)}
}

func (_c *AwardEmojiServiceInterface_GetMergeRequestAwardEmojiOnNote_Call) Run(run func(pid interface{}, mergeRequestIID int, noteID int, awardID int, options ...gitlab.RequestOptionFunc)) *AwardEmojiServiceInterface_GetMergeRequestAwardEmojiOnNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), args[3].(int), variadicArgs...)
	})
	return _c
}

func (_c *AwardEmojiServiceInterface_GetMergeRequestAwardEmojiOnNote_Call) Return(_a0 *gitlab.AwardEmoji, _a1 *gitlab.Response, _a2 error) *AwardEmojiServiceInterface_GetMergeRequestAwardEmojiOnNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *AwardEmojiServiceInterface_GetMergeRequestAwardEmojiOnNote_Call) RunAndReturn(run func(interface{}, int, int, int, ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error)) *AwardEmojiServiceInterface_GetMergeRequestAwardEmojiOnNote_Call {
	_c.Call.Return(run)
	return _c
}

// GetSnippetAwardEmoji provides a mock function with given fields: pid, snippetID, awardID, options
func (_m *AwardEmojiServiceInterface) GetSnippetAwardEmoji(pid interface{}, snippetID int, awardID int, options ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, snippetID, awardID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSnippetAwardEmoji")
	}

	var r0 *gitlab.AwardEmoji
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error)); ok {
		return rf(pid, snippetID, awardID, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) *gitlab.AwardEmoji); ok {
		r0 = rf(pid, snippetID, awardID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.AwardEmoji)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, snippetID, awardID, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, snippetID, awardID, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AwardEmojiServiceInterface_GetSnippetAwardEmoji_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSnippetAwardEmoji'
type AwardEmojiServiceInterface_GetSnippetAwardEmoji_Call struct {
	*mock.Call
}

// GetSnippetAwardEmoji is a helper method to define mock.On call
//   - pid interface{}
//   - snippetID int
//   - awardID int
//   - options ...gitlab.RequestOptionFunc
func (_e *AwardEmojiServiceInterface_Expecter) GetSnippetAwardEmoji(pid interface{}, snippetID interface{}, awardID interface{}, options ...interface{}) *AwardEmojiServiceInterface_GetSnippetAwardEmoji_Call {
	return &AwardEmojiServiceInterface_GetSnippetAwardEmoji_Call{Call: _e.mock.On("GetSnippetAwardEmoji",
		append([]interface{}{pid, snippetID, awardID}, options...)...)}
}

func (_c *AwardEmojiServiceInterface_GetSnippetAwardEmoji_Call) Run(run func(pid interface{}, snippetID int, awardID int, options ...gitlab.RequestOptionFunc)) *AwardEmojiServiceInterface_GetSnippetAwardEmoji_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), variadicArgs...)
	})
	return _c
}

func (_c *AwardEmojiServiceInterface_GetSnippetAwardEmoji_Call) Return(_a0 *gitlab.AwardEmoji, _a1 *gitlab.Response, _a2 error) *AwardEmojiServiceInterface_GetSnippetAwardEmoji_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *AwardEmojiServiceInterface_GetSnippetAwardEmoji_Call) RunAndReturn(run func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error)) *AwardEmojiServiceInterface_GetSnippetAwardEmoji_Call {
	_c.Call.Return(run)
	return _c
}

// GetSnippetAwardEmojiOnNote provides a mock function with given fields: pid, snippetIID, noteID, awardID, options
func (_m *AwardEmojiServiceInterface) GetSnippetAwardEmojiOnNote(pid interface{}, snippetIID int, noteID int, awardID int, options ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, snippetIID, noteID, awardID)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSnippetAwardEmojiOnNote")
	}

	var r0 *gitlab.AwardEmoji
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, int, ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error)); ok {
		return rf(pid, snippetIID, noteID, awardID, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, int, ...gitlab.RequestOptionFunc) *gitlab.AwardEmoji); ok {
		r0 = rf(pid, snippetIID, noteID, awardID, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.AwardEmoji)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, snippetIID, noteID, awardID, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, int, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, snippetIID, noteID, awardID, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AwardEmojiServiceInterface_GetSnippetAwardEmojiOnNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSnippetAwardEmojiOnNote'
type AwardEmojiServiceInterface_GetSnippetAwardEmojiOnNote_Call struct {
	*mock.Call
}

// GetSnippetAwardEmojiOnNote is a helper method to define mock.On call
//   - pid interface{}
//   - snippetIID int
//   - noteID int
//   - awardID int
//   - options ...gitlab.RequestOptionFunc
func (_e *AwardEmojiServiceInterface_Expecter) GetSnippetAwardEmojiOnNote(pid interface{}, snippetIID interface{}, noteID interface{}, awardID interface{}, options ...interface{}) *AwardEmojiServiceInterface_GetSnippetAwardEmojiOnNote_Call {
	return &AwardEmojiServiceInterface_GetSnippetAwardEmojiOnNote_Call{Call: _e.mock.On("GetSnippetAwardEmojiOnNote",
		append([]interface{}{pid, snippetIID, noteID, awardID}, options...)...)}
}

func (_c *AwardEmojiServiceInterface_GetSnippetAwardEmojiOnNote_Call) Run(run func(pid interface{}, snippetIID int, noteID int, awardID int, options ...gitlab.RequestOptionFunc)) *AwardEmojiServiceInterface_GetSnippetAwardEmojiOnNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), args[3].(int), variadicArgs...)
	})
	return _c
}

func (_c *AwardEmojiServiceInterface_GetSnippetAwardEmojiOnNote_Call) Return(_a0 *gitlab.AwardEmoji, _a1 *gitlab.Response, _a2 error) *AwardEmojiServiceInterface_GetSnippetAwardEmojiOnNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *AwardEmojiServiceInterface_GetSnippetAwardEmojiOnNote_Call) RunAndReturn(run func(interface{}, int, int, int, ...gitlab.RequestOptionFunc) (*gitlab.AwardEmoji, *gitlab.Response, error)) *AwardEmojiServiceInterface_GetSnippetAwardEmojiOnNote_Call {
	_c.Call.Return(run)
	return _c
}

// ListIssueAwardEmoji provides a mock function with given fields: pid, issueIID, opt, options
func (_m *AwardEmojiServiceInterface) ListIssueAwardEmoji(pid interface{}, issueIID int, opt *gitlab.ListAwardEmojiOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.AwardEmoji, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issueIID, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListIssueAwardEmoji")
	}

	var r0 []*gitlab.AwardEmoji
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.AwardEmoji, *gitlab.Response, error)); ok {
		return rf(pid, issueIID, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) []*gitlab.AwardEmoji); ok {
		r0 = rf(pid, issueIID, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.AwardEmoji)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issueIID, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issueIID, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AwardEmojiServiceInterface_ListIssueAwardEmoji_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListIssueAwardEmoji'
type AwardEmojiServiceInterface_ListIssueAwardEmoji_Call struct {
	*mock.Call
}

// ListIssueAwardEmoji is a helper method to define mock.On call
//   - pid interface{}
//   - issueIID int
//   - opt *gitlab.ListAwardEmojiOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *AwardEmojiServiceInterface_Expecter) ListIssueAwardEmoji(pid interface{}, issueIID interface{}, opt interface{}, options ...interface{}) *AwardEmojiServiceInterface_ListIssueAwardEmoji_Call {
	return &AwardEmojiServiceInterface_ListIssueAwardEmoji_Call{Call: _e.mock.On("ListIssueAwardEmoji",
		append([]interface{}{pid, issueIID, opt}, options...)...)}
}

func (_c *AwardEmojiServiceInterface_ListIssueAwardEmoji_Call) Run(run func(pid interface{}, issueIID int, opt *gitlab.ListAwardEmojiOptions, options ...gitlab.RequestOptionFunc)) *AwardEmojiServiceInterface_ListIssueAwardEmoji_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.ListAwardEmojiOptions), variadicArgs...)
	})
	return _c
}

func (_c *AwardEmojiServiceInterface_ListIssueAwardEmoji_Call) Return(_a0 []*gitlab.AwardEmoji, _a1 *gitlab.Response, _a2 error) *AwardEmojiServiceInterface_ListIssueAwardEmoji_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *AwardEmojiServiceInterface_ListIssueAwardEmoji_Call) RunAndReturn(run func(interface{}, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.AwardEmoji, *gitlab.Response, error)) *AwardEmojiServiceInterface_ListIssueAwardEmoji_Call {
	_c.Call.Return(run)
	return _c
}

// ListIssuesAwardEmojiOnNote provides a mock function with given fields: pid, issueID, noteID, opt, options
func (_m *AwardEmojiServiceInterface) ListIssuesAwardEmojiOnNote(pid interface{}, issueID int, noteID int, opt *gitlab.ListAwardEmojiOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.AwardEmoji, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issueID, noteID, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListIssuesAwardEmojiOnNote")
	}

	var r0 []*gitlab.AwardEmoji
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.AwardEmoji, *gitlab.Response, error)); ok {
		return rf(pid, issueID, noteID, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) []*gitlab.AwardEmoji); ok {
		r0 = rf(pid, issueID, noteID, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.AwardEmoji)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issueID, noteID, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issueID, noteID, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AwardEmojiServiceInterface_ListIssuesAwardEmojiOnNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListIssuesAwardEmojiOnNote'
type AwardEmojiServiceInterface_ListIssuesAwardEmojiOnNote_Call struct {
	*mock.Call
}

// ListIssuesAwardEmojiOnNote is a helper method to define mock.On call
//   - pid interface{}
//   - issueID int
//   - noteID int
//   - opt *gitlab.ListAwardEmojiOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *AwardEmojiServiceInterface_Expecter) ListIssuesAwardEmojiOnNote(pid interface{}, issueID interface{}, noteID interface{}, opt interface{}, options ...interface{}) *AwardEmojiServiceInterface_ListIssuesAwardEmojiOnNote_Call {
	return &AwardEmojiServiceInterface_ListIssuesAwardEmojiOnNote_Call{Call: _e.mock.On("ListIssuesAwardEmojiOnNote",
		append([]interface{}{pid, issueID, noteID, opt}, options...)...)}
}

func (_c *AwardEmojiServiceInterface_ListIssuesAwardEmojiOnNote_Call) Run(run func(pid interface{}, issueID int, noteID int, opt *gitlab.ListAwardEmojiOptions, options ...gitlab.RequestOptionFunc)) *AwardEmojiServiceInterface_ListIssuesAwardEmojiOnNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), args[3].(*gitlab.ListAwardEmojiOptions), variadicArgs...)
	})
	return _c
}

func (_c *AwardEmojiServiceInterface_ListIssuesAwardEmojiOnNote_Call) Return(_a0 []*gitlab.AwardEmoji, _a1 *gitlab.Response, _a2 error) *AwardEmojiServiceInterface_ListIssuesAwardEmojiOnNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *AwardEmojiServiceInterface_ListIssuesAwardEmojiOnNote_Call) RunAndReturn(run func(interface{}, int, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.AwardEmoji, *gitlab.Response, error)) *AwardEmojiServiceInterface_ListIssuesAwardEmojiOnNote_Call {
	_c.Call.Return(run)
	return _c
}

// ListMergeRequestAwardEmoji provides a mock function with given fields: pid, mergeRequestIID, opt, options
func (_m *AwardEmojiServiceInterface) ListMergeRequestAwardEmoji(pid interface{}, mergeRequestIID int, opt *gitlab.ListAwardEmojiOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.AwardEmoji, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequestIID, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMergeRequestAwardEmoji")
	}

	var r0 []*gitlab.AwardEmoji
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.AwardEmoji, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequestIID, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) []*gitlab.AwardEmoji); ok {
		r0 = rf(pid, mergeRequestIID, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.AwardEmoji)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequestIID, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequestIID, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AwardEmojiServiceInterface_ListMergeRequestAwardEmoji_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMergeRequestAwardEmoji'
type AwardEmojiServiceInterface_ListMergeRequestAwardEmoji_Call struct {
	*mock.Call
}

// ListMergeRequestAwardEmoji is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequestIID int
//   - opt *gitlab.ListAwardEmojiOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *AwardEmojiServiceInterface_Expecter) ListMergeRequestAwardEmoji(pid interface{}, mergeRequestIID interface{}, opt interface{}, options ...interface{}) *AwardEmojiServiceInterface_ListMergeRequestAwardEmoji_Call {
	return &AwardEmojiServiceInterface_ListMergeRequestAwardEmoji_Call{Call: _e.mock.On("ListMergeRequestAwardEmoji",
		append([]interface{}{pid, mergeRequestIID, opt}, options...)...)}
}

func (_c *AwardEmojiServiceInterface_ListMergeRequestAwardEmoji_Call) Run(run func(pid interface{}, mergeRequestIID int, opt *gitlab.ListAwardEmojiOptions, options ...gitlab.RequestOptionFunc)) *AwardEmojiServiceInterface_ListMergeRequestAwardEmoji_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.ListAwardEmojiOptions), variadicArgs...)
	})
	return _c
}

func (_c *AwardEmojiServiceInterface_ListMergeRequestAwardEmoji_Call) Return(_a0 []*gitlab.AwardEmoji, _a1 *gitlab.Response, _a2 error) *AwardEmojiServiceInterface_ListMergeRequestAwardEmoji_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *AwardEmojiServiceInterface_ListMergeRequestAwardEmoji_Call) RunAndReturn(run func(interface{}, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.AwardEmoji, *gitlab.Response, error)) *AwardEmojiServiceInterface_ListMergeRequestAwardEmoji_Call {
	_c.Call.Return(run)
	return _c
}

// ListMergeRequestAwardEmojiOnNote provides a mock function with given fields: pid, mergeRequestIID, noteID, opt, options
func (_m *AwardEmojiServiceInterface) ListMergeRequestAwardEmojiOnNote(pid interface{}, mergeRequestIID int, noteID int, opt *gitlab.ListAwardEmojiOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.AwardEmoji, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequestIID, noteID, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMergeRequestAwardEmojiOnNote")
	}

	var r0 []*gitlab.AwardEmoji
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.AwardEmoji, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequestIID, noteID, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) []*gitlab.AwardEmoji); ok {
		r0 = rf(pid, mergeRequestIID, noteID, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.AwardEmoji)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequestIID, noteID, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequestIID, noteID, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AwardEmojiServiceInterface_ListMergeRequestAwardEmojiOnNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMergeRequestAwardEmojiOnNote'
type AwardEmojiServiceInterface_ListMergeRequestAwardEmojiOnNote_Call struct {
	*mock.Call
}

// ListMergeRequestAwardEmojiOnNote is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequestIID int
//   - noteID int
//   - opt *gitlab.ListAwardEmojiOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *AwardEmojiServiceInterface_Expecter) ListMergeRequestAwardEmojiOnNote(pid interface{}, mergeRequestIID interface{}, noteID interface{}, opt interface{}, options ...interface{}) *AwardEmojiServiceInterface_ListMergeRequestAwardEmojiOnNote_Call {
	return &AwardEmojiServiceInterface_ListMergeRequestAwardEmojiOnNote_Call{Call: _e.mock.On("ListMergeRequestAwardEmojiOnNote",
		append([]interface{}{pid, mergeRequestIID, noteID, opt}, options...)...)}
}

func (_c *AwardEmojiServiceInterface_ListMergeRequestAwardEmojiOnNote_Call) Run(run func(pid interface{}, mergeRequestIID int, noteID int, opt *gitlab.ListAwardEmojiOptions, options ...gitlab.RequestOptionFunc)) *AwardEmojiServiceInterface_ListMergeRequestAwardEmojiOnNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), args[3].(*gitlab.ListAwardEmojiOptions), variadicArgs...)
	})
	return _c
}

func (_c *AwardEmojiServiceInterface_ListMergeRequestAwardEmojiOnNote_Call) Return(_a0 []*gitlab.AwardEmoji, _a1 *gitlab.Response, _a2 error) *AwardEmojiServiceInterface_ListMergeRequestAwardEmojiOnNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *AwardEmojiServiceInterface_ListMergeRequestAwardEmojiOnNote_Call) RunAndReturn(run func(interface{}, int, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.AwardEmoji, *gitlab.Response, error)) *AwardEmojiServiceInterface_ListMergeRequestAwardEmojiOnNote_Call {
	_c.Call.Return(run)
	return _c
}

// ListSnippetAwardEmoji provides a mock function with given fields: pid, snippetID, opt, options
func (_m *AwardEmojiServiceInterface) ListSnippetAwardEmoji(pid interface{}, snippetID int, opt *gitlab.ListAwardEmojiOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.AwardEmoji, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, snippetID, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSnippetAwardEmoji")
	}

	var r0 []*gitlab.AwardEmoji
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.AwardEmoji, *gitlab.Response, error)); ok {
		return rf(pid, snippetID, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) []*gitlab.AwardEmoji); ok {
		r0 = rf(pid, snippetID, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.AwardEmoji)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, snippetID, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, snippetID, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AwardEmojiServiceInterface_ListSnippetAwardEmoji_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListSnippetAwardEmoji'
type AwardEmojiServiceInterface_ListSnippetAwardEmoji_Call struct {
	*mock.Call
}

// ListSnippetAwardEmoji is a helper method to define mock.On call
//   - pid interface{}
//   - snippetID int
//   - opt *gitlab.ListAwardEmojiOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *AwardEmojiServiceInterface_Expecter) ListSnippetAwardEmoji(pid interface{}, snippetID interface{}, opt interface{}, options ...interface{}) *AwardEmojiServiceInterface_ListSnippetAwardEmoji_Call {
	return &AwardEmojiServiceInterface_ListSnippetAwardEmoji_Call{Call: _e.mock.On("ListSnippetAwardEmoji",
		append([]interface{}{pid, snippetID, opt}, options...)...)}
}

func (_c *AwardEmojiServiceInterface_ListSnippetAwardEmoji_Call) Run(run func(pid interface{}, snippetID int, opt *gitlab.ListAwardEmojiOptions, options ...gitlab.RequestOptionFunc)) *AwardEmojiServiceInterface_ListSnippetAwardEmoji_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.ListAwardEmojiOptions), variadicArgs...)
	})
	return _c
}

func (_c *AwardEmojiServiceInterface_ListSnippetAwardEmoji_Call) Return(_a0 []*gitlab.AwardEmoji, _a1 *gitlab.Response, _a2 error) *AwardEmojiServiceInterface_ListSnippetAwardEmoji_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *AwardEmojiServiceInterface_ListSnippetAwardEmoji_Call) RunAndReturn(run func(interface{}, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.AwardEmoji, *gitlab.Response, error)) *AwardEmojiServiceInterface_ListSnippetAwardEmoji_Call {
	_c.Call.Return(run)
	return _c
}

// ListSnippetAwardEmojiOnNote provides a mock function with given fields: pid, snippetIID, noteID, opt, options
func (_m *AwardEmojiServiceInterface) ListSnippetAwardEmojiOnNote(pid interface{}, snippetIID int, noteID int, opt *gitlab.ListAwardEmojiOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.AwardEmoji, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, snippetIID, noteID, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSnippetAwardEmojiOnNote")
	}

	var r0 []*gitlab.AwardEmoji
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.AwardEmoji, *gitlab.Response, error)); ok {
		return rf(pid, snippetIID, noteID, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) []*gitlab.AwardEmoji); ok {
		r0 = rf(pid, snippetIID, noteID, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.AwardEmoji)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, snippetIID, noteID, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, snippetIID, noteID, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AwardEmojiServiceInterface_ListSnippetAwardEmojiOnNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListSnippetAwardEmojiOnNote'
type AwardEmojiServiceInterface_ListSnippetAwardEmojiOnNote_Call struct {
	*mock.Call
}

// ListSnippetAwardEmojiOnNote is a helper method to define mock.On call
//   - pid interface{}
//   - snippetIID int
//   - noteID int
//   - opt *gitlab.ListAwardEmojiOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *AwardEmojiServiceInterface_Expecter) ListSnippetAwardEmojiOnNote(pid interface{}, snippetIID interface{}, noteID interface{}, opt interface{}, options ...interface{}) *AwardEmojiServiceInterface_ListSnippetAwardEmojiOnNote_Call {
	return &AwardEmojiServiceInterface_ListSnippetAwardEmojiOnNote_Call{Call: _e.mock.On("ListSnippetAwardEmojiOnNote",
		append([]interface{}{pid, snippetIID, noteID, opt}, options...)...)}
}

func (_c *AwardEmojiServiceInterface_ListSnippetAwardEmojiOnNote_Call) Run(run func(pid interface{}, snippetIID int, noteID int, opt *gitlab.ListAwardEmojiOptions, options ...gitlab.RequestOptionFunc)) *AwardEmojiServiceInterface_ListSnippetAwardEmojiOnNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), args[3].(*gitlab.ListAwardEmojiOptions), variadicArgs...)
	})
	return _c
}

func (_c *AwardEmojiServiceInterface_ListSnippetAwardEmojiOnNote_Call) Return(_a0 []*gitlab.AwardEmoji, _a1 *gitlab.Response, _a2 error) *AwardEmojiServiceInterface_ListSnippetAwardEmojiOnNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *AwardEmojiServiceInterface_ListSnippetAwardEmojiOnNote_Call) RunAndReturn(run func(interface{}, int, int, *gitlab.ListAwardEmojiOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.AwardEmoji, *gitlab.Response, error)) *AwardEmojiServiceInterface_ListSnippetAwardEmojiOnNote_Call {
	_c.Call.Return(run)
	return _c
}

// NewAwardEmojiServiceInterface creates a new instance of AwardEmojiServiceInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewAwardEmojiServiceInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *AwardEmojiServiceInterface {
	mock := &AwardEmojiServiceInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

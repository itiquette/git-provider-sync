// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"
	gitlab "gitlab.com/gitlab-org/api/client-go"
)

// RunnersServiceInterface is an autogenerated mock type for the RunnersServiceInterface type
type RunnersServiceInterface struct {
	mock.Mock
}

type RunnersServiceInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *RunnersServiceInterface) EXPECT() *RunnersServiceInterface_Expecter {
	return &RunnersServiceInterface_Expecter{mock: &_m.Mock}
}

// DeleteRegisteredRunner provides a mock function with given fields: opt, options
func (_m *RunnersServiceInterface) DeleteRegisteredRunner(opt *gitlab.DeleteRegisteredRunnerOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRegisteredRunner")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(*gitlab.DeleteRegisteredRunnerOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(opt, options...)
	}
	if rf, ok := ret.Get(0).(func(*gitlab.DeleteRegisteredRunnerOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(*gitlab.DeleteRegisteredRunnerOptions, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(opt, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunnersServiceInterface_DeleteRegisteredRunner_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRegisteredRunner'
type RunnersServiceInterface_DeleteRegisteredRunner_Call struct {
	*mock.Call
}

// DeleteRegisteredRunner is a helper method to define mock.On call
//   - opt *gitlab.DeleteRegisteredRunnerOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *RunnersServiceInterface_Expecter) DeleteRegisteredRunner(opt interface{}, options ...interface{}) *RunnersServiceInterface_DeleteRegisteredRunner_Call {
	return &RunnersServiceInterface_DeleteRegisteredRunner_Call{Call: _e.mock.On("DeleteRegisteredRunner",
		append([]interface{}{opt}, options...)...)}
}

func (_c *RunnersServiceInterface_DeleteRegisteredRunner_Call) Run(run func(opt *gitlab.DeleteRegisteredRunnerOptions, options ...gitlab.RequestOptionFunc)) *RunnersServiceInterface_DeleteRegisteredRunner_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(*gitlab.DeleteRegisteredRunnerOptions), variadicArgs...)
	})
	return _c
}

func (_c *RunnersServiceInterface_DeleteRegisteredRunner_Call) Return(_a0 *gitlab.Response, _a1 error) *RunnersServiceInterface_DeleteRegisteredRunner_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RunnersServiceInterface_DeleteRegisteredRunner_Call) RunAndReturn(run func(*gitlab.DeleteRegisteredRunnerOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *RunnersServiceInterface_DeleteRegisteredRunner_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteRegisteredRunnerByID provides a mock function with given fields: rid, options
func (_m *RunnersServiceInterface) DeleteRegisteredRunnerByID(rid int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, rid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteRegisteredRunnerByID")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(rid, options...)
	}
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(rid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(rid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunnersServiceInterface_DeleteRegisteredRunnerByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteRegisteredRunnerByID'
type RunnersServiceInterface_DeleteRegisteredRunnerByID_Call struct {
	*mock.Call
}

// DeleteRegisteredRunnerByID is a helper method to define mock.On call
//   - rid int
//   - options ...gitlab.RequestOptionFunc
func (_e *RunnersServiceInterface_Expecter) DeleteRegisteredRunnerByID(rid interface{}, options ...interface{}) *RunnersServiceInterface_DeleteRegisteredRunnerByID_Call {
	return &RunnersServiceInterface_DeleteRegisteredRunnerByID_Call{Call: _e.mock.On("DeleteRegisteredRunnerByID",
		append([]interface{}{rid}, options...)...)}
}

func (_c *RunnersServiceInterface_DeleteRegisteredRunnerByID_Call) Run(run func(rid int, options ...gitlab.RequestOptionFunc)) *RunnersServiceInterface_DeleteRegisteredRunnerByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *RunnersServiceInterface_DeleteRegisteredRunnerByID_Call) Return(_a0 *gitlab.Response, _a1 error) *RunnersServiceInterface_DeleteRegisteredRunnerByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RunnersServiceInterface_DeleteRegisteredRunnerByID_Call) RunAndReturn(run func(int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *RunnersServiceInterface_DeleteRegisteredRunnerByID_Call {
	_c.Call.Return(run)
	return _c
}

// DisableProjectRunner provides a mock function with given fields: pid, runner, options
func (_m *RunnersServiceInterface) DisableProjectRunner(pid interface{}, runner int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, runner)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DisableProjectRunner")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, runner, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, runner, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, runner, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunnersServiceInterface_DisableProjectRunner_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DisableProjectRunner'
type RunnersServiceInterface_DisableProjectRunner_Call struct {
	*mock.Call
}

// DisableProjectRunner is a helper method to define mock.On call
//   - pid interface{}
//   - runner int
//   - options ...gitlab.RequestOptionFunc
func (_e *RunnersServiceInterface_Expecter) DisableProjectRunner(pid interface{}, runner interface{}, options ...interface{}) *RunnersServiceInterface_DisableProjectRunner_Call {
	return &RunnersServiceInterface_DisableProjectRunner_Call{Call: _e.mock.On("DisableProjectRunner",
		append([]interface{}{pid, runner}, options...)...)}
}

func (_c *RunnersServiceInterface_DisableProjectRunner_Call) Run(run func(pid interface{}, runner int, options ...gitlab.RequestOptionFunc)) *RunnersServiceInterface_DisableProjectRunner_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *RunnersServiceInterface_DisableProjectRunner_Call) Return(_a0 *gitlab.Response, _a1 error) *RunnersServiceInterface_DisableProjectRunner_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RunnersServiceInterface_DisableProjectRunner_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *RunnersServiceInterface_DisableProjectRunner_Call {
	_c.Call.Return(run)
	return _c
}

// EnableProjectRunner provides a mock function with given fields: pid, opt, options
func (_m *RunnersServiceInterface) EnableProjectRunner(pid interface{}, opt *gitlab.EnableProjectRunnerOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Runner, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for EnableProjectRunner")
	}

	var r0 *gitlab.Runner
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.EnableProjectRunnerOptions, ...gitlab.RequestOptionFunc) (*gitlab.Runner, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.EnableProjectRunnerOptions, ...gitlab.RequestOptionFunc) *gitlab.Runner); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Runner)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.EnableProjectRunnerOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.EnableProjectRunnerOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// RunnersServiceInterface_EnableProjectRunner_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EnableProjectRunner'
type RunnersServiceInterface_EnableProjectRunner_Call struct {
	*mock.Call
}

// EnableProjectRunner is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.EnableProjectRunnerOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *RunnersServiceInterface_Expecter) EnableProjectRunner(pid interface{}, opt interface{}, options ...interface{}) *RunnersServiceInterface_EnableProjectRunner_Call {
	return &RunnersServiceInterface_EnableProjectRunner_Call{Call: _e.mock.On("EnableProjectRunner",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *RunnersServiceInterface_EnableProjectRunner_Call) Run(run func(pid interface{}, opt *gitlab.EnableProjectRunnerOptions, options ...gitlab.RequestOptionFunc)) *RunnersServiceInterface_EnableProjectRunner_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.EnableProjectRunnerOptions), variadicArgs...)
	})
	return _c
}

func (_c *RunnersServiceInterface_EnableProjectRunner_Call) Return(_a0 *gitlab.Runner, _a1 *gitlab.Response, _a2 error) *RunnersServiceInterface_EnableProjectRunner_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *RunnersServiceInterface_EnableProjectRunner_Call) RunAndReturn(run func(interface{}, *gitlab.EnableProjectRunnerOptions, ...gitlab.RequestOptionFunc) (*gitlab.Runner, *gitlab.Response, error)) *RunnersServiceInterface_EnableProjectRunner_Call {
	_c.Call.Return(run)
	return _c
}

// GetRunnerDetails provides a mock function with given fields: rid, options
func (_m *RunnersServiceInterface) GetRunnerDetails(rid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.RunnerDetails, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, rid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetRunnerDetails")
	}

	var r0 *gitlab.RunnerDetails
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.RunnerDetails, *gitlab.Response, error)); ok {
		return rf(rid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.RunnerDetails); ok {
		r0 = rf(rid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.RunnerDetails)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(rid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(rid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// RunnersServiceInterface_GetRunnerDetails_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRunnerDetails'
type RunnersServiceInterface_GetRunnerDetails_Call struct {
	*mock.Call
}

// GetRunnerDetails is a helper method to define mock.On call
//   - rid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *RunnersServiceInterface_Expecter) GetRunnerDetails(rid interface{}, options ...interface{}) *RunnersServiceInterface_GetRunnerDetails_Call {
	return &RunnersServiceInterface_GetRunnerDetails_Call{Call: _e.mock.On("GetRunnerDetails",
		append([]interface{}{rid}, options...)...)}
}

func (_c *RunnersServiceInterface_GetRunnerDetails_Call) Run(run func(rid interface{}, options ...gitlab.RequestOptionFunc)) *RunnersServiceInterface_GetRunnerDetails_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *RunnersServiceInterface_GetRunnerDetails_Call) Return(_a0 *gitlab.RunnerDetails, _a1 *gitlab.Response, _a2 error) *RunnersServiceInterface_GetRunnerDetails_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *RunnersServiceInterface_GetRunnerDetails_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.RunnerDetails, *gitlab.Response, error)) *RunnersServiceInterface_GetRunnerDetails_Call {
	_c.Call.Return(run)
	return _c
}

// ListAllRunners provides a mock function with given fields: opt, options
func (_m *RunnersServiceInterface) ListAllRunners(opt *gitlab.ListRunnersOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Runner, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListAllRunners")
	}

	var r0 []*gitlab.Runner
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(*gitlab.ListRunnersOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Runner, *gitlab.Response, error)); ok {
		return rf(opt, options...)
	}
	if rf, ok := ret.Get(0).(func(*gitlab.ListRunnersOptions, ...gitlab.RequestOptionFunc) []*gitlab.Runner); ok {
		r0 = rf(opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Runner)
		}
	}

	if rf, ok := ret.Get(1).(func(*gitlab.ListRunnersOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(*gitlab.ListRunnersOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// RunnersServiceInterface_ListAllRunners_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListAllRunners'
type RunnersServiceInterface_ListAllRunners_Call struct {
	*mock.Call
}

// ListAllRunners is a helper method to define mock.On call
//   - opt *gitlab.ListRunnersOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *RunnersServiceInterface_Expecter) ListAllRunners(opt interface{}, options ...interface{}) *RunnersServiceInterface_ListAllRunners_Call {
	return &RunnersServiceInterface_ListAllRunners_Call{Call: _e.mock.On("ListAllRunners",
		append([]interface{}{opt}, options...)...)}
}

func (_c *RunnersServiceInterface_ListAllRunners_Call) Run(run func(opt *gitlab.ListRunnersOptions, options ...gitlab.RequestOptionFunc)) *RunnersServiceInterface_ListAllRunners_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(*gitlab.ListRunnersOptions), variadicArgs...)
	})
	return _c
}

func (_c *RunnersServiceInterface_ListAllRunners_Call) Return(_a0 []*gitlab.Runner, _a1 *gitlab.Response, _a2 error) *RunnersServiceInterface_ListAllRunners_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *RunnersServiceInterface_ListAllRunners_Call) RunAndReturn(run func(*gitlab.ListRunnersOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Runner, *gitlab.Response, error)) *RunnersServiceInterface_ListAllRunners_Call {
	_c.Call.Return(run)
	return _c
}

// ListGroupsRunners provides a mock function with given fields: gid, opt, options
func (_m *RunnersServiceInterface) ListGroupsRunners(gid interface{}, opt *gitlab.ListGroupsRunnersOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Runner, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListGroupsRunners")
	}

	var r0 []*gitlab.Runner
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListGroupsRunnersOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Runner, *gitlab.Response, error)); ok {
		return rf(gid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListGroupsRunnersOptions, ...gitlab.RequestOptionFunc) []*gitlab.Runner); ok {
		r0 = rf(gid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Runner)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListGroupsRunnersOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListGroupsRunnersOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// RunnersServiceInterface_ListGroupsRunners_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListGroupsRunners'
type RunnersServiceInterface_ListGroupsRunners_Call struct {
	*mock.Call
}

// ListGroupsRunners is a helper method to define mock.On call
//   - gid interface{}
//   - opt *gitlab.ListGroupsRunnersOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *RunnersServiceInterface_Expecter) ListGroupsRunners(gid interface{}, opt interface{}, options ...interface{}) *RunnersServiceInterface_ListGroupsRunners_Call {
	return &RunnersServiceInterface_ListGroupsRunners_Call{Call: _e.mock.On("ListGroupsRunners",
		append([]interface{}{gid, opt}, options...)...)}
}

func (_c *RunnersServiceInterface_ListGroupsRunners_Call) Run(run func(gid interface{}, opt *gitlab.ListGroupsRunnersOptions, options ...gitlab.RequestOptionFunc)) *RunnersServiceInterface_ListGroupsRunners_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListGroupsRunnersOptions), variadicArgs...)
	})
	return _c
}

func (_c *RunnersServiceInterface_ListGroupsRunners_Call) Return(_a0 []*gitlab.Runner, _a1 *gitlab.Response, _a2 error) *RunnersServiceInterface_ListGroupsRunners_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *RunnersServiceInterface_ListGroupsRunners_Call) RunAndReturn(run func(interface{}, *gitlab.ListGroupsRunnersOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Runner, *gitlab.Response, error)) *RunnersServiceInterface_ListGroupsRunners_Call {
	_c.Call.Return(run)
	return _c
}

// ListProjectRunners provides a mock function with given fields: pid, opt, options
func (_m *RunnersServiceInterface) ListProjectRunners(pid interface{}, opt *gitlab.ListProjectRunnersOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Runner, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListProjectRunners")
	}

	var r0 []*gitlab.Runner
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListProjectRunnersOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Runner, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListProjectRunnersOptions, ...gitlab.RequestOptionFunc) []*gitlab.Runner); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Runner)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListProjectRunnersOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListProjectRunnersOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// RunnersServiceInterface_ListProjectRunners_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListProjectRunners'
type RunnersServiceInterface_ListProjectRunners_Call struct {
	*mock.Call
}

// ListProjectRunners is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.ListProjectRunnersOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *RunnersServiceInterface_Expecter) ListProjectRunners(pid interface{}, opt interface{}, options ...interface{}) *RunnersServiceInterface_ListProjectRunners_Call {
	return &RunnersServiceInterface_ListProjectRunners_Call{Call: _e.mock.On("ListProjectRunners",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *RunnersServiceInterface_ListProjectRunners_Call) Run(run func(pid interface{}, opt *gitlab.ListProjectRunnersOptions, options ...gitlab.RequestOptionFunc)) *RunnersServiceInterface_ListProjectRunners_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListProjectRunnersOptions), variadicArgs...)
	})
	return _c
}

func (_c *RunnersServiceInterface_ListProjectRunners_Call) Return(_a0 []*gitlab.Runner, _a1 *gitlab.Response, _a2 error) *RunnersServiceInterface_ListProjectRunners_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *RunnersServiceInterface_ListProjectRunners_Call) RunAndReturn(run func(interface{}, *gitlab.ListProjectRunnersOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Runner, *gitlab.Response, error)) *RunnersServiceInterface_ListProjectRunners_Call {
	_c.Call.Return(run)
	return _c
}

// ListRunnerJobs provides a mock function with given fields: rid, opt, options
func (_m *RunnersServiceInterface) ListRunnerJobs(rid interface{}, opt *gitlab.ListRunnerJobsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Job, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, rid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRunnerJobs")
	}

	var r0 []*gitlab.Job
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListRunnerJobsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Job, *gitlab.Response, error)); ok {
		return rf(rid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListRunnerJobsOptions, ...gitlab.RequestOptionFunc) []*gitlab.Job); ok {
		r0 = rf(rid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Job)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListRunnerJobsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(rid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListRunnerJobsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(rid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// RunnersServiceInterface_ListRunnerJobs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRunnerJobs'
type RunnersServiceInterface_ListRunnerJobs_Call struct {
	*mock.Call
}

// ListRunnerJobs is a helper method to define mock.On call
//   - rid interface{}
//   - opt *gitlab.ListRunnerJobsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *RunnersServiceInterface_Expecter) ListRunnerJobs(rid interface{}, opt interface{}, options ...interface{}) *RunnersServiceInterface_ListRunnerJobs_Call {
	return &RunnersServiceInterface_ListRunnerJobs_Call{Call: _e.mock.On("ListRunnerJobs",
		append([]interface{}{rid, opt}, options...)...)}
}

func (_c *RunnersServiceInterface_ListRunnerJobs_Call) Run(run func(rid interface{}, opt *gitlab.ListRunnerJobsOptions, options ...gitlab.RequestOptionFunc)) *RunnersServiceInterface_ListRunnerJobs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListRunnerJobsOptions), variadicArgs...)
	})
	return _c
}

func (_c *RunnersServiceInterface_ListRunnerJobs_Call) Return(_a0 []*gitlab.Job, _a1 *gitlab.Response, _a2 error) *RunnersServiceInterface_ListRunnerJobs_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *RunnersServiceInterface_ListRunnerJobs_Call) RunAndReturn(run func(interface{}, *gitlab.ListRunnerJobsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Job, *gitlab.Response, error)) *RunnersServiceInterface_ListRunnerJobs_Call {
	_c.Call.Return(run)
	return _c
}

// ListRunners provides a mock function with given fields: opt, options
func (_m *RunnersServiceInterface) ListRunners(opt *gitlab.ListRunnersOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Runner, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListRunners")
	}

	var r0 []*gitlab.Runner
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(*gitlab.ListRunnersOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Runner, *gitlab.Response, error)); ok {
		return rf(opt, options...)
	}
	if rf, ok := ret.Get(0).(func(*gitlab.ListRunnersOptions, ...gitlab.RequestOptionFunc) []*gitlab.Runner); ok {
		r0 = rf(opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Runner)
		}
	}

	if rf, ok := ret.Get(1).(func(*gitlab.ListRunnersOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(*gitlab.ListRunnersOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// RunnersServiceInterface_ListRunners_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRunners'
type RunnersServiceInterface_ListRunners_Call struct {
	*mock.Call
}

// ListRunners is a helper method to define mock.On call
//   - opt *gitlab.ListRunnersOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *RunnersServiceInterface_Expecter) ListRunners(opt interface{}, options ...interface{}) *RunnersServiceInterface_ListRunners_Call {
	return &RunnersServiceInterface_ListRunners_Call{Call: _e.mock.On("ListRunners",
		append([]interface{}{opt}, options...)...)}
}

func (_c *RunnersServiceInterface_ListRunners_Call) Run(run func(opt *gitlab.ListRunnersOptions, options ...gitlab.RequestOptionFunc)) *RunnersServiceInterface_ListRunners_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(*gitlab.ListRunnersOptions), variadicArgs...)
	})
	return _c
}

func (_c *RunnersServiceInterface_ListRunners_Call) Return(_a0 []*gitlab.Runner, _a1 *gitlab.Response, _a2 error) *RunnersServiceInterface_ListRunners_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *RunnersServiceInterface_ListRunners_Call) RunAndReturn(run func(*gitlab.ListRunnersOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Runner, *gitlab.Response, error)) *RunnersServiceInterface_ListRunners_Call {
	_c.Call.Return(run)
	return _c
}

// RegisterNewRunner provides a mock function with given fields: opt, options
func (_m *RunnersServiceInterface) RegisterNewRunner(opt *gitlab.RegisterNewRunnerOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Runner, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RegisterNewRunner")
	}

	var r0 *gitlab.Runner
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(*gitlab.RegisterNewRunnerOptions, ...gitlab.RequestOptionFunc) (*gitlab.Runner, *gitlab.Response, error)); ok {
		return rf(opt, options...)
	}
	if rf, ok := ret.Get(0).(func(*gitlab.RegisterNewRunnerOptions, ...gitlab.RequestOptionFunc) *gitlab.Runner); ok {
		r0 = rf(opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Runner)
		}
	}

	if rf, ok := ret.Get(1).(func(*gitlab.RegisterNewRunnerOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(*gitlab.RegisterNewRunnerOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// RunnersServiceInterface_RegisterNewRunner_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RegisterNewRunner'
type RunnersServiceInterface_RegisterNewRunner_Call struct {
	*mock.Call
}

// RegisterNewRunner is a helper method to define mock.On call
//   - opt *gitlab.RegisterNewRunnerOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *RunnersServiceInterface_Expecter) RegisterNewRunner(opt interface{}, options ...interface{}) *RunnersServiceInterface_RegisterNewRunner_Call {
	return &RunnersServiceInterface_RegisterNewRunner_Call{Call: _e.mock.On("RegisterNewRunner",
		append([]interface{}{opt}, options...)...)}
}

func (_c *RunnersServiceInterface_RegisterNewRunner_Call) Run(run func(opt *gitlab.RegisterNewRunnerOptions, options ...gitlab.RequestOptionFunc)) *RunnersServiceInterface_RegisterNewRunner_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(*gitlab.RegisterNewRunnerOptions), variadicArgs...)
	})
	return _c
}

func (_c *RunnersServiceInterface_RegisterNewRunner_Call) Return(_a0 *gitlab.Runner, _a1 *gitlab.Response, _a2 error) *RunnersServiceInterface_RegisterNewRunner_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *RunnersServiceInterface_RegisterNewRunner_Call) RunAndReturn(run func(*gitlab.RegisterNewRunnerOptions, ...gitlab.RequestOptionFunc) (*gitlab.Runner, *gitlab.Response, error)) *RunnersServiceInterface_RegisterNewRunner_Call {
	_c.Call.Return(run)
	return _c
}

// RemoveRunner provides a mock function with given fields: rid, options
func (_m *RunnersServiceInterface) RemoveRunner(rid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, rid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RemoveRunner")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(rid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(rid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(rid, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunnersServiceInterface_RemoveRunner_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RemoveRunner'
type RunnersServiceInterface_RemoveRunner_Call struct {
	*mock.Call
}

// RemoveRunner is a helper method to define mock.On call
//   - rid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *RunnersServiceInterface_Expecter) RemoveRunner(rid interface{}, options ...interface{}) *RunnersServiceInterface_RemoveRunner_Call {
	return &RunnersServiceInterface_RemoveRunner_Call{Call: _e.mock.On("RemoveRunner",
		append([]interface{}{rid}, options...)...)}
}

func (_c *RunnersServiceInterface_RemoveRunner_Call) Run(run func(rid interface{}, options ...gitlab.RequestOptionFunc)) *RunnersServiceInterface_RemoveRunner_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *RunnersServiceInterface_RemoveRunner_Call) Return(_a0 *gitlab.Response, _a1 error) *RunnersServiceInterface_RemoveRunner_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RunnersServiceInterface_RemoveRunner_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *RunnersServiceInterface_RemoveRunner_Call {
	_c.Call.Return(run)
	return _c
}

// ResetGroupRunnerRegistrationToken provides a mock function with given fields: gid, options
func (_m *RunnersServiceInterface) ResetGroupRunnerRegistrationToken(gid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.RunnerRegistrationToken, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetGroupRunnerRegistrationToken")
	}

	var r0 *gitlab.RunnerRegistrationToken
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.RunnerRegistrationToken, *gitlab.Response, error)); ok {
		return rf(gid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.RunnerRegistrationToken); ok {
		r0 = rf(gid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.RunnerRegistrationToken)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// RunnersServiceInterface_ResetGroupRunnerRegistrationToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResetGroupRunnerRegistrationToken'
type RunnersServiceInterface_ResetGroupRunnerRegistrationToken_Call struct {
	*mock.Call
}

// ResetGroupRunnerRegistrationToken is a helper method to define mock.On call
//   - gid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *RunnersServiceInterface_Expecter) ResetGroupRunnerRegistrationToken(gid interface{}, options ...interface{}) *RunnersServiceInterface_ResetGroupRunnerRegistrationToken_Call {
	return &RunnersServiceInterface_ResetGroupRunnerRegistrationToken_Call{Call: _e.mock.On("ResetGroupRunnerRegistrationToken",
		append([]interface{}{gid}, options...)...)}
}

func (_c *RunnersServiceInterface_ResetGroupRunnerRegistrationToken_Call) Run(run func(gid interface{}, options ...gitlab.RequestOptionFunc)) *RunnersServiceInterface_ResetGroupRunnerRegistrationToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *RunnersServiceInterface_ResetGroupRunnerRegistrationToken_Call) Return(_a0 *gitlab.RunnerRegistrationToken, _a1 *gitlab.Response, _a2 error) *RunnersServiceInterface_ResetGroupRunnerRegistrationToken_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *RunnersServiceInterface_ResetGroupRunnerRegistrationToken_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.RunnerRegistrationToken, *gitlab.Response, error)) *RunnersServiceInterface_ResetGroupRunnerRegistrationToken_Call {
	_c.Call.Return(run)
	return _c
}

// ResetInstanceRunnerRegistrationToken provides a mock function with given fields: options
func (_m *RunnersServiceInterface) ResetInstanceRunnerRegistrationToken(options ...gitlab.RequestOptionFunc) (*gitlab.RunnerRegistrationToken, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetInstanceRunnerRegistrationToken")
	}

	var r0 *gitlab.RunnerRegistrationToken
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(...gitlab.RequestOptionFunc) (*gitlab.RunnerRegistrationToken, *gitlab.Response, error)); ok {
		return rf(options...)
	}
	if rf, ok := ret.Get(0).(func(...gitlab.RequestOptionFunc) *gitlab.RunnerRegistrationToken); ok {
		r0 = rf(options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.RunnerRegistrationToken)
		}
	}

	if rf, ok := ret.Get(1).(func(...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// RunnersServiceInterface_ResetInstanceRunnerRegistrationToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResetInstanceRunnerRegistrationToken'
type RunnersServiceInterface_ResetInstanceRunnerRegistrationToken_Call struct {
	*mock.Call
}

// ResetInstanceRunnerRegistrationToken is a helper method to define mock.On call
//   - options ...gitlab.RequestOptionFunc
func (_e *RunnersServiceInterface_Expecter) ResetInstanceRunnerRegistrationToken(options ...interface{}) *RunnersServiceInterface_ResetInstanceRunnerRegistrationToken_Call {
	return &RunnersServiceInterface_ResetInstanceRunnerRegistrationToken_Call{Call: _e.mock.On("ResetInstanceRunnerRegistrationToken",
		append([]interface{}{}, options...)...)}
}

func (_c *RunnersServiceInterface_ResetInstanceRunnerRegistrationToken_Call) Run(run func(options ...gitlab.RequestOptionFunc)) *RunnersServiceInterface_ResetInstanceRunnerRegistrationToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-0)
		for i, a := range args[0:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(variadicArgs...)
	})
	return _c
}

func (_c *RunnersServiceInterface_ResetInstanceRunnerRegistrationToken_Call) Return(_a0 *gitlab.RunnerRegistrationToken, _a1 *gitlab.Response, _a2 error) *RunnersServiceInterface_ResetInstanceRunnerRegistrationToken_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *RunnersServiceInterface_ResetInstanceRunnerRegistrationToken_Call) RunAndReturn(run func(...gitlab.RequestOptionFunc) (*gitlab.RunnerRegistrationToken, *gitlab.Response, error)) *RunnersServiceInterface_ResetInstanceRunnerRegistrationToken_Call {
	_c.Call.Return(run)
	return _c
}

// ResetProjectRunnerRegistrationToken provides a mock function with given fields: pid, options
func (_m *RunnersServiceInterface) ResetProjectRunnerRegistrationToken(pid interface{}, options ...gitlab.RequestOptionFunc) (*gitlab.RunnerRegistrationToken, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetProjectRunnerRegistrationToken")
	}

	var r0 *gitlab.RunnerRegistrationToken
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.RunnerRegistrationToken, *gitlab.Response, error)); ok {
		return rf(pid, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.RunnerRegistrationToken); ok {
		r0 = rf(pid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.RunnerRegistrationToken)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// RunnersServiceInterface_ResetProjectRunnerRegistrationToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResetProjectRunnerRegistrationToken'
type RunnersServiceInterface_ResetProjectRunnerRegistrationToken_Call struct {
	*mock.Call
}

// ResetProjectRunnerRegistrationToken is a helper method to define mock.On call
//   - pid interface{}
//   - options ...gitlab.RequestOptionFunc
func (_e *RunnersServiceInterface_Expecter) ResetProjectRunnerRegistrationToken(pid interface{}, options ...interface{}) *RunnersServiceInterface_ResetProjectRunnerRegistrationToken_Call {
	return &RunnersServiceInterface_ResetProjectRunnerRegistrationToken_Call{Call: _e.mock.On("ResetProjectRunnerRegistrationToken",
		append([]interface{}{pid}, options...)...)}
}

func (_c *RunnersServiceInterface_ResetProjectRunnerRegistrationToken_Call) Run(run func(pid interface{}, options ...gitlab.RequestOptionFunc)) *RunnersServiceInterface_ResetProjectRunnerRegistrationToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *RunnersServiceInterface_ResetProjectRunnerRegistrationToken_Call) Return(_a0 *gitlab.RunnerRegistrationToken, _a1 *gitlab.Response, _a2 error) *RunnersServiceInterface_ResetProjectRunnerRegistrationToken_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *RunnersServiceInterface_ResetProjectRunnerRegistrationToken_Call) RunAndReturn(run func(interface{}, ...gitlab.RequestOptionFunc) (*gitlab.RunnerRegistrationToken, *gitlab.Response, error)) *RunnersServiceInterface_ResetProjectRunnerRegistrationToken_Call {
	_c.Call.Return(run)
	return _c
}

// ResetRunnerAuthenticationToken provides a mock function with given fields: rid, options
func (_m *RunnersServiceInterface) ResetRunnerAuthenticationToken(rid int, options ...gitlab.RequestOptionFunc) (*gitlab.RunnerAuthenticationToken, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, rid)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetRunnerAuthenticationToken")
	}

	var r0 *gitlab.RunnerAuthenticationToken
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) (*gitlab.RunnerAuthenticationToken, *gitlab.Response, error)); ok {
		return rf(rid, options...)
	}
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) *gitlab.RunnerAuthenticationToken); ok {
		r0 = rf(rid, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.RunnerAuthenticationToken)
		}
	}

	if rf, ok := ret.Get(1).(func(int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(rid, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(rid, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// RunnersServiceInterface_ResetRunnerAuthenticationToken_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResetRunnerAuthenticationToken'
type RunnersServiceInterface_ResetRunnerAuthenticationToken_Call struct {
	*mock.Call
}

// ResetRunnerAuthenticationToken is a helper method to define mock.On call
//   - rid int
//   - options ...gitlab.RequestOptionFunc
func (_e *RunnersServiceInterface_Expecter) ResetRunnerAuthenticationToken(rid interface{}, options ...interface{}) *RunnersServiceInterface_ResetRunnerAuthenticationToken_Call {
	return &RunnersServiceInterface_ResetRunnerAuthenticationToken_Call{Call: _e.mock.On("ResetRunnerAuthenticationToken",
		append([]interface{}{rid}, options...)...)}
}

func (_c *RunnersServiceInterface_ResetRunnerAuthenticationToken_Call) Run(run func(rid int, options ...gitlab.RequestOptionFunc)) *RunnersServiceInterface_ResetRunnerAuthenticationToken_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *RunnersServiceInterface_ResetRunnerAuthenticationToken_Call) Return(_a0 *gitlab.RunnerAuthenticationToken, _a1 *gitlab.Response, _a2 error) *RunnersServiceInterface_ResetRunnerAuthenticationToken_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *RunnersServiceInterface_ResetRunnerAuthenticationToken_Call) RunAndReturn(run func(int, ...gitlab.RequestOptionFunc) (*gitlab.RunnerAuthenticationToken, *gitlab.Response, error)) *RunnersServiceInterface_ResetRunnerAuthenticationToken_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateRunnerDetails provides a mock function with given fields: rid, opt, options
func (_m *RunnersServiceInterface) UpdateRunnerDetails(rid interface{}, opt *gitlab.UpdateRunnerDetailsOptions, options ...gitlab.RequestOptionFunc) (*gitlab.RunnerDetails, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, rid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateRunnerDetails")
	}

	var r0 *gitlab.RunnerDetails
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.UpdateRunnerDetailsOptions, ...gitlab.RequestOptionFunc) (*gitlab.RunnerDetails, *gitlab.Response, error)); ok {
		return rf(rid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.UpdateRunnerDetailsOptions, ...gitlab.RequestOptionFunc) *gitlab.RunnerDetails); ok {
		r0 = rf(rid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.RunnerDetails)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.UpdateRunnerDetailsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(rid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.UpdateRunnerDetailsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(rid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// RunnersServiceInterface_UpdateRunnerDetails_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateRunnerDetails'
type RunnersServiceInterface_UpdateRunnerDetails_Call struct {
	*mock.Call
}

// UpdateRunnerDetails is a helper method to define mock.On call
//   - rid interface{}
//   - opt *gitlab.UpdateRunnerDetailsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *RunnersServiceInterface_Expecter) UpdateRunnerDetails(rid interface{}, opt interface{}, options ...interface{}) *RunnersServiceInterface_UpdateRunnerDetails_Call {
	return &RunnersServiceInterface_UpdateRunnerDetails_Call{Call: _e.mock.On("UpdateRunnerDetails",
		append([]interface{}{rid, opt}, options...)...)}
}

func (_c *RunnersServiceInterface_UpdateRunnerDetails_Call) Run(run func(rid interface{}, opt *gitlab.UpdateRunnerDetailsOptions, options ...gitlab.RequestOptionFunc)) *RunnersServiceInterface_UpdateRunnerDetails_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.UpdateRunnerDetailsOptions), variadicArgs...)
	})
	return _c
}

func (_c *RunnersServiceInterface_UpdateRunnerDetails_Call) Return(_a0 *gitlab.RunnerDetails, _a1 *gitlab.Response, _a2 error) *RunnersServiceInterface_UpdateRunnerDetails_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *RunnersServiceInterface_UpdateRunnerDetails_Call) RunAndReturn(run func(interface{}, *gitlab.UpdateRunnerDetailsOptions, ...gitlab.RequestOptionFunc) (*gitlab.RunnerDetails, *gitlab.Response, error)) *RunnersServiceInterface_UpdateRunnerDetails_Call {
	_c.Call.Return(run)
	return _c
}

// VerifyRegisteredRunner provides a mock function with given fields: opt, options
func (_m *RunnersServiceInterface) VerifyRegisteredRunner(opt *gitlab.VerifyRegisteredRunnerOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for VerifyRegisteredRunner")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(*gitlab.VerifyRegisteredRunnerOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(opt, options...)
	}
	if rf, ok := ret.Get(0).(func(*gitlab.VerifyRegisteredRunnerOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(*gitlab.VerifyRegisteredRunnerOptions, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(opt, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunnersServiceInterface_VerifyRegisteredRunner_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VerifyRegisteredRunner'
type RunnersServiceInterface_VerifyRegisteredRunner_Call struct {
	*mock.Call
}

// VerifyRegisteredRunner is a helper method to define mock.On call
//   - opt *gitlab.VerifyRegisteredRunnerOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *RunnersServiceInterface_Expecter) VerifyRegisteredRunner(opt interface{}, options ...interface{}) *RunnersServiceInterface_VerifyRegisteredRunner_Call {
	return &RunnersServiceInterface_VerifyRegisteredRunner_Call{Call: _e.mock.On("VerifyRegisteredRunner",
		append([]interface{}{opt}, options...)...)}
}

func (_c *RunnersServiceInterface_VerifyRegisteredRunner_Call) Run(run func(opt *gitlab.VerifyRegisteredRunnerOptions, options ...gitlab.RequestOptionFunc)) *RunnersServiceInterface_VerifyRegisteredRunner_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(*gitlab.VerifyRegisteredRunnerOptions), variadicArgs...)
	})
	return _c
}

func (_c *RunnersServiceInterface_VerifyRegisteredRunner_Call) Return(_a0 *gitlab.Response, _a1 error) *RunnersServiceInterface_VerifyRegisteredRunner_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RunnersServiceInterface_VerifyRegisteredRunner_Call) RunAndReturn(run func(*gitlab.VerifyRegisteredRunnerOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *RunnersServiceInterface_VerifyRegisteredRunner_Call {
	_c.Call.Return(run)
	return _c
}

// NewRunnersServiceInterface creates a new instance of RunnersServiceInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRunnersServiceInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *RunnersServiceInterface {
	mock := &RunnersServiceInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

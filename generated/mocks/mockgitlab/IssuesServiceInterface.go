// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"
	gitlab "gitlab.com/gitlab-org/api/client-go"
)

// IssuesServiceInterface is an autogenerated mock type for the IssuesServiceInterface type
type IssuesServiceInterface struct {
	mock.Mock
}

type IssuesServiceInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *IssuesServiceInterface) EXPECT() *IssuesServiceInterface_Expecter {
	return &IssuesServiceInterface_Expecter{mock: &_m.Mock}
}

// AddSpentTime provides a mock function with given fields: pid, issue, opt, options
func (_m *IssuesServiceInterface) AddSpentTime(pid interface{}, issue int, opt *gitlab.AddSpentTimeOptions, options ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issue, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddSpentTime")
	}

	var r0 *gitlab.TimeStats
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.AddSpentTimeOptions, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)); ok {
		return rf(pid, issue, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.AddSpentTimeOptions, ...gitlab.RequestOptionFunc) *gitlab.TimeStats); ok {
		r0 = rf(pid, issue, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.TimeStats)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.AddSpentTimeOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issue, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.AddSpentTimeOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issue, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// IssuesServiceInterface_AddSpentTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddSpentTime'
type IssuesServiceInterface_AddSpentTime_Call struct {
	*mock.Call
}

// AddSpentTime is a helper method to define mock.On call
//   - pid interface{}
//   - issue int
//   - opt *gitlab.AddSpentTimeOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *IssuesServiceInterface_Expecter) AddSpentTime(pid interface{}, issue interface{}, opt interface{}, options ...interface{}) *IssuesServiceInterface_AddSpentTime_Call {
	return &IssuesServiceInterface_AddSpentTime_Call{Call: _e.mock.On("AddSpentTime",
		append([]interface{}{pid, issue, opt}, options...)...)}
}

func (_c *IssuesServiceInterface_AddSpentTime_Call) Run(run func(pid interface{}, issue int, opt *gitlab.AddSpentTimeOptions, options ...gitlab.RequestOptionFunc)) *IssuesServiceInterface_AddSpentTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.AddSpentTimeOptions), variadicArgs...)
	})
	return _c
}

func (_c *IssuesServiceInterface_AddSpentTime_Call) Return(_a0 *gitlab.TimeStats, _a1 *gitlab.Response, _a2 error) *IssuesServiceInterface_AddSpentTime_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *IssuesServiceInterface_AddSpentTime_Call) RunAndReturn(run func(interface{}, int, *gitlab.AddSpentTimeOptions, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)) *IssuesServiceInterface_AddSpentTime_Call {
	_c.Call.Return(run)
	return _c
}

// CreateIssue provides a mock function with given fields: pid, opt, options
func (_m *IssuesServiceInterface) CreateIssue(pid interface{}, opt *gitlab.CreateIssueOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIssue")
	}

	var r0 *gitlab.Issue
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.CreateIssueOptions, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.CreateIssueOptions, ...gitlab.RequestOptionFunc) *gitlab.Issue); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Issue)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.CreateIssueOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.CreateIssueOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// IssuesServiceInterface_CreateIssue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateIssue'
type IssuesServiceInterface_CreateIssue_Call struct {
	*mock.Call
}

// CreateIssue is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.CreateIssueOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *IssuesServiceInterface_Expecter) CreateIssue(pid interface{}, opt interface{}, options ...interface{}) *IssuesServiceInterface_CreateIssue_Call {
	return &IssuesServiceInterface_CreateIssue_Call{Call: _e.mock.On("CreateIssue",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *IssuesServiceInterface_CreateIssue_Call) Run(run func(pid interface{}, opt *gitlab.CreateIssueOptions, options ...gitlab.RequestOptionFunc)) *IssuesServiceInterface_CreateIssue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.CreateIssueOptions), variadicArgs...)
	})
	return _c
}

func (_c *IssuesServiceInterface_CreateIssue_Call) Return(_a0 *gitlab.Issue, _a1 *gitlab.Response, _a2 error) *IssuesServiceInterface_CreateIssue_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *IssuesServiceInterface_CreateIssue_Call) RunAndReturn(run func(interface{}, *gitlab.CreateIssueOptions, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)) *IssuesServiceInterface_CreateIssue_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTodo provides a mock function with given fields: pid, issue, options
func (_m *IssuesServiceInterface) CreateTodo(pid interface{}, issue int, options ...gitlab.RequestOptionFunc) (*gitlab.Todo, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issue)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTodo")
	}

	var r0 *gitlab.Todo
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Todo, *gitlab.Response, error)); ok {
		return rf(pid, issue, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Todo); ok {
		r0 = rf(pid, issue, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Todo)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issue, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issue, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// IssuesServiceInterface_CreateTodo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTodo'
type IssuesServiceInterface_CreateTodo_Call struct {
	*mock.Call
}

// CreateTodo is a helper method to define mock.On call
//   - pid interface{}
//   - issue int
//   - options ...gitlab.RequestOptionFunc
func (_e *IssuesServiceInterface_Expecter) CreateTodo(pid interface{}, issue interface{}, options ...interface{}) *IssuesServiceInterface_CreateTodo_Call {
	return &IssuesServiceInterface_CreateTodo_Call{Call: _e.mock.On("CreateTodo",
		append([]interface{}{pid, issue}, options...)...)}
}

func (_c *IssuesServiceInterface_CreateTodo_Call) Run(run func(pid interface{}, issue int, options ...gitlab.RequestOptionFunc)) *IssuesServiceInterface_CreateTodo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *IssuesServiceInterface_CreateTodo_Call) Return(_a0 *gitlab.Todo, _a1 *gitlab.Response, _a2 error) *IssuesServiceInterface_CreateTodo_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *IssuesServiceInterface_CreateTodo_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Todo, *gitlab.Response, error)) *IssuesServiceInterface_CreateTodo_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteIssue provides a mock function with given fields: pid, issue, options
func (_m *IssuesServiceInterface) DeleteIssue(pid interface{}, issue int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issue)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIssue")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, issue, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, issue, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, issue, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IssuesServiceInterface_DeleteIssue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteIssue'
type IssuesServiceInterface_DeleteIssue_Call struct {
	*mock.Call
}

// DeleteIssue is a helper method to define mock.On call
//   - pid interface{}
//   - issue int
//   - options ...gitlab.RequestOptionFunc
func (_e *IssuesServiceInterface_Expecter) DeleteIssue(pid interface{}, issue interface{}, options ...interface{}) *IssuesServiceInterface_DeleteIssue_Call {
	return &IssuesServiceInterface_DeleteIssue_Call{Call: _e.mock.On("DeleteIssue",
		append([]interface{}{pid, issue}, options...)...)}
}

func (_c *IssuesServiceInterface_DeleteIssue_Call) Run(run func(pid interface{}, issue int, options ...gitlab.RequestOptionFunc)) *IssuesServiceInterface_DeleteIssue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *IssuesServiceInterface_DeleteIssue_Call) Return(_a0 *gitlab.Response, _a1 error) *IssuesServiceInterface_DeleteIssue_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *IssuesServiceInterface_DeleteIssue_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *IssuesServiceInterface_DeleteIssue_Call {
	_c.Call.Return(run)
	return _c
}

// GetIssue provides a mock function with given fields: pid, issue, options
func (_m *IssuesServiceInterface) GetIssue(pid interface{}, issue int, options ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issue)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIssue")
	}

	var r0 *gitlab.Issue
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)); ok {
		return rf(pid, issue, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Issue); ok {
		r0 = rf(pid, issue, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Issue)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issue, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issue, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// IssuesServiceInterface_GetIssue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIssue'
type IssuesServiceInterface_GetIssue_Call struct {
	*mock.Call
}

// GetIssue is a helper method to define mock.On call
//   - pid interface{}
//   - issue int
//   - options ...gitlab.RequestOptionFunc
func (_e *IssuesServiceInterface_Expecter) GetIssue(pid interface{}, issue interface{}, options ...interface{}) *IssuesServiceInterface_GetIssue_Call {
	return &IssuesServiceInterface_GetIssue_Call{Call: _e.mock.On("GetIssue",
		append([]interface{}{pid, issue}, options...)...)}
}

func (_c *IssuesServiceInterface_GetIssue_Call) Run(run func(pid interface{}, issue int, options ...gitlab.RequestOptionFunc)) *IssuesServiceInterface_GetIssue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *IssuesServiceInterface_GetIssue_Call) Return(_a0 *gitlab.Issue, _a1 *gitlab.Response, _a2 error) *IssuesServiceInterface_GetIssue_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *IssuesServiceInterface_GetIssue_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)) *IssuesServiceInterface_GetIssue_Call {
	_c.Call.Return(run)
	return _c
}

// GetIssueByID provides a mock function with given fields: issue, options
func (_m *IssuesServiceInterface) GetIssueByID(issue int, options ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, issue)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIssueByID")
	}

	var r0 *gitlab.Issue
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)); ok {
		return rf(issue, options...)
	}
	if rf, ok := ret.Get(0).(func(int, ...gitlab.RequestOptionFunc) *gitlab.Issue); ok {
		r0 = rf(issue, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Issue)
		}
	}

	if rf, ok := ret.Get(1).(func(int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(issue, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(issue, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// IssuesServiceInterface_GetIssueByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIssueByID'
type IssuesServiceInterface_GetIssueByID_Call struct {
	*mock.Call
}

// GetIssueByID is a helper method to define mock.On call
//   - issue int
//   - options ...gitlab.RequestOptionFunc
func (_e *IssuesServiceInterface_Expecter) GetIssueByID(issue interface{}, options ...interface{}) *IssuesServiceInterface_GetIssueByID_Call {
	return &IssuesServiceInterface_GetIssueByID_Call{Call: _e.mock.On("GetIssueByID",
		append([]interface{}{issue}, options...)...)}
}

func (_c *IssuesServiceInterface_GetIssueByID_Call) Run(run func(issue int, options ...gitlab.RequestOptionFunc)) *IssuesServiceInterface_GetIssueByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(int), variadicArgs...)
	})
	return _c
}

func (_c *IssuesServiceInterface_GetIssueByID_Call) Return(_a0 *gitlab.Issue, _a1 *gitlab.Response, _a2 error) *IssuesServiceInterface_GetIssueByID_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *IssuesServiceInterface_GetIssueByID_Call) RunAndReturn(run func(int, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)) *IssuesServiceInterface_GetIssueByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetParticipants provides a mock function with given fields: pid, issue, options
func (_m *IssuesServiceInterface) GetParticipants(pid interface{}, issue int, options ...gitlab.RequestOptionFunc) ([]*gitlab.BasicUser, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issue)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetParticipants")
	}

	var r0 []*gitlab.BasicUser
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) ([]*gitlab.BasicUser, *gitlab.Response, error)); ok {
		return rf(pid, issue, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) []*gitlab.BasicUser); ok {
		r0 = rf(pid, issue, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.BasicUser)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issue, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issue, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// IssuesServiceInterface_GetParticipants_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetParticipants'
type IssuesServiceInterface_GetParticipants_Call struct {
	*mock.Call
}

// GetParticipants is a helper method to define mock.On call
//   - pid interface{}
//   - issue int
//   - options ...gitlab.RequestOptionFunc
func (_e *IssuesServiceInterface_Expecter) GetParticipants(pid interface{}, issue interface{}, options ...interface{}) *IssuesServiceInterface_GetParticipants_Call {
	return &IssuesServiceInterface_GetParticipants_Call{Call: _e.mock.On("GetParticipants",
		append([]interface{}{pid, issue}, options...)...)}
}

func (_c *IssuesServiceInterface_GetParticipants_Call) Run(run func(pid interface{}, issue int, options ...gitlab.RequestOptionFunc)) *IssuesServiceInterface_GetParticipants_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *IssuesServiceInterface_GetParticipants_Call) Return(_a0 []*gitlab.BasicUser, _a1 *gitlab.Response, _a2 error) *IssuesServiceInterface_GetParticipants_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *IssuesServiceInterface_GetParticipants_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) ([]*gitlab.BasicUser, *gitlab.Response, error)) *IssuesServiceInterface_GetParticipants_Call {
	_c.Call.Return(run)
	return _c
}

// GetTimeSpent provides a mock function with given fields: pid, issue, options
func (_m *IssuesServiceInterface) GetTimeSpent(pid interface{}, issue int, options ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issue)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTimeSpent")
	}

	var r0 *gitlab.TimeStats
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)); ok {
		return rf(pid, issue, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.TimeStats); ok {
		r0 = rf(pid, issue, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.TimeStats)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issue, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issue, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// IssuesServiceInterface_GetTimeSpent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTimeSpent'
type IssuesServiceInterface_GetTimeSpent_Call struct {
	*mock.Call
}

// GetTimeSpent is a helper method to define mock.On call
//   - pid interface{}
//   - issue int
//   - options ...gitlab.RequestOptionFunc
func (_e *IssuesServiceInterface_Expecter) GetTimeSpent(pid interface{}, issue interface{}, options ...interface{}) *IssuesServiceInterface_GetTimeSpent_Call {
	return &IssuesServiceInterface_GetTimeSpent_Call{Call: _e.mock.On("GetTimeSpent",
		append([]interface{}{pid, issue}, options...)...)}
}

func (_c *IssuesServiceInterface_GetTimeSpent_Call) Run(run func(pid interface{}, issue int, options ...gitlab.RequestOptionFunc)) *IssuesServiceInterface_GetTimeSpent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *IssuesServiceInterface_GetTimeSpent_Call) Return(_a0 *gitlab.TimeStats, _a1 *gitlab.Response, _a2 error) *IssuesServiceInterface_GetTimeSpent_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *IssuesServiceInterface_GetTimeSpent_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)) *IssuesServiceInterface_GetTimeSpent_Call {
	_c.Call.Return(run)
	return _c
}

// ListGroupIssues provides a mock function with given fields: pid, opt, options
func (_m *IssuesServiceInterface) ListGroupIssues(pid interface{}, opt *gitlab.ListGroupIssuesOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListGroupIssues")
	}

	var r0 []*gitlab.Issue
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListGroupIssuesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListGroupIssuesOptions, ...gitlab.RequestOptionFunc) []*gitlab.Issue); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Issue)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListGroupIssuesOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListGroupIssuesOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// IssuesServiceInterface_ListGroupIssues_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListGroupIssues'
type IssuesServiceInterface_ListGroupIssues_Call struct {
	*mock.Call
}

// ListGroupIssues is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.ListGroupIssuesOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *IssuesServiceInterface_Expecter) ListGroupIssues(pid interface{}, opt interface{}, options ...interface{}) *IssuesServiceInterface_ListGroupIssues_Call {
	return &IssuesServiceInterface_ListGroupIssues_Call{Call: _e.mock.On("ListGroupIssues",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *IssuesServiceInterface_ListGroupIssues_Call) Run(run func(pid interface{}, opt *gitlab.ListGroupIssuesOptions, options ...gitlab.RequestOptionFunc)) *IssuesServiceInterface_ListGroupIssues_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListGroupIssuesOptions), variadicArgs...)
	})
	return _c
}

func (_c *IssuesServiceInterface_ListGroupIssues_Call) Return(_a0 []*gitlab.Issue, _a1 *gitlab.Response, _a2 error) *IssuesServiceInterface_ListGroupIssues_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *IssuesServiceInterface_ListGroupIssues_Call) RunAndReturn(run func(interface{}, *gitlab.ListGroupIssuesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error)) *IssuesServiceInterface_ListGroupIssues_Call {
	_c.Call.Return(run)
	return _c
}

// ListIssues provides a mock function with given fields: opt, options
func (_m *IssuesServiceInterface) ListIssues(opt *gitlab.ListIssuesOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListIssues")
	}

	var r0 []*gitlab.Issue
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(*gitlab.ListIssuesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error)); ok {
		return rf(opt, options...)
	}
	if rf, ok := ret.Get(0).(func(*gitlab.ListIssuesOptions, ...gitlab.RequestOptionFunc) []*gitlab.Issue); ok {
		r0 = rf(opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Issue)
		}
	}

	if rf, ok := ret.Get(1).(func(*gitlab.ListIssuesOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(*gitlab.ListIssuesOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// IssuesServiceInterface_ListIssues_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListIssues'
type IssuesServiceInterface_ListIssues_Call struct {
	*mock.Call
}

// ListIssues is a helper method to define mock.On call
//   - opt *gitlab.ListIssuesOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *IssuesServiceInterface_Expecter) ListIssues(opt interface{}, options ...interface{}) *IssuesServiceInterface_ListIssues_Call {
	return &IssuesServiceInterface_ListIssues_Call{Call: _e.mock.On("ListIssues",
		append([]interface{}{opt}, options...)...)}
}

func (_c *IssuesServiceInterface_ListIssues_Call) Run(run func(opt *gitlab.ListIssuesOptions, options ...gitlab.RequestOptionFunc)) *IssuesServiceInterface_ListIssues_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(*gitlab.ListIssuesOptions), variadicArgs...)
	})
	return _c
}

func (_c *IssuesServiceInterface_ListIssues_Call) Return(_a0 []*gitlab.Issue, _a1 *gitlab.Response, _a2 error) *IssuesServiceInterface_ListIssues_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *IssuesServiceInterface_ListIssues_Call) RunAndReturn(run func(*gitlab.ListIssuesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error)) *IssuesServiceInterface_ListIssues_Call {
	_c.Call.Return(run)
	return _c
}

// ListMergeRequestsClosingIssue provides a mock function with given fields: pid, issue, opt, options
func (_m *IssuesServiceInterface) ListMergeRequestsClosingIssue(pid interface{}, issue int, opt *gitlab.ListMergeRequestsClosingIssueOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.BasicMergeRequest, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issue, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMergeRequestsClosingIssue")
	}

	var r0 []*gitlab.BasicMergeRequest
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListMergeRequestsClosingIssueOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.BasicMergeRequest, *gitlab.Response, error)); ok {
		return rf(pid, issue, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListMergeRequestsClosingIssueOptions, ...gitlab.RequestOptionFunc) []*gitlab.BasicMergeRequest); ok {
		r0 = rf(pid, issue, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.BasicMergeRequest)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.ListMergeRequestsClosingIssueOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issue, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.ListMergeRequestsClosingIssueOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issue, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// IssuesServiceInterface_ListMergeRequestsClosingIssue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMergeRequestsClosingIssue'
type IssuesServiceInterface_ListMergeRequestsClosingIssue_Call struct {
	*mock.Call
}

// ListMergeRequestsClosingIssue is a helper method to define mock.On call
//   - pid interface{}
//   - issue int
//   - opt *gitlab.ListMergeRequestsClosingIssueOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *IssuesServiceInterface_Expecter) ListMergeRequestsClosingIssue(pid interface{}, issue interface{}, opt interface{}, options ...interface{}) *IssuesServiceInterface_ListMergeRequestsClosingIssue_Call {
	return &IssuesServiceInterface_ListMergeRequestsClosingIssue_Call{Call: _e.mock.On("ListMergeRequestsClosingIssue",
		append([]interface{}{pid, issue, opt}, options...)...)}
}

func (_c *IssuesServiceInterface_ListMergeRequestsClosingIssue_Call) Run(run func(pid interface{}, issue int, opt *gitlab.ListMergeRequestsClosingIssueOptions, options ...gitlab.RequestOptionFunc)) *IssuesServiceInterface_ListMergeRequestsClosingIssue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.ListMergeRequestsClosingIssueOptions), variadicArgs...)
	})
	return _c
}

func (_c *IssuesServiceInterface_ListMergeRequestsClosingIssue_Call) Return(_a0 []*gitlab.BasicMergeRequest, _a1 *gitlab.Response, _a2 error) *IssuesServiceInterface_ListMergeRequestsClosingIssue_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *IssuesServiceInterface_ListMergeRequestsClosingIssue_Call) RunAndReturn(run func(interface{}, int, *gitlab.ListMergeRequestsClosingIssueOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.BasicMergeRequest, *gitlab.Response, error)) *IssuesServiceInterface_ListMergeRequestsClosingIssue_Call {
	_c.Call.Return(run)
	return _c
}

// ListMergeRequestsRelatedToIssue provides a mock function with given fields: pid, issue, opt, options
func (_m *IssuesServiceInterface) ListMergeRequestsRelatedToIssue(pid interface{}, issue int, opt *gitlab.ListMergeRequestsRelatedToIssueOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.BasicMergeRequest, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issue, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMergeRequestsRelatedToIssue")
	}

	var r0 []*gitlab.BasicMergeRequest
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListMergeRequestsRelatedToIssueOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.BasicMergeRequest, *gitlab.Response, error)); ok {
		return rf(pid, issue, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListMergeRequestsRelatedToIssueOptions, ...gitlab.RequestOptionFunc) []*gitlab.BasicMergeRequest); ok {
		r0 = rf(pid, issue, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.BasicMergeRequest)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.ListMergeRequestsRelatedToIssueOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issue, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.ListMergeRequestsRelatedToIssueOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issue, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// IssuesServiceInterface_ListMergeRequestsRelatedToIssue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMergeRequestsRelatedToIssue'
type IssuesServiceInterface_ListMergeRequestsRelatedToIssue_Call struct {
	*mock.Call
}

// ListMergeRequestsRelatedToIssue is a helper method to define mock.On call
//   - pid interface{}
//   - issue int
//   - opt *gitlab.ListMergeRequestsRelatedToIssueOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *IssuesServiceInterface_Expecter) ListMergeRequestsRelatedToIssue(pid interface{}, issue interface{}, opt interface{}, options ...interface{}) *IssuesServiceInterface_ListMergeRequestsRelatedToIssue_Call {
	return &IssuesServiceInterface_ListMergeRequestsRelatedToIssue_Call{Call: _e.mock.On("ListMergeRequestsRelatedToIssue",
		append([]interface{}{pid, issue, opt}, options...)...)}
}

func (_c *IssuesServiceInterface_ListMergeRequestsRelatedToIssue_Call) Run(run func(pid interface{}, issue int, opt *gitlab.ListMergeRequestsRelatedToIssueOptions, options ...gitlab.RequestOptionFunc)) *IssuesServiceInterface_ListMergeRequestsRelatedToIssue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.ListMergeRequestsRelatedToIssueOptions), variadicArgs...)
	})
	return _c
}

func (_c *IssuesServiceInterface_ListMergeRequestsRelatedToIssue_Call) Return(_a0 []*gitlab.BasicMergeRequest, _a1 *gitlab.Response, _a2 error) *IssuesServiceInterface_ListMergeRequestsRelatedToIssue_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *IssuesServiceInterface_ListMergeRequestsRelatedToIssue_Call) RunAndReturn(run func(interface{}, int, *gitlab.ListMergeRequestsRelatedToIssueOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.BasicMergeRequest, *gitlab.Response, error)) *IssuesServiceInterface_ListMergeRequestsRelatedToIssue_Call {
	_c.Call.Return(run)
	return _c
}

// ListProjectIssues provides a mock function with given fields: pid, opt, options
func (_m *IssuesServiceInterface) ListProjectIssues(pid interface{}, opt *gitlab.ListProjectIssuesOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListProjectIssues")
	}

	var r0 []*gitlab.Issue
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListProjectIssuesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListProjectIssuesOptions, ...gitlab.RequestOptionFunc) []*gitlab.Issue); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Issue)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListProjectIssuesOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListProjectIssuesOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// IssuesServiceInterface_ListProjectIssues_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListProjectIssues'
type IssuesServiceInterface_ListProjectIssues_Call struct {
	*mock.Call
}

// ListProjectIssues is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.ListProjectIssuesOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *IssuesServiceInterface_Expecter) ListProjectIssues(pid interface{}, opt interface{}, options ...interface{}) *IssuesServiceInterface_ListProjectIssues_Call {
	return &IssuesServiceInterface_ListProjectIssues_Call{Call: _e.mock.On("ListProjectIssues",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *IssuesServiceInterface_ListProjectIssues_Call) Run(run func(pid interface{}, opt *gitlab.ListProjectIssuesOptions, options ...gitlab.RequestOptionFunc)) *IssuesServiceInterface_ListProjectIssues_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListProjectIssuesOptions), variadicArgs...)
	})
	return _c
}

func (_c *IssuesServiceInterface_ListProjectIssues_Call) Return(_a0 []*gitlab.Issue, _a1 *gitlab.Response, _a2 error) *IssuesServiceInterface_ListProjectIssues_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *IssuesServiceInterface_ListProjectIssues_Call) RunAndReturn(run func(interface{}, *gitlab.ListProjectIssuesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error)) *IssuesServiceInterface_ListProjectIssues_Call {
	_c.Call.Return(run)
	return _c
}

// MoveIssue provides a mock function with given fields: pid, issue, opt, options
func (_m *IssuesServiceInterface) MoveIssue(pid interface{}, issue int, opt *gitlab.MoveIssueOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issue, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MoveIssue")
	}

	var r0 *gitlab.Issue
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.MoveIssueOptions, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)); ok {
		return rf(pid, issue, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.MoveIssueOptions, ...gitlab.RequestOptionFunc) *gitlab.Issue); ok {
		r0 = rf(pid, issue, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Issue)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.MoveIssueOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issue, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.MoveIssueOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issue, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// IssuesServiceInterface_MoveIssue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MoveIssue'
type IssuesServiceInterface_MoveIssue_Call struct {
	*mock.Call
}

// MoveIssue is a helper method to define mock.On call
//   - pid interface{}
//   - issue int
//   - opt *gitlab.MoveIssueOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *IssuesServiceInterface_Expecter) MoveIssue(pid interface{}, issue interface{}, opt interface{}, options ...interface{}) *IssuesServiceInterface_MoveIssue_Call {
	return &IssuesServiceInterface_MoveIssue_Call{Call: _e.mock.On("MoveIssue",
		append([]interface{}{pid, issue, opt}, options...)...)}
}

func (_c *IssuesServiceInterface_MoveIssue_Call) Run(run func(pid interface{}, issue int, opt *gitlab.MoveIssueOptions, options ...gitlab.RequestOptionFunc)) *IssuesServiceInterface_MoveIssue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.MoveIssueOptions), variadicArgs...)
	})
	return _c
}

func (_c *IssuesServiceInterface_MoveIssue_Call) Return(_a0 *gitlab.Issue, _a1 *gitlab.Response, _a2 error) *IssuesServiceInterface_MoveIssue_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *IssuesServiceInterface_MoveIssue_Call) RunAndReturn(run func(interface{}, int, *gitlab.MoveIssueOptions, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)) *IssuesServiceInterface_MoveIssue_Call {
	_c.Call.Return(run)
	return _c
}

// ReorderIssue provides a mock function with given fields: pid, issue, opt, options
func (_m *IssuesServiceInterface) ReorderIssue(pid interface{}, issue int, opt *gitlab.ReorderIssueOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issue, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ReorderIssue")
	}

	var r0 *gitlab.Issue
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ReorderIssueOptions, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)); ok {
		return rf(pid, issue, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ReorderIssueOptions, ...gitlab.RequestOptionFunc) *gitlab.Issue); ok {
		r0 = rf(pid, issue, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Issue)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.ReorderIssueOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issue, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.ReorderIssueOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issue, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// IssuesServiceInterface_ReorderIssue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ReorderIssue'
type IssuesServiceInterface_ReorderIssue_Call struct {
	*mock.Call
}

// ReorderIssue is a helper method to define mock.On call
//   - pid interface{}
//   - issue int
//   - opt *gitlab.ReorderIssueOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *IssuesServiceInterface_Expecter) ReorderIssue(pid interface{}, issue interface{}, opt interface{}, options ...interface{}) *IssuesServiceInterface_ReorderIssue_Call {
	return &IssuesServiceInterface_ReorderIssue_Call{Call: _e.mock.On("ReorderIssue",
		append([]interface{}{pid, issue, opt}, options...)...)}
}

func (_c *IssuesServiceInterface_ReorderIssue_Call) Run(run func(pid interface{}, issue int, opt *gitlab.ReorderIssueOptions, options ...gitlab.RequestOptionFunc)) *IssuesServiceInterface_ReorderIssue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.ReorderIssueOptions), variadicArgs...)
	})
	return _c
}

func (_c *IssuesServiceInterface_ReorderIssue_Call) Return(_a0 *gitlab.Issue, _a1 *gitlab.Response, _a2 error) *IssuesServiceInterface_ReorderIssue_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *IssuesServiceInterface_ReorderIssue_Call) RunAndReturn(run func(interface{}, int, *gitlab.ReorderIssueOptions, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)) *IssuesServiceInterface_ReorderIssue_Call {
	_c.Call.Return(run)
	return _c
}

// ResetSpentTime provides a mock function with given fields: pid, issue, options
func (_m *IssuesServiceInterface) ResetSpentTime(pid interface{}, issue int, options ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issue)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetSpentTime")
	}

	var r0 *gitlab.TimeStats
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)); ok {
		return rf(pid, issue, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.TimeStats); ok {
		r0 = rf(pid, issue, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.TimeStats)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issue, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issue, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// IssuesServiceInterface_ResetSpentTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResetSpentTime'
type IssuesServiceInterface_ResetSpentTime_Call struct {
	*mock.Call
}

// ResetSpentTime is a helper method to define mock.On call
//   - pid interface{}
//   - issue int
//   - options ...gitlab.RequestOptionFunc
func (_e *IssuesServiceInterface_Expecter) ResetSpentTime(pid interface{}, issue interface{}, options ...interface{}) *IssuesServiceInterface_ResetSpentTime_Call {
	return &IssuesServiceInterface_ResetSpentTime_Call{Call: _e.mock.On("ResetSpentTime",
		append([]interface{}{pid, issue}, options...)...)}
}

func (_c *IssuesServiceInterface_ResetSpentTime_Call) Run(run func(pid interface{}, issue int, options ...gitlab.RequestOptionFunc)) *IssuesServiceInterface_ResetSpentTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *IssuesServiceInterface_ResetSpentTime_Call) Return(_a0 *gitlab.TimeStats, _a1 *gitlab.Response, _a2 error) *IssuesServiceInterface_ResetSpentTime_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *IssuesServiceInterface_ResetSpentTime_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)) *IssuesServiceInterface_ResetSpentTime_Call {
	_c.Call.Return(run)
	return _c
}

// ResetTimeEstimate provides a mock function with given fields: pid, issue, options
func (_m *IssuesServiceInterface) ResetTimeEstimate(pid interface{}, issue int, options ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issue)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetTimeEstimate")
	}

	var r0 *gitlab.TimeStats
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)); ok {
		return rf(pid, issue, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.TimeStats); ok {
		r0 = rf(pid, issue, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.TimeStats)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issue, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issue, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// IssuesServiceInterface_ResetTimeEstimate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResetTimeEstimate'
type IssuesServiceInterface_ResetTimeEstimate_Call struct {
	*mock.Call
}

// ResetTimeEstimate is a helper method to define mock.On call
//   - pid interface{}
//   - issue int
//   - options ...gitlab.RequestOptionFunc
func (_e *IssuesServiceInterface_Expecter) ResetTimeEstimate(pid interface{}, issue interface{}, options ...interface{}) *IssuesServiceInterface_ResetTimeEstimate_Call {
	return &IssuesServiceInterface_ResetTimeEstimate_Call{Call: _e.mock.On("ResetTimeEstimate",
		append([]interface{}{pid, issue}, options...)...)}
}

func (_c *IssuesServiceInterface_ResetTimeEstimate_Call) Run(run func(pid interface{}, issue int, options ...gitlab.RequestOptionFunc)) *IssuesServiceInterface_ResetTimeEstimate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *IssuesServiceInterface_ResetTimeEstimate_Call) Return(_a0 *gitlab.TimeStats, _a1 *gitlab.Response, _a2 error) *IssuesServiceInterface_ResetTimeEstimate_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *IssuesServiceInterface_ResetTimeEstimate_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)) *IssuesServiceInterface_ResetTimeEstimate_Call {
	_c.Call.Return(run)
	return _c
}

// SetTimeEstimate provides a mock function with given fields: pid, issue, opt, options
func (_m *IssuesServiceInterface) SetTimeEstimate(pid interface{}, issue int, opt *gitlab.SetTimeEstimateOptions, options ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issue, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetTimeEstimate")
	}

	var r0 *gitlab.TimeStats
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.SetTimeEstimateOptions, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)); ok {
		return rf(pid, issue, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.SetTimeEstimateOptions, ...gitlab.RequestOptionFunc) *gitlab.TimeStats); ok {
		r0 = rf(pid, issue, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.TimeStats)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.SetTimeEstimateOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issue, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.SetTimeEstimateOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issue, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// IssuesServiceInterface_SetTimeEstimate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetTimeEstimate'
type IssuesServiceInterface_SetTimeEstimate_Call struct {
	*mock.Call
}

// SetTimeEstimate is a helper method to define mock.On call
//   - pid interface{}
//   - issue int
//   - opt *gitlab.SetTimeEstimateOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *IssuesServiceInterface_Expecter) SetTimeEstimate(pid interface{}, issue interface{}, opt interface{}, options ...interface{}) *IssuesServiceInterface_SetTimeEstimate_Call {
	return &IssuesServiceInterface_SetTimeEstimate_Call{Call: _e.mock.On("SetTimeEstimate",
		append([]interface{}{pid, issue, opt}, options...)...)}
}

func (_c *IssuesServiceInterface_SetTimeEstimate_Call) Run(run func(pid interface{}, issue int, opt *gitlab.SetTimeEstimateOptions, options ...gitlab.RequestOptionFunc)) *IssuesServiceInterface_SetTimeEstimate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.SetTimeEstimateOptions), variadicArgs...)
	})
	return _c
}

func (_c *IssuesServiceInterface_SetTimeEstimate_Call) Return(_a0 *gitlab.TimeStats, _a1 *gitlab.Response, _a2 error) *IssuesServiceInterface_SetTimeEstimate_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *IssuesServiceInterface_SetTimeEstimate_Call) RunAndReturn(run func(interface{}, int, *gitlab.SetTimeEstimateOptions, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)) *IssuesServiceInterface_SetTimeEstimate_Call {
	_c.Call.Return(run)
	return _c
}

// SubscribeToIssue provides a mock function with given fields: pid, issue, options
func (_m *IssuesServiceInterface) SubscribeToIssue(pid interface{}, issue int, options ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issue)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SubscribeToIssue")
	}

	var r0 *gitlab.Issue
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)); ok {
		return rf(pid, issue, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Issue); ok {
		r0 = rf(pid, issue, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Issue)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issue, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issue, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// IssuesServiceInterface_SubscribeToIssue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscribeToIssue'
type IssuesServiceInterface_SubscribeToIssue_Call struct {
	*mock.Call
}

// SubscribeToIssue is a helper method to define mock.On call
//   - pid interface{}
//   - issue int
//   - options ...gitlab.RequestOptionFunc
func (_e *IssuesServiceInterface_Expecter) SubscribeToIssue(pid interface{}, issue interface{}, options ...interface{}) *IssuesServiceInterface_SubscribeToIssue_Call {
	return &IssuesServiceInterface_SubscribeToIssue_Call{Call: _e.mock.On("SubscribeToIssue",
		append([]interface{}{pid, issue}, options...)...)}
}

func (_c *IssuesServiceInterface_SubscribeToIssue_Call) Run(run func(pid interface{}, issue int, options ...gitlab.RequestOptionFunc)) *IssuesServiceInterface_SubscribeToIssue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *IssuesServiceInterface_SubscribeToIssue_Call) Return(_a0 *gitlab.Issue, _a1 *gitlab.Response, _a2 error) *IssuesServiceInterface_SubscribeToIssue_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *IssuesServiceInterface_SubscribeToIssue_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)) *IssuesServiceInterface_SubscribeToIssue_Call {
	_c.Call.Return(run)
	return _c
}

// UnsubscribeFromIssue provides a mock function with given fields: pid, issue, options
func (_m *IssuesServiceInterface) UnsubscribeFromIssue(pid interface{}, issue int, options ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issue)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnsubscribeFromIssue")
	}

	var r0 *gitlab.Issue
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)); ok {
		return rf(pid, issue, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Issue); ok {
		r0 = rf(pid, issue, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Issue)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issue, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issue, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// IssuesServiceInterface_UnsubscribeFromIssue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsubscribeFromIssue'
type IssuesServiceInterface_UnsubscribeFromIssue_Call struct {
	*mock.Call
}

// UnsubscribeFromIssue is a helper method to define mock.On call
//   - pid interface{}
//   - issue int
//   - options ...gitlab.RequestOptionFunc
func (_e *IssuesServiceInterface_Expecter) UnsubscribeFromIssue(pid interface{}, issue interface{}, options ...interface{}) *IssuesServiceInterface_UnsubscribeFromIssue_Call {
	return &IssuesServiceInterface_UnsubscribeFromIssue_Call{Call: _e.mock.On("UnsubscribeFromIssue",
		append([]interface{}{pid, issue}, options...)...)}
}

func (_c *IssuesServiceInterface_UnsubscribeFromIssue_Call) Run(run func(pid interface{}, issue int, options ...gitlab.RequestOptionFunc)) *IssuesServiceInterface_UnsubscribeFromIssue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *IssuesServiceInterface_UnsubscribeFromIssue_Call) Return(_a0 *gitlab.Issue, _a1 *gitlab.Response, _a2 error) *IssuesServiceInterface_UnsubscribeFromIssue_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *IssuesServiceInterface_UnsubscribeFromIssue_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)) *IssuesServiceInterface_UnsubscribeFromIssue_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateIssue provides a mock function with given fields: pid, issue, opt, options
func (_m *IssuesServiceInterface) UpdateIssue(pid interface{}, issue int, opt *gitlab.UpdateIssueOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issue, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateIssue")
	}

	var r0 *gitlab.Issue
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.UpdateIssueOptions, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)); ok {
		return rf(pid, issue, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.UpdateIssueOptions, ...gitlab.RequestOptionFunc) *gitlab.Issue); ok {
		r0 = rf(pid, issue, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Issue)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.UpdateIssueOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issue, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.UpdateIssueOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issue, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// IssuesServiceInterface_UpdateIssue_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateIssue'
type IssuesServiceInterface_UpdateIssue_Call struct {
	*mock.Call
}

// UpdateIssue is a helper method to define mock.On call
//   - pid interface{}
//   - issue int
//   - opt *gitlab.UpdateIssueOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *IssuesServiceInterface_Expecter) UpdateIssue(pid interface{}, issue interface{}, opt interface{}, options ...interface{}) *IssuesServiceInterface_UpdateIssue_Call {
	return &IssuesServiceInterface_UpdateIssue_Call{Call: _e.mock.On("UpdateIssue",
		append([]interface{}{pid, issue, opt}, options...)...)}
}

func (_c *IssuesServiceInterface_UpdateIssue_Call) Run(run func(pid interface{}, issue int, opt *gitlab.UpdateIssueOptions, options ...gitlab.RequestOptionFunc)) *IssuesServiceInterface_UpdateIssue_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.UpdateIssueOptions), variadicArgs...)
	})
	return _c
}

func (_c *IssuesServiceInterface_UpdateIssue_Call) Return(_a0 *gitlab.Issue, _a1 *gitlab.Response, _a2 error) *IssuesServiceInterface_UpdateIssue_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *IssuesServiceInterface_UpdateIssue_Call) RunAndReturn(run func(interface{}, int, *gitlab.UpdateIssueOptions, ...gitlab.RequestOptionFunc) (*gitlab.Issue, *gitlab.Response, error)) *IssuesServiceInterface_UpdateIssue_Call {
	_c.Call.Return(run)
	return _c
}

// NewIssuesServiceInterface creates a new instance of IssuesServiceInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewIssuesServiceInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *IssuesServiceInterface {
	mock := &IssuesServiceInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

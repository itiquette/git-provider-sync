// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"
	gitlab "gitlab.com/gitlab-org/api/client-go"
)

// SearchServiceInterface is an autogenerated mock type for the SearchServiceInterface type
type SearchServiceInterface struct {
	mock.Mock
}

type SearchServiceInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *SearchServiceInterface) EXPECT() *SearchServiceInterface_Expecter {
	return &SearchServiceInterface_Expecter{mock: &_m.Mock}
}

// Blobs provides a mock function with given fields: query, opt, options
func (_m *SearchServiceInterface) Blobs(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Blob, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, query, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Blobs")
	}

	var r0 []*gitlab.Blob
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Blob, *gitlab.Response, error)); ok {
		return rf(query, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) []*gitlab.Blob); ok {
		r0 = rf(query, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Blob)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(query, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(query, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SearchServiceInterface_Blobs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Blobs'
type SearchServiceInterface_Blobs_Call struct {
	*mock.Call
}

// Blobs is a helper method to define mock.On call
//   - query string
//   - opt *gitlab.SearchOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *SearchServiceInterface_Expecter) Blobs(query interface{}, opt interface{}, options ...interface{}) *SearchServiceInterface_Blobs_Call {
	return &SearchServiceInterface_Blobs_Call{Call: _e.mock.On("Blobs",
		append([]interface{}{query, opt}, options...)...)}
}

func (_c *SearchServiceInterface_Blobs_Call) Run(run func(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc)) *SearchServiceInterface_Blobs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(string), args[1].(*gitlab.SearchOptions), variadicArgs...)
	})
	return _c
}

func (_c *SearchServiceInterface_Blobs_Call) Return(_a0 []*gitlab.Blob, _a1 *gitlab.Response, _a2 error) *SearchServiceInterface_Blobs_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *SearchServiceInterface_Blobs_Call) RunAndReturn(run func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Blob, *gitlab.Response, error)) *SearchServiceInterface_Blobs_Call {
	_c.Call.Return(run)
	return _c
}

// BlobsByGroup provides a mock function with given fields: gid, query, opt, options
func (_m *SearchServiceInterface) BlobsByGroup(gid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Blob, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, query, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BlobsByGroup")
	}

	var r0 []*gitlab.Blob
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Blob, *gitlab.Response, error)); ok {
		return rf(gid, query, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) []*gitlab.Blob); ok {
		r0 = rf(gid, query, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Blob)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, query, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, query, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SearchServiceInterface_BlobsByGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlobsByGroup'
type SearchServiceInterface_BlobsByGroup_Call struct {
	*mock.Call
}

// BlobsByGroup is a helper method to define mock.On call
//   - gid interface{}
//   - query string
//   - opt *gitlab.SearchOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *SearchServiceInterface_Expecter) BlobsByGroup(gid interface{}, query interface{}, opt interface{}, options ...interface{}) *SearchServiceInterface_BlobsByGroup_Call {
	return &SearchServiceInterface_BlobsByGroup_Call{Call: _e.mock.On("BlobsByGroup",
		append([]interface{}{gid, query, opt}, options...)...)}
}

func (_c *SearchServiceInterface_BlobsByGroup_Call) Run(run func(gid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc)) *SearchServiceInterface_BlobsByGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(*gitlab.SearchOptions), variadicArgs...)
	})
	return _c
}

func (_c *SearchServiceInterface_BlobsByGroup_Call) Return(_a0 []*gitlab.Blob, _a1 *gitlab.Response, _a2 error) *SearchServiceInterface_BlobsByGroup_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *SearchServiceInterface_BlobsByGroup_Call) RunAndReturn(run func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Blob, *gitlab.Response, error)) *SearchServiceInterface_BlobsByGroup_Call {
	_c.Call.Return(run)
	return _c
}

// BlobsByProject provides a mock function with given fields: pid, query, opt, options
func (_m *SearchServiceInterface) BlobsByProject(pid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Blob, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, query, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BlobsByProject")
	}

	var r0 []*gitlab.Blob
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Blob, *gitlab.Response, error)); ok {
		return rf(pid, query, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) []*gitlab.Blob); ok {
		r0 = rf(pid, query, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Blob)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, query, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, query, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SearchServiceInterface_BlobsByProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlobsByProject'
type SearchServiceInterface_BlobsByProject_Call struct {
	*mock.Call
}

// BlobsByProject is a helper method to define mock.On call
//   - pid interface{}
//   - query string
//   - opt *gitlab.SearchOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *SearchServiceInterface_Expecter) BlobsByProject(pid interface{}, query interface{}, opt interface{}, options ...interface{}) *SearchServiceInterface_BlobsByProject_Call {
	return &SearchServiceInterface_BlobsByProject_Call{Call: _e.mock.On("BlobsByProject",
		append([]interface{}{pid, query, opt}, options...)...)}
}

func (_c *SearchServiceInterface_BlobsByProject_Call) Run(run func(pid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc)) *SearchServiceInterface_BlobsByProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(*gitlab.SearchOptions), variadicArgs...)
	})
	return _c
}

func (_c *SearchServiceInterface_BlobsByProject_Call) Return(_a0 []*gitlab.Blob, _a1 *gitlab.Response, _a2 error) *SearchServiceInterface_BlobsByProject_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *SearchServiceInterface_BlobsByProject_Call) RunAndReturn(run func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Blob, *gitlab.Response, error)) *SearchServiceInterface_BlobsByProject_Call {
	_c.Call.Return(run)
	return _c
}

// Commits provides a mock function with given fields: query, opt, options
func (_m *SearchServiceInterface) Commits(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Commit, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, query, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Commits")
	}

	var r0 []*gitlab.Commit
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Commit, *gitlab.Response, error)); ok {
		return rf(query, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) []*gitlab.Commit); ok {
		r0 = rf(query, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Commit)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(query, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(query, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SearchServiceInterface_Commits_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Commits'
type SearchServiceInterface_Commits_Call struct {
	*mock.Call
}

// Commits is a helper method to define mock.On call
//   - query string
//   - opt *gitlab.SearchOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *SearchServiceInterface_Expecter) Commits(query interface{}, opt interface{}, options ...interface{}) *SearchServiceInterface_Commits_Call {
	return &SearchServiceInterface_Commits_Call{Call: _e.mock.On("Commits",
		append([]interface{}{query, opt}, options...)...)}
}

func (_c *SearchServiceInterface_Commits_Call) Run(run func(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc)) *SearchServiceInterface_Commits_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(string), args[1].(*gitlab.SearchOptions), variadicArgs...)
	})
	return _c
}

func (_c *SearchServiceInterface_Commits_Call) Return(_a0 []*gitlab.Commit, _a1 *gitlab.Response, _a2 error) *SearchServiceInterface_Commits_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *SearchServiceInterface_Commits_Call) RunAndReturn(run func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Commit, *gitlab.Response, error)) *SearchServiceInterface_Commits_Call {
	_c.Call.Return(run)
	return _c
}

// CommitsByGroup provides a mock function with given fields: gid, query, opt, options
func (_m *SearchServiceInterface) CommitsByGroup(gid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Commit, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, query, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CommitsByGroup")
	}

	var r0 []*gitlab.Commit
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Commit, *gitlab.Response, error)); ok {
		return rf(gid, query, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) []*gitlab.Commit); ok {
		r0 = rf(gid, query, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Commit)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, query, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, query, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SearchServiceInterface_CommitsByGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CommitsByGroup'
type SearchServiceInterface_CommitsByGroup_Call struct {
	*mock.Call
}

// CommitsByGroup is a helper method to define mock.On call
//   - gid interface{}
//   - query string
//   - opt *gitlab.SearchOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *SearchServiceInterface_Expecter) CommitsByGroup(gid interface{}, query interface{}, opt interface{}, options ...interface{}) *SearchServiceInterface_CommitsByGroup_Call {
	return &SearchServiceInterface_CommitsByGroup_Call{Call: _e.mock.On("CommitsByGroup",
		append([]interface{}{gid, query, opt}, options...)...)}
}

func (_c *SearchServiceInterface_CommitsByGroup_Call) Run(run func(gid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc)) *SearchServiceInterface_CommitsByGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(*gitlab.SearchOptions), variadicArgs...)
	})
	return _c
}

func (_c *SearchServiceInterface_CommitsByGroup_Call) Return(_a0 []*gitlab.Commit, _a1 *gitlab.Response, _a2 error) *SearchServiceInterface_CommitsByGroup_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *SearchServiceInterface_CommitsByGroup_Call) RunAndReturn(run func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Commit, *gitlab.Response, error)) *SearchServiceInterface_CommitsByGroup_Call {
	_c.Call.Return(run)
	return _c
}

// CommitsByProject provides a mock function with given fields: pid, query, opt, options
func (_m *SearchServiceInterface) CommitsByProject(pid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Commit, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, query, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CommitsByProject")
	}

	var r0 []*gitlab.Commit
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Commit, *gitlab.Response, error)); ok {
		return rf(pid, query, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) []*gitlab.Commit); ok {
		r0 = rf(pid, query, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Commit)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, query, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, query, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SearchServiceInterface_CommitsByProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CommitsByProject'
type SearchServiceInterface_CommitsByProject_Call struct {
	*mock.Call
}

// CommitsByProject is a helper method to define mock.On call
//   - pid interface{}
//   - query string
//   - opt *gitlab.SearchOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *SearchServiceInterface_Expecter) CommitsByProject(pid interface{}, query interface{}, opt interface{}, options ...interface{}) *SearchServiceInterface_CommitsByProject_Call {
	return &SearchServiceInterface_CommitsByProject_Call{Call: _e.mock.On("CommitsByProject",
		append([]interface{}{pid, query, opt}, options...)...)}
}

func (_c *SearchServiceInterface_CommitsByProject_Call) Run(run func(pid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc)) *SearchServiceInterface_CommitsByProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(*gitlab.SearchOptions), variadicArgs...)
	})
	return _c
}

func (_c *SearchServiceInterface_CommitsByProject_Call) Return(_a0 []*gitlab.Commit, _a1 *gitlab.Response, _a2 error) *SearchServiceInterface_CommitsByProject_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *SearchServiceInterface_CommitsByProject_Call) RunAndReturn(run func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Commit, *gitlab.Response, error)) *SearchServiceInterface_CommitsByProject_Call {
	_c.Call.Return(run)
	return _c
}

// Issues provides a mock function with given fields: query, opt, options
func (_m *SearchServiceInterface) Issues(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, query, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Issues")
	}

	var r0 []*gitlab.Issue
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error)); ok {
		return rf(query, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) []*gitlab.Issue); ok {
		r0 = rf(query, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Issue)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(query, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(query, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SearchServiceInterface_Issues_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Issues'
type SearchServiceInterface_Issues_Call struct {
	*mock.Call
}

// Issues is a helper method to define mock.On call
//   - query string
//   - opt *gitlab.SearchOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *SearchServiceInterface_Expecter) Issues(query interface{}, opt interface{}, options ...interface{}) *SearchServiceInterface_Issues_Call {
	return &SearchServiceInterface_Issues_Call{Call: _e.mock.On("Issues",
		append([]interface{}{query, opt}, options...)...)}
}

func (_c *SearchServiceInterface_Issues_Call) Run(run func(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc)) *SearchServiceInterface_Issues_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(string), args[1].(*gitlab.SearchOptions), variadicArgs...)
	})
	return _c
}

func (_c *SearchServiceInterface_Issues_Call) Return(_a0 []*gitlab.Issue, _a1 *gitlab.Response, _a2 error) *SearchServiceInterface_Issues_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *SearchServiceInterface_Issues_Call) RunAndReturn(run func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error)) *SearchServiceInterface_Issues_Call {
	_c.Call.Return(run)
	return _c
}

// IssuesByGroup provides a mock function with given fields: gid, query, opt, options
func (_m *SearchServiceInterface) IssuesByGroup(gid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, query, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IssuesByGroup")
	}

	var r0 []*gitlab.Issue
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error)); ok {
		return rf(gid, query, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) []*gitlab.Issue); ok {
		r0 = rf(gid, query, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Issue)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, query, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, query, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SearchServiceInterface_IssuesByGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IssuesByGroup'
type SearchServiceInterface_IssuesByGroup_Call struct {
	*mock.Call
}

// IssuesByGroup is a helper method to define mock.On call
//   - gid interface{}
//   - query string
//   - opt *gitlab.SearchOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *SearchServiceInterface_Expecter) IssuesByGroup(gid interface{}, query interface{}, opt interface{}, options ...interface{}) *SearchServiceInterface_IssuesByGroup_Call {
	return &SearchServiceInterface_IssuesByGroup_Call{Call: _e.mock.On("IssuesByGroup",
		append([]interface{}{gid, query, opt}, options...)...)}
}

func (_c *SearchServiceInterface_IssuesByGroup_Call) Run(run func(gid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc)) *SearchServiceInterface_IssuesByGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(*gitlab.SearchOptions), variadicArgs...)
	})
	return _c
}

func (_c *SearchServiceInterface_IssuesByGroup_Call) Return(_a0 []*gitlab.Issue, _a1 *gitlab.Response, _a2 error) *SearchServiceInterface_IssuesByGroup_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *SearchServiceInterface_IssuesByGroup_Call) RunAndReturn(run func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error)) *SearchServiceInterface_IssuesByGroup_Call {
	_c.Call.Return(run)
	return _c
}

// IssuesByProject provides a mock function with given fields: pid, query, opt, options
func (_m *SearchServiceInterface) IssuesByProject(pid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, query, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for IssuesByProject")
	}

	var r0 []*gitlab.Issue
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error)); ok {
		return rf(pid, query, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) []*gitlab.Issue); ok {
		r0 = rf(pid, query, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Issue)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, query, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, query, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SearchServiceInterface_IssuesByProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IssuesByProject'
type SearchServiceInterface_IssuesByProject_Call struct {
	*mock.Call
}

// IssuesByProject is a helper method to define mock.On call
//   - pid interface{}
//   - query string
//   - opt *gitlab.SearchOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *SearchServiceInterface_Expecter) IssuesByProject(pid interface{}, query interface{}, opt interface{}, options ...interface{}) *SearchServiceInterface_IssuesByProject_Call {
	return &SearchServiceInterface_IssuesByProject_Call{Call: _e.mock.On("IssuesByProject",
		append([]interface{}{pid, query, opt}, options...)...)}
}

func (_c *SearchServiceInterface_IssuesByProject_Call) Run(run func(pid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc)) *SearchServiceInterface_IssuesByProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(*gitlab.SearchOptions), variadicArgs...)
	})
	return _c
}

func (_c *SearchServiceInterface_IssuesByProject_Call) Return(_a0 []*gitlab.Issue, _a1 *gitlab.Response, _a2 error) *SearchServiceInterface_IssuesByProject_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *SearchServiceInterface_IssuesByProject_Call) RunAndReturn(run func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error)) *SearchServiceInterface_IssuesByProject_Call {
	_c.Call.Return(run)
	return _c
}

// MergeRequests provides a mock function with given fields: query, opt, options
func (_m *SearchServiceInterface) MergeRequests(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequest, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, query, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MergeRequests")
	}

	var r0 []*gitlab.MergeRequest
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequest, *gitlab.Response, error)); ok {
		return rf(query, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) []*gitlab.MergeRequest); ok {
		r0 = rf(query, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.MergeRequest)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(query, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(query, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SearchServiceInterface_MergeRequests_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MergeRequests'
type SearchServiceInterface_MergeRequests_Call struct {
	*mock.Call
}

// MergeRequests is a helper method to define mock.On call
//   - query string
//   - opt *gitlab.SearchOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *SearchServiceInterface_Expecter) MergeRequests(query interface{}, opt interface{}, options ...interface{}) *SearchServiceInterface_MergeRequests_Call {
	return &SearchServiceInterface_MergeRequests_Call{Call: _e.mock.On("MergeRequests",
		append([]interface{}{query, opt}, options...)...)}
}

func (_c *SearchServiceInterface_MergeRequests_Call) Run(run func(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc)) *SearchServiceInterface_MergeRequests_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(string), args[1].(*gitlab.SearchOptions), variadicArgs...)
	})
	return _c
}

func (_c *SearchServiceInterface_MergeRequests_Call) Return(_a0 []*gitlab.MergeRequest, _a1 *gitlab.Response, _a2 error) *SearchServiceInterface_MergeRequests_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *SearchServiceInterface_MergeRequests_Call) RunAndReturn(run func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequest, *gitlab.Response, error)) *SearchServiceInterface_MergeRequests_Call {
	_c.Call.Return(run)
	return _c
}

// MergeRequestsByGroup provides a mock function with given fields: gid, query, opt, options
func (_m *SearchServiceInterface) MergeRequestsByGroup(gid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequest, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, query, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MergeRequestsByGroup")
	}

	var r0 []*gitlab.MergeRequest
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequest, *gitlab.Response, error)); ok {
		return rf(gid, query, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) []*gitlab.MergeRequest); ok {
		r0 = rf(gid, query, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.MergeRequest)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, query, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, query, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SearchServiceInterface_MergeRequestsByGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MergeRequestsByGroup'
type SearchServiceInterface_MergeRequestsByGroup_Call struct {
	*mock.Call
}

// MergeRequestsByGroup is a helper method to define mock.On call
//   - gid interface{}
//   - query string
//   - opt *gitlab.SearchOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *SearchServiceInterface_Expecter) MergeRequestsByGroup(gid interface{}, query interface{}, opt interface{}, options ...interface{}) *SearchServiceInterface_MergeRequestsByGroup_Call {
	return &SearchServiceInterface_MergeRequestsByGroup_Call{Call: _e.mock.On("MergeRequestsByGroup",
		append([]interface{}{gid, query, opt}, options...)...)}
}

func (_c *SearchServiceInterface_MergeRequestsByGroup_Call) Run(run func(gid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc)) *SearchServiceInterface_MergeRequestsByGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(*gitlab.SearchOptions), variadicArgs...)
	})
	return _c
}

func (_c *SearchServiceInterface_MergeRequestsByGroup_Call) Return(_a0 []*gitlab.MergeRequest, _a1 *gitlab.Response, _a2 error) *SearchServiceInterface_MergeRequestsByGroup_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *SearchServiceInterface_MergeRequestsByGroup_Call) RunAndReturn(run func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequest, *gitlab.Response, error)) *SearchServiceInterface_MergeRequestsByGroup_Call {
	_c.Call.Return(run)
	return _c
}

// MergeRequestsByProject provides a mock function with given fields: pid, query, opt, options
func (_m *SearchServiceInterface) MergeRequestsByProject(pid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequest, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, query, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MergeRequestsByProject")
	}

	var r0 []*gitlab.MergeRequest
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequest, *gitlab.Response, error)); ok {
		return rf(pid, query, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) []*gitlab.MergeRequest); ok {
		r0 = rf(pid, query, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.MergeRequest)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, query, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, query, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SearchServiceInterface_MergeRequestsByProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MergeRequestsByProject'
type SearchServiceInterface_MergeRequestsByProject_Call struct {
	*mock.Call
}

// MergeRequestsByProject is a helper method to define mock.On call
//   - pid interface{}
//   - query string
//   - opt *gitlab.SearchOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *SearchServiceInterface_Expecter) MergeRequestsByProject(pid interface{}, query interface{}, opt interface{}, options ...interface{}) *SearchServiceInterface_MergeRequestsByProject_Call {
	return &SearchServiceInterface_MergeRequestsByProject_Call{Call: _e.mock.On("MergeRequestsByProject",
		append([]interface{}{pid, query, opt}, options...)...)}
}

func (_c *SearchServiceInterface_MergeRequestsByProject_Call) Run(run func(pid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc)) *SearchServiceInterface_MergeRequestsByProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(*gitlab.SearchOptions), variadicArgs...)
	})
	return _c
}

func (_c *SearchServiceInterface_MergeRequestsByProject_Call) Return(_a0 []*gitlab.MergeRequest, _a1 *gitlab.Response, _a2 error) *SearchServiceInterface_MergeRequestsByProject_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *SearchServiceInterface_MergeRequestsByProject_Call) RunAndReturn(run func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequest, *gitlab.Response, error)) *SearchServiceInterface_MergeRequestsByProject_Call {
	_c.Call.Return(run)
	return _c
}

// Milestones provides a mock function with given fields: query, opt, options
func (_m *SearchServiceInterface) Milestones(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Milestone, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, query, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Milestones")
	}

	var r0 []*gitlab.Milestone
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Milestone, *gitlab.Response, error)); ok {
		return rf(query, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) []*gitlab.Milestone); ok {
		r0 = rf(query, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Milestone)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(query, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(query, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SearchServiceInterface_Milestones_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Milestones'
type SearchServiceInterface_Milestones_Call struct {
	*mock.Call
}

// Milestones is a helper method to define mock.On call
//   - query string
//   - opt *gitlab.SearchOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *SearchServiceInterface_Expecter) Milestones(query interface{}, opt interface{}, options ...interface{}) *SearchServiceInterface_Milestones_Call {
	return &SearchServiceInterface_Milestones_Call{Call: _e.mock.On("Milestones",
		append([]interface{}{query, opt}, options...)...)}
}

func (_c *SearchServiceInterface_Milestones_Call) Run(run func(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc)) *SearchServiceInterface_Milestones_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(string), args[1].(*gitlab.SearchOptions), variadicArgs...)
	})
	return _c
}

func (_c *SearchServiceInterface_Milestones_Call) Return(_a0 []*gitlab.Milestone, _a1 *gitlab.Response, _a2 error) *SearchServiceInterface_Milestones_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *SearchServiceInterface_Milestones_Call) RunAndReturn(run func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Milestone, *gitlab.Response, error)) *SearchServiceInterface_Milestones_Call {
	_c.Call.Return(run)
	return _c
}

// MilestonesByGroup provides a mock function with given fields: gid, query, opt, options
func (_m *SearchServiceInterface) MilestonesByGroup(gid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Milestone, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, query, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MilestonesByGroup")
	}

	var r0 []*gitlab.Milestone
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Milestone, *gitlab.Response, error)); ok {
		return rf(gid, query, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) []*gitlab.Milestone); ok {
		r0 = rf(gid, query, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Milestone)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, query, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, query, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SearchServiceInterface_MilestonesByGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MilestonesByGroup'
type SearchServiceInterface_MilestonesByGroup_Call struct {
	*mock.Call
}

// MilestonesByGroup is a helper method to define mock.On call
//   - gid interface{}
//   - query string
//   - opt *gitlab.SearchOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *SearchServiceInterface_Expecter) MilestonesByGroup(gid interface{}, query interface{}, opt interface{}, options ...interface{}) *SearchServiceInterface_MilestonesByGroup_Call {
	return &SearchServiceInterface_MilestonesByGroup_Call{Call: _e.mock.On("MilestonesByGroup",
		append([]interface{}{gid, query, opt}, options...)...)}
}

func (_c *SearchServiceInterface_MilestonesByGroup_Call) Run(run func(gid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc)) *SearchServiceInterface_MilestonesByGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(*gitlab.SearchOptions), variadicArgs...)
	})
	return _c
}

func (_c *SearchServiceInterface_MilestonesByGroup_Call) Return(_a0 []*gitlab.Milestone, _a1 *gitlab.Response, _a2 error) *SearchServiceInterface_MilestonesByGroup_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *SearchServiceInterface_MilestonesByGroup_Call) RunAndReturn(run func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Milestone, *gitlab.Response, error)) *SearchServiceInterface_MilestonesByGroup_Call {
	_c.Call.Return(run)
	return _c
}

// MilestonesByProject provides a mock function with given fields: pid, query, opt, options
func (_m *SearchServiceInterface) MilestonesByProject(pid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Milestone, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, query, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for MilestonesByProject")
	}

	var r0 []*gitlab.Milestone
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Milestone, *gitlab.Response, error)); ok {
		return rf(pid, query, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) []*gitlab.Milestone); ok {
		r0 = rf(pid, query, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Milestone)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, query, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, query, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SearchServiceInterface_MilestonesByProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MilestonesByProject'
type SearchServiceInterface_MilestonesByProject_Call struct {
	*mock.Call
}

// MilestonesByProject is a helper method to define mock.On call
//   - pid interface{}
//   - query string
//   - opt *gitlab.SearchOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *SearchServiceInterface_Expecter) MilestonesByProject(pid interface{}, query interface{}, opt interface{}, options ...interface{}) *SearchServiceInterface_MilestonesByProject_Call {
	return &SearchServiceInterface_MilestonesByProject_Call{Call: _e.mock.On("MilestonesByProject",
		append([]interface{}{pid, query, opt}, options...)...)}
}

func (_c *SearchServiceInterface_MilestonesByProject_Call) Run(run func(pid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc)) *SearchServiceInterface_MilestonesByProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(*gitlab.SearchOptions), variadicArgs...)
	})
	return _c
}

func (_c *SearchServiceInterface_MilestonesByProject_Call) Return(_a0 []*gitlab.Milestone, _a1 *gitlab.Response, _a2 error) *SearchServiceInterface_MilestonesByProject_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *SearchServiceInterface_MilestonesByProject_Call) RunAndReturn(run func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Milestone, *gitlab.Response, error)) *SearchServiceInterface_MilestonesByProject_Call {
	_c.Call.Return(run)
	return _c
}

// NotesByProject provides a mock function with given fields: pid, query, opt, options
func (_m *SearchServiceInterface) NotesByProject(pid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, query, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for NotesByProject")
	}

	var r0 []*gitlab.Note
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error)); ok {
		return rf(pid, query, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) []*gitlab.Note); ok {
		r0 = rf(pid, query, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Note)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, query, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, query, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SearchServiceInterface_NotesByProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NotesByProject'
type SearchServiceInterface_NotesByProject_Call struct {
	*mock.Call
}

// NotesByProject is a helper method to define mock.On call
//   - pid interface{}
//   - query string
//   - opt *gitlab.SearchOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *SearchServiceInterface_Expecter) NotesByProject(pid interface{}, query interface{}, opt interface{}, options ...interface{}) *SearchServiceInterface_NotesByProject_Call {
	return &SearchServiceInterface_NotesByProject_Call{Call: _e.mock.On("NotesByProject",
		append([]interface{}{pid, query, opt}, options...)...)}
}

func (_c *SearchServiceInterface_NotesByProject_Call) Run(run func(pid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc)) *SearchServiceInterface_NotesByProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(*gitlab.SearchOptions), variadicArgs...)
	})
	return _c
}

func (_c *SearchServiceInterface_NotesByProject_Call) Return(_a0 []*gitlab.Note, _a1 *gitlab.Response, _a2 error) *SearchServiceInterface_NotesByProject_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *SearchServiceInterface_NotesByProject_Call) RunAndReturn(run func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error)) *SearchServiceInterface_NotesByProject_Call {
	_c.Call.Return(run)
	return _c
}

// Projects provides a mock function with given fields: query, opt, options
func (_m *SearchServiceInterface) Projects(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, query, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Projects")
	}

	var r0 []*gitlab.Project
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)); ok {
		return rf(query, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) []*gitlab.Project); ok {
		r0 = rf(query, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(query, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(query, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SearchServiceInterface_Projects_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Projects'
type SearchServiceInterface_Projects_Call struct {
	*mock.Call
}

// Projects is a helper method to define mock.On call
//   - query string
//   - opt *gitlab.SearchOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *SearchServiceInterface_Expecter) Projects(query interface{}, opt interface{}, options ...interface{}) *SearchServiceInterface_Projects_Call {
	return &SearchServiceInterface_Projects_Call{Call: _e.mock.On("Projects",
		append([]interface{}{query, opt}, options...)...)}
}

func (_c *SearchServiceInterface_Projects_Call) Run(run func(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc)) *SearchServiceInterface_Projects_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(string), args[1].(*gitlab.SearchOptions), variadicArgs...)
	})
	return _c
}

func (_c *SearchServiceInterface_Projects_Call) Return(_a0 []*gitlab.Project, _a1 *gitlab.Response, _a2 error) *SearchServiceInterface_Projects_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *SearchServiceInterface_Projects_Call) RunAndReturn(run func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)) *SearchServiceInterface_Projects_Call {
	_c.Call.Return(run)
	return _c
}

// ProjectsByGroup provides a mock function with given fields: gid, query, opt, options
func (_m *SearchServiceInterface) ProjectsByGroup(gid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, query, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ProjectsByGroup")
	}

	var r0 []*gitlab.Project
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)); ok {
		return rf(gid, query, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) []*gitlab.Project); ok {
		r0 = rf(gid, query, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Project)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, query, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, query, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SearchServiceInterface_ProjectsByGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ProjectsByGroup'
type SearchServiceInterface_ProjectsByGroup_Call struct {
	*mock.Call
}

// ProjectsByGroup is a helper method to define mock.On call
//   - gid interface{}
//   - query string
//   - opt *gitlab.SearchOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *SearchServiceInterface_Expecter) ProjectsByGroup(gid interface{}, query interface{}, opt interface{}, options ...interface{}) *SearchServiceInterface_ProjectsByGroup_Call {
	return &SearchServiceInterface_ProjectsByGroup_Call{Call: _e.mock.On("ProjectsByGroup",
		append([]interface{}{gid, query, opt}, options...)...)}
}

func (_c *SearchServiceInterface_ProjectsByGroup_Call) Run(run func(gid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc)) *SearchServiceInterface_ProjectsByGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(*gitlab.SearchOptions), variadicArgs...)
	})
	return _c
}

func (_c *SearchServiceInterface_ProjectsByGroup_Call) Return(_a0 []*gitlab.Project, _a1 *gitlab.Response, _a2 error) *SearchServiceInterface_ProjectsByGroup_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *SearchServiceInterface_ProjectsByGroup_Call) RunAndReturn(run func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Project, *gitlab.Response, error)) *SearchServiceInterface_ProjectsByGroup_Call {
	_c.Call.Return(run)
	return _c
}

// SnippetBlobs provides a mock function with given fields: query, opt, options
func (_m *SearchServiceInterface) SnippetBlobs(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Snippet, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, query, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnippetBlobs")
	}

	var r0 []*gitlab.Snippet
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Snippet, *gitlab.Response, error)); ok {
		return rf(query, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) []*gitlab.Snippet); ok {
		r0 = rf(query, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Snippet)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(query, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(query, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SearchServiceInterface_SnippetBlobs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SnippetBlobs'
type SearchServiceInterface_SnippetBlobs_Call struct {
	*mock.Call
}

// SnippetBlobs is a helper method to define mock.On call
//   - query string
//   - opt *gitlab.SearchOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *SearchServiceInterface_Expecter) SnippetBlobs(query interface{}, opt interface{}, options ...interface{}) *SearchServiceInterface_SnippetBlobs_Call {
	return &SearchServiceInterface_SnippetBlobs_Call{Call: _e.mock.On("SnippetBlobs",
		append([]interface{}{query, opt}, options...)...)}
}

func (_c *SearchServiceInterface_SnippetBlobs_Call) Run(run func(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc)) *SearchServiceInterface_SnippetBlobs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(string), args[1].(*gitlab.SearchOptions), variadicArgs...)
	})
	return _c
}

func (_c *SearchServiceInterface_SnippetBlobs_Call) Return(_a0 []*gitlab.Snippet, _a1 *gitlab.Response, _a2 error) *SearchServiceInterface_SnippetBlobs_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *SearchServiceInterface_SnippetBlobs_Call) RunAndReturn(run func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Snippet, *gitlab.Response, error)) *SearchServiceInterface_SnippetBlobs_Call {
	_c.Call.Return(run)
	return _c
}

// SnippetTitles provides a mock function with given fields: query, opt, options
func (_m *SearchServiceInterface) SnippetTitles(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Snippet, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, query, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SnippetTitles")
	}

	var r0 []*gitlab.Snippet
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Snippet, *gitlab.Response, error)); ok {
		return rf(query, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) []*gitlab.Snippet); ok {
		r0 = rf(query, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Snippet)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(query, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(query, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SearchServiceInterface_SnippetTitles_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SnippetTitles'
type SearchServiceInterface_SnippetTitles_Call struct {
	*mock.Call
}

// SnippetTitles is a helper method to define mock.On call
//   - query string
//   - opt *gitlab.SearchOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *SearchServiceInterface_Expecter) SnippetTitles(query interface{}, opt interface{}, options ...interface{}) *SearchServiceInterface_SnippetTitles_Call {
	return &SearchServiceInterface_SnippetTitles_Call{Call: _e.mock.On("SnippetTitles",
		append([]interface{}{query, opt}, options...)...)}
}

func (_c *SearchServiceInterface_SnippetTitles_Call) Run(run func(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc)) *SearchServiceInterface_SnippetTitles_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(string), args[1].(*gitlab.SearchOptions), variadicArgs...)
	})
	return _c
}

func (_c *SearchServiceInterface_SnippetTitles_Call) Return(_a0 []*gitlab.Snippet, _a1 *gitlab.Response, _a2 error) *SearchServiceInterface_SnippetTitles_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *SearchServiceInterface_SnippetTitles_Call) RunAndReturn(run func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Snippet, *gitlab.Response, error)) *SearchServiceInterface_SnippetTitles_Call {
	_c.Call.Return(run)
	return _c
}

// Users provides a mock function with given fields: query, opt, options
func (_m *SearchServiceInterface) Users(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.User, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, query, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Users")
	}

	var r0 []*gitlab.User
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.User, *gitlab.Response, error)); ok {
		return rf(query, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) []*gitlab.User); ok {
		r0 = rf(query, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.User)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(query, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(query, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SearchServiceInterface_Users_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Users'
type SearchServiceInterface_Users_Call struct {
	*mock.Call
}

// Users is a helper method to define mock.On call
//   - query string
//   - opt *gitlab.SearchOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *SearchServiceInterface_Expecter) Users(query interface{}, opt interface{}, options ...interface{}) *SearchServiceInterface_Users_Call {
	return &SearchServiceInterface_Users_Call{Call: _e.mock.On("Users",
		append([]interface{}{query, opt}, options...)...)}
}

func (_c *SearchServiceInterface_Users_Call) Run(run func(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc)) *SearchServiceInterface_Users_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(string), args[1].(*gitlab.SearchOptions), variadicArgs...)
	})
	return _c
}

func (_c *SearchServiceInterface_Users_Call) Return(_a0 []*gitlab.User, _a1 *gitlab.Response, _a2 error) *SearchServiceInterface_Users_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *SearchServiceInterface_Users_Call) RunAndReturn(run func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.User, *gitlab.Response, error)) *SearchServiceInterface_Users_Call {
	_c.Call.Return(run)
	return _c
}

// UsersByGroup provides a mock function with given fields: gid, query, opt, options
func (_m *SearchServiceInterface) UsersByGroup(gid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.User, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, query, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UsersByGroup")
	}

	var r0 []*gitlab.User
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.User, *gitlab.Response, error)); ok {
		return rf(gid, query, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) []*gitlab.User); ok {
		r0 = rf(gid, query, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.User)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, query, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, query, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SearchServiceInterface_UsersByGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UsersByGroup'
type SearchServiceInterface_UsersByGroup_Call struct {
	*mock.Call
}

// UsersByGroup is a helper method to define mock.On call
//   - gid interface{}
//   - query string
//   - opt *gitlab.SearchOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *SearchServiceInterface_Expecter) UsersByGroup(gid interface{}, query interface{}, opt interface{}, options ...interface{}) *SearchServiceInterface_UsersByGroup_Call {
	return &SearchServiceInterface_UsersByGroup_Call{Call: _e.mock.On("UsersByGroup",
		append([]interface{}{gid, query, opt}, options...)...)}
}

func (_c *SearchServiceInterface_UsersByGroup_Call) Run(run func(gid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc)) *SearchServiceInterface_UsersByGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(*gitlab.SearchOptions), variadicArgs...)
	})
	return _c
}

func (_c *SearchServiceInterface_UsersByGroup_Call) Return(_a0 []*gitlab.User, _a1 *gitlab.Response, _a2 error) *SearchServiceInterface_UsersByGroup_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *SearchServiceInterface_UsersByGroup_Call) RunAndReturn(run func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.User, *gitlab.Response, error)) *SearchServiceInterface_UsersByGroup_Call {
	_c.Call.Return(run)
	return _c
}

// UsersByProject provides a mock function with given fields: pid, query, opt, options
func (_m *SearchServiceInterface) UsersByProject(pid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.User, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, query, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UsersByProject")
	}

	var r0 []*gitlab.User
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.User, *gitlab.Response, error)); ok {
		return rf(pid, query, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) []*gitlab.User); ok {
		r0 = rf(pid, query, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.User)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, query, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, query, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SearchServiceInterface_UsersByProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UsersByProject'
type SearchServiceInterface_UsersByProject_Call struct {
	*mock.Call
}

// UsersByProject is a helper method to define mock.On call
//   - pid interface{}
//   - query string
//   - opt *gitlab.SearchOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *SearchServiceInterface_Expecter) UsersByProject(pid interface{}, query interface{}, opt interface{}, options ...interface{}) *SearchServiceInterface_UsersByProject_Call {
	return &SearchServiceInterface_UsersByProject_Call{Call: _e.mock.On("UsersByProject",
		append([]interface{}{pid, query, opt}, options...)...)}
}

func (_c *SearchServiceInterface_UsersByProject_Call) Run(run func(pid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc)) *SearchServiceInterface_UsersByProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(*gitlab.SearchOptions), variadicArgs...)
	})
	return _c
}

func (_c *SearchServiceInterface_UsersByProject_Call) Return(_a0 []*gitlab.User, _a1 *gitlab.Response, _a2 error) *SearchServiceInterface_UsersByProject_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *SearchServiceInterface_UsersByProject_Call) RunAndReturn(run func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.User, *gitlab.Response, error)) *SearchServiceInterface_UsersByProject_Call {
	_c.Call.Return(run)
	return _c
}

// WikiBlobs provides a mock function with given fields: query, opt, options
func (_m *SearchServiceInterface) WikiBlobs(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Wiki, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, query, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WikiBlobs")
	}

	var r0 []*gitlab.Wiki
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Wiki, *gitlab.Response, error)); ok {
		return rf(query, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) []*gitlab.Wiki); ok {
		r0 = rf(query, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Wiki)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(query, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(query, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SearchServiceInterface_WikiBlobs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WikiBlobs'
type SearchServiceInterface_WikiBlobs_Call struct {
	*mock.Call
}

// WikiBlobs is a helper method to define mock.On call
//   - query string
//   - opt *gitlab.SearchOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *SearchServiceInterface_Expecter) WikiBlobs(query interface{}, opt interface{}, options ...interface{}) *SearchServiceInterface_WikiBlobs_Call {
	return &SearchServiceInterface_WikiBlobs_Call{Call: _e.mock.On("WikiBlobs",
		append([]interface{}{query, opt}, options...)...)}
}

func (_c *SearchServiceInterface_WikiBlobs_Call) Run(run func(query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc)) *SearchServiceInterface_WikiBlobs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(string), args[1].(*gitlab.SearchOptions), variadicArgs...)
	})
	return _c
}

func (_c *SearchServiceInterface_WikiBlobs_Call) Return(_a0 []*gitlab.Wiki, _a1 *gitlab.Response, _a2 error) *SearchServiceInterface_WikiBlobs_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *SearchServiceInterface_WikiBlobs_Call) RunAndReturn(run func(string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Wiki, *gitlab.Response, error)) *SearchServiceInterface_WikiBlobs_Call {
	_c.Call.Return(run)
	return _c
}

// WikiBlobsByGroup provides a mock function with given fields: gid, query, opt, options
func (_m *SearchServiceInterface) WikiBlobsByGroup(gid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Wiki, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, query, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WikiBlobsByGroup")
	}

	var r0 []*gitlab.Wiki
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Wiki, *gitlab.Response, error)); ok {
		return rf(gid, query, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) []*gitlab.Wiki); ok {
		r0 = rf(gid, query, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Wiki)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, query, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, query, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SearchServiceInterface_WikiBlobsByGroup_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WikiBlobsByGroup'
type SearchServiceInterface_WikiBlobsByGroup_Call struct {
	*mock.Call
}

// WikiBlobsByGroup is a helper method to define mock.On call
//   - gid interface{}
//   - query string
//   - opt *gitlab.SearchOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *SearchServiceInterface_Expecter) WikiBlobsByGroup(gid interface{}, query interface{}, opt interface{}, options ...interface{}) *SearchServiceInterface_WikiBlobsByGroup_Call {
	return &SearchServiceInterface_WikiBlobsByGroup_Call{Call: _e.mock.On("WikiBlobsByGroup",
		append([]interface{}{gid, query, opt}, options...)...)}
}

func (_c *SearchServiceInterface_WikiBlobsByGroup_Call) Run(run func(gid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc)) *SearchServiceInterface_WikiBlobsByGroup_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(*gitlab.SearchOptions), variadicArgs...)
	})
	return _c
}

func (_c *SearchServiceInterface_WikiBlobsByGroup_Call) Return(_a0 []*gitlab.Wiki, _a1 *gitlab.Response, _a2 error) *SearchServiceInterface_WikiBlobsByGroup_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *SearchServiceInterface_WikiBlobsByGroup_Call) RunAndReturn(run func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Wiki, *gitlab.Response, error)) *SearchServiceInterface_WikiBlobsByGroup_Call {
	_c.Call.Return(run)
	return _c
}

// WikiBlobsByProject provides a mock function with given fields: pid, query, opt, options
func (_m *SearchServiceInterface) WikiBlobsByProject(pid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Wiki, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, query, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WikiBlobsByProject")
	}

	var r0 []*gitlab.Wiki
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Wiki, *gitlab.Response, error)); ok {
		return rf(pid, query, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) []*gitlab.Wiki); ok {
		r0 = rf(pid, query, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Wiki)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, query, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, query, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// SearchServiceInterface_WikiBlobsByProject_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WikiBlobsByProject'
type SearchServiceInterface_WikiBlobsByProject_Call struct {
	*mock.Call
}

// WikiBlobsByProject is a helper method to define mock.On call
//   - pid interface{}
//   - query string
//   - opt *gitlab.SearchOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *SearchServiceInterface_Expecter) WikiBlobsByProject(pid interface{}, query interface{}, opt interface{}, options ...interface{}) *SearchServiceInterface_WikiBlobsByProject_Call {
	return &SearchServiceInterface_WikiBlobsByProject_Call{Call: _e.mock.On("WikiBlobsByProject",
		append([]interface{}{pid, query, opt}, options...)...)}
}

func (_c *SearchServiceInterface_WikiBlobsByProject_Call) Run(run func(pid interface{}, query string, opt *gitlab.SearchOptions, options ...gitlab.RequestOptionFunc)) *SearchServiceInterface_WikiBlobsByProject_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(string), args[2].(*gitlab.SearchOptions), variadicArgs...)
	})
	return _c
}

func (_c *SearchServiceInterface_WikiBlobsByProject_Call) Return(_a0 []*gitlab.Wiki, _a1 *gitlab.Response, _a2 error) *SearchServiceInterface_WikiBlobsByProject_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *SearchServiceInterface_WikiBlobsByProject_Call) RunAndReturn(run func(interface{}, string, *gitlab.SearchOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Wiki, *gitlab.Response, error)) *SearchServiceInterface_WikiBlobsByProject_Call {
	_c.Call.Return(run)
	return _c
}

// NewSearchServiceInterface creates a new instance of SearchServiceInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewSearchServiceInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *SearchServiceInterface {
	mock := &SearchServiceInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

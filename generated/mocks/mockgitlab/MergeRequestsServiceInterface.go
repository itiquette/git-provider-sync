// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"
	gitlab "gitlab.com/gitlab-org/api/client-go"
)

// MergeRequestsServiceInterface is an autogenerated mock type for the MergeRequestsServiceInterface type
type MergeRequestsServiceInterface struct {
	mock.Mock
}

type MergeRequestsServiceInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *MergeRequestsServiceInterface) EXPECT() *MergeRequestsServiceInterface_Expecter {
	return &MergeRequestsServiceInterface_Expecter{mock: &_m.Mock}
}

// AcceptMergeRequest provides a mock function with given fields: pid, mergeRequest, opt, options
func (_m *MergeRequestsServiceInterface) AcceptMergeRequest(pid interface{}, mergeRequest int, opt *gitlab.AcceptMergeRequestOptions, options ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AcceptMergeRequest")
	}

	var r0 *gitlab.MergeRequest
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.AcceptMergeRequestOptions, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.AcceptMergeRequestOptions, ...gitlab.RequestOptionFunc) *gitlab.MergeRequest); ok {
		r0 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.MergeRequest)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.AcceptMergeRequestOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.AcceptMergeRequestOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_AcceptMergeRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AcceptMergeRequest'
type MergeRequestsServiceInterface_AcceptMergeRequest_Call struct {
	*mock.Call
}

// AcceptMergeRequest is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - opt *gitlab.AcceptMergeRequestOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) AcceptMergeRequest(pid interface{}, mergeRequest interface{}, opt interface{}, options ...interface{}) *MergeRequestsServiceInterface_AcceptMergeRequest_Call {
	return &MergeRequestsServiceInterface_AcceptMergeRequest_Call{Call: _e.mock.On("AcceptMergeRequest",
		append([]interface{}{pid, mergeRequest, opt}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_AcceptMergeRequest_Call) Run(run func(pid interface{}, mergeRequest int, opt *gitlab.AcceptMergeRequestOptions, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_AcceptMergeRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.AcceptMergeRequestOptions), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_AcceptMergeRequest_Call) Return(_a0 *gitlab.MergeRequest, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_AcceptMergeRequest_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_AcceptMergeRequest_Call) RunAndReturn(run func(interface{}, int, *gitlab.AcceptMergeRequestOptions, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error)) *MergeRequestsServiceInterface_AcceptMergeRequest_Call {
	_c.Call.Return(run)
	return _c
}

// AddSpentTime provides a mock function with given fields: pid, mergeRequest, opt, options
func (_m *MergeRequestsServiceInterface) AddSpentTime(pid interface{}, mergeRequest int, opt *gitlab.AddSpentTimeOptions, options ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddSpentTime")
	}

	var r0 *gitlab.TimeStats
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.AddSpentTimeOptions, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.AddSpentTimeOptions, ...gitlab.RequestOptionFunc) *gitlab.TimeStats); ok {
		r0 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.TimeStats)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.AddSpentTimeOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.AddSpentTimeOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_AddSpentTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddSpentTime'
type MergeRequestsServiceInterface_AddSpentTime_Call struct {
	*mock.Call
}

// AddSpentTime is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - opt *gitlab.AddSpentTimeOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) AddSpentTime(pid interface{}, mergeRequest interface{}, opt interface{}, options ...interface{}) *MergeRequestsServiceInterface_AddSpentTime_Call {
	return &MergeRequestsServiceInterface_AddSpentTime_Call{Call: _e.mock.On("AddSpentTime",
		append([]interface{}{pid, mergeRequest, opt}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_AddSpentTime_Call) Run(run func(pid interface{}, mergeRequest int, opt *gitlab.AddSpentTimeOptions, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_AddSpentTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.AddSpentTimeOptions), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_AddSpentTime_Call) Return(_a0 *gitlab.TimeStats, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_AddSpentTime_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_AddSpentTime_Call) RunAndReturn(run func(interface{}, int, *gitlab.AddSpentTimeOptions, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)) *MergeRequestsServiceInterface_AddSpentTime_Call {
	_c.Call.Return(run)
	return _c
}

// CancelMergeWhenPipelineSucceeds provides a mock function with given fields: pid, mergeRequest, options
func (_m *MergeRequestsServiceInterface) CancelMergeWhenPipelineSucceeds(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CancelMergeWhenPipelineSucceeds")
	}

	var r0 *gitlab.MergeRequest
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.MergeRequest); ok {
		r0 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.MergeRequest)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_CancelMergeWhenPipelineSucceeds_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CancelMergeWhenPipelineSucceeds'
type MergeRequestsServiceInterface_CancelMergeWhenPipelineSucceeds_Call struct {
	*mock.Call
}

// CancelMergeWhenPipelineSucceeds is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) CancelMergeWhenPipelineSucceeds(pid interface{}, mergeRequest interface{}, options ...interface{}) *MergeRequestsServiceInterface_CancelMergeWhenPipelineSucceeds_Call {
	return &MergeRequestsServiceInterface_CancelMergeWhenPipelineSucceeds_Call{Call: _e.mock.On("CancelMergeWhenPipelineSucceeds",
		append([]interface{}{pid, mergeRequest}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_CancelMergeWhenPipelineSucceeds_Call) Run(run func(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_CancelMergeWhenPipelineSucceeds_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_CancelMergeWhenPipelineSucceeds_Call) Return(_a0 *gitlab.MergeRequest, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_CancelMergeWhenPipelineSucceeds_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_CancelMergeWhenPipelineSucceeds_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error)) *MergeRequestsServiceInterface_CancelMergeWhenPipelineSucceeds_Call {
	_c.Call.Return(run)
	return _c
}

// CreateMergeRequest provides a mock function with given fields: pid, opt, options
func (_m *MergeRequestsServiceInterface) CreateMergeRequest(pid interface{}, opt *gitlab.CreateMergeRequestOptions, options ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateMergeRequest")
	}

	var r0 *gitlab.MergeRequest
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.CreateMergeRequestOptions, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.CreateMergeRequestOptions, ...gitlab.RequestOptionFunc) *gitlab.MergeRequest); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.MergeRequest)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.CreateMergeRequestOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.CreateMergeRequestOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_CreateMergeRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMergeRequest'
type MergeRequestsServiceInterface_CreateMergeRequest_Call struct {
	*mock.Call
}

// CreateMergeRequest is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.CreateMergeRequestOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) CreateMergeRequest(pid interface{}, opt interface{}, options ...interface{}) *MergeRequestsServiceInterface_CreateMergeRequest_Call {
	return &MergeRequestsServiceInterface_CreateMergeRequest_Call{Call: _e.mock.On("CreateMergeRequest",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_CreateMergeRequest_Call) Run(run func(pid interface{}, opt *gitlab.CreateMergeRequestOptions, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_CreateMergeRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.CreateMergeRequestOptions), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_CreateMergeRequest_Call) Return(_a0 *gitlab.MergeRequest, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_CreateMergeRequest_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_CreateMergeRequest_Call) RunAndReturn(run func(interface{}, *gitlab.CreateMergeRequestOptions, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error)) *MergeRequestsServiceInterface_CreateMergeRequest_Call {
	_c.Call.Return(run)
	return _c
}

// CreateMergeRequestDependency provides a mock function with given fields: pid, mergeRequest, opts, options
func (_m *MergeRequestsServiceInterface) CreateMergeRequestDependency(pid interface{}, mergeRequest int, opts gitlab.CreateMergeRequestDependencyOptions, options ...gitlab.RequestOptionFunc) (*gitlab.MergeRequestDependency, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, opts)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateMergeRequestDependency")
	}

	var r0 *gitlab.MergeRequestDependency
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, gitlab.CreateMergeRequestDependencyOptions, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequestDependency, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, opts, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, gitlab.CreateMergeRequestDependencyOptions, ...gitlab.RequestOptionFunc) *gitlab.MergeRequestDependency); ok {
		r0 = rf(pid, mergeRequest, opts, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.MergeRequestDependency)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, gitlab.CreateMergeRequestDependencyOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, opts, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, gitlab.CreateMergeRequestDependencyOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, opts, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_CreateMergeRequestDependency_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMergeRequestDependency'
type MergeRequestsServiceInterface_CreateMergeRequestDependency_Call struct {
	*mock.Call
}

// CreateMergeRequestDependency is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - opts gitlab.CreateMergeRequestDependencyOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) CreateMergeRequestDependency(pid interface{}, mergeRequest interface{}, opts interface{}, options ...interface{}) *MergeRequestsServiceInterface_CreateMergeRequestDependency_Call {
	return &MergeRequestsServiceInterface_CreateMergeRequestDependency_Call{Call: _e.mock.On("CreateMergeRequestDependency",
		append([]interface{}{pid, mergeRequest, opts}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_CreateMergeRequestDependency_Call) Run(run func(pid interface{}, mergeRequest int, opts gitlab.CreateMergeRequestDependencyOptions, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_CreateMergeRequestDependency_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(gitlab.CreateMergeRequestDependencyOptions), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_CreateMergeRequestDependency_Call) Return(_a0 *gitlab.MergeRequestDependency, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_CreateMergeRequestDependency_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_CreateMergeRequestDependency_Call) RunAndReturn(run func(interface{}, int, gitlab.CreateMergeRequestDependencyOptions, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequestDependency, *gitlab.Response, error)) *MergeRequestsServiceInterface_CreateMergeRequestDependency_Call {
	_c.Call.Return(run)
	return _c
}

// CreateMergeRequestPipeline provides a mock function with given fields: pid, mergeRequest, options
func (_m *MergeRequestsServiceInterface) CreateMergeRequestPipeline(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc) (*gitlab.PipelineInfo, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateMergeRequestPipeline")
	}

	var r0 *gitlab.PipelineInfo
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.PipelineInfo, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.PipelineInfo); ok {
		r0 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.PipelineInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_CreateMergeRequestPipeline_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMergeRequestPipeline'
type MergeRequestsServiceInterface_CreateMergeRequestPipeline_Call struct {
	*mock.Call
}

// CreateMergeRequestPipeline is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) CreateMergeRequestPipeline(pid interface{}, mergeRequest interface{}, options ...interface{}) *MergeRequestsServiceInterface_CreateMergeRequestPipeline_Call {
	return &MergeRequestsServiceInterface_CreateMergeRequestPipeline_Call{Call: _e.mock.On("CreateMergeRequestPipeline",
		append([]interface{}{pid, mergeRequest}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_CreateMergeRequestPipeline_Call) Run(run func(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_CreateMergeRequestPipeline_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_CreateMergeRequestPipeline_Call) Return(_a0 *gitlab.PipelineInfo, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_CreateMergeRequestPipeline_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_CreateMergeRequestPipeline_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.PipelineInfo, *gitlab.Response, error)) *MergeRequestsServiceInterface_CreateMergeRequestPipeline_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTodo provides a mock function with given fields: pid, mergeRequest, options
func (_m *MergeRequestsServiceInterface) CreateTodo(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc) (*gitlab.Todo, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateTodo")
	}

	var r0 *gitlab.Todo
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Todo, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Todo); ok {
		r0 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Todo)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_CreateTodo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTodo'
type MergeRequestsServiceInterface_CreateTodo_Call struct {
	*mock.Call
}

// CreateTodo is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) CreateTodo(pid interface{}, mergeRequest interface{}, options ...interface{}) *MergeRequestsServiceInterface_CreateTodo_Call {
	return &MergeRequestsServiceInterface_CreateTodo_Call{Call: _e.mock.On("CreateTodo",
		append([]interface{}{pid, mergeRequest}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_CreateTodo_Call) Run(run func(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_CreateTodo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_CreateTodo_Call) Return(_a0 *gitlab.Todo, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_CreateTodo_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_CreateTodo_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Todo, *gitlab.Response, error)) *MergeRequestsServiceInterface_CreateTodo_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteMergeRequest provides a mock function with given fields: pid, mergeRequest, options
func (_m *MergeRequestsServiceInterface) DeleteMergeRequest(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMergeRequest")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, mergeRequest, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MergeRequestsServiceInterface_DeleteMergeRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteMergeRequest'
type MergeRequestsServiceInterface_DeleteMergeRequest_Call struct {
	*mock.Call
}

// DeleteMergeRequest is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) DeleteMergeRequest(pid interface{}, mergeRequest interface{}, options ...interface{}) *MergeRequestsServiceInterface_DeleteMergeRequest_Call {
	return &MergeRequestsServiceInterface_DeleteMergeRequest_Call{Call: _e.mock.On("DeleteMergeRequest",
		append([]interface{}{pid, mergeRequest}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_DeleteMergeRequest_Call) Run(run func(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_DeleteMergeRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_DeleteMergeRequest_Call) Return(_a0 *gitlab.Response, _a1 error) *MergeRequestsServiceInterface_DeleteMergeRequest_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MergeRequestsServiceInterface_DeleteMergeRequest_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MergeRequestsServiceInterface_DeleteMergeRequest_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteMergeRequestDependency provides a mock function with given fields: pid, mergeRequest, blockingMergeRequest, options
func (_m *MergeRequestsServiceInterface) DeleteMergeRequestDependency(pid interface{}, mergeRequest int, blockingMergeRequest int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, blockingMergeRequest)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMergeRequestDependency")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, blockingMergeRequest, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, mergeRequest, blockingMergeRequest, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, mergeRequest, blockingMergeRequest, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MergeRequestsServiceInterface_DeleteMergeRequestDependency_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteMergeRequestDependency'
type MergeRequestsServiceInterface_DeleteMergeRequestDependency_Call struct {
	*mock.Call
}

// DeleteMergeRequestDependency is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - blockingMergeRequest int
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) DeleteMergeRequestDependency(pid interface{}, mergeRequest interface{}, blockingMergeRequest interface{}, options ...interface{}) *MergeRequestsServiceInterface_DeleteMergeRequestDependency_Call {
	return &MergeRequestsServiceInterface_DeleteMergeRequestDependency_Call{Call: _e.mock.On("DeleteMergeRequestDependency",
		append([]interface{}{pid, mergeRequest, blockingMergeRequest}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_DeleteMergeRequestDependency_Call) Run(run func(pid interface{}, mergeRequest int, blockingMergeRequest int, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_DeleteMergeRequestDependency_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_DeleteMergeRequestDependency_Call) Return(_a0 *gitlab.Response, _a1 error) *MergeRequestsServiceInterface_DeleteMergeRequestDependency_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MergeRequestsServiceInterface_DeleteMergeRequestDependency_Call) RunAndReturn(run func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MergeRequestsServiceInterface_DeleteMergeRequestDependency_Call {
	_c.Call.Return(run)
	return _c
}

// GetIssuesClosedOnMerge provides a mock function with given fields: pid, mergeRequest, opt, options
func (_m *MergeRequestsServiceInterface) GetIssuesClosedOnMerge(pid interface{}, mergeRequest int, opt *gitlab.GetIssuesClosedOnMergeOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIssuesClosedOnMerge")
	}

	var r0 []*gitlab.Issue
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.GetIssuesClosedOnMergeOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.GetIssuesClosedOnMergeOptions, ...gitlab.RequestOptionFunc) []*gitlab.Issue); ok {
		r0 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Issue)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.GetIssuesClosedOnMergeOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.GetIssuesClosedOnMergeOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_GetIssuesClosedOnMerge_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIssuesClosedOnMerge'
type MergeRequestsServiceInterface_GetIssuesClosedOnMerge_Call struct {
	*mock.Call
}

// GetIssuesClosedOnMerge is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - opt *gitlab.GetIssuesClosedOnMergeOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) GetIssuesClosedOnMerge(pid interface{}, mergeRequest interface{}, opt interface{}, options ...interface{}) *MergeRequestsServiceInterface_GetIssuesClosedOnMerge_Call {
	return &MergeRequestsServiceInterface_GetIssuesClosedOnMerge_Call{Call: _e.mock.On("GetIssuesClosedOnMerge",
		append([]interface{}{pid, mergeRequest, opt}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_GetIssuesClosedOnMerge_Call) Run(run func(pid interface{}, mergeRequest int, opt *gitlab.GetIssuesClosedOnMergeOptions, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_GetIssuesClosedOnMerge_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.GetIssuesClosedOnMergeOptions), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_GetIssuesClosedOnMerge_Call) Return(_a0 []*gitlab.Issue, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_GetIssuesClosedOnMerge_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_GetIssuesClosedOnMerge_Call) RunAndReturn(run func(interface{}, int, *gitlab.GetIssuesClosedOnMergeOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Issue, *gitlab.Response, error)) *MergeRequestsServiceInterface_GetIssuesClosedOnMerge_Call {
	_c.Call.Return(run)
	return _c
}

// GetMergeRequest provides a mock function with given fields: pid, mergeRequest, opt, options
func (_m *MergeRequestsServiceInterface) GetMergeRequest(pid interface{}, mergeRequest int, opt *gitlab.GetMergeRequestsOptions, options ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMergeRequest")
	}

	var r0 *gitlab.MergeRequest
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.GetMergeRequestsOptions, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.GetMergeRequestsOptions, ...gitlab.RequestOptionFunc) *gitlab.MergeRequest); ok {
		r0 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.MergeRequest)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.GetMergeRequestsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.GetMergeRequestsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_GetMergeRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMergeRequest'
type MergeRequestsServiceInterface_GetMergeRequest_Call struct {
	*mock.Call
}

// GetMergeRequest is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - opt *gitlab.GetMergeRequestsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) GetMergeRequest(pid interface{}, mergeRequest interface{}, opt interface{}, options ...interface{}) *MergeRequestsServiceInterface_GetMergeRequest_Call {
	return &MergeRequestsServiceInterface_GetMergeRequest_Call{Call: _e.mock.On("GetMergeRequest",
		append([]interface{}{pid, mergeRequest, opt}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_GetMergeRequest_Call) Run(run func(pid interface{}, mergeRequest int, opt *gitlab.GetMergeRequestsOptions, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_GetMergeRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.GetMergeRequestsOptions), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_GetMergeRequest_Call) Return(_a0 *gitlab.MergeRequest, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_GetMergeRequest_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_GetMergeRequest_Call) RunAndReturn(run func(interface{}, int, *gitlab.GetMergeRequestsOptions, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error)) *MergeRequestsServiceInterface_GetMergeRequest_Call {
	_c.Call.Return(run)
	return _c
}

// GetMergeRequestApprovals provides a mock function with given fields: pid, mergeRequest, options
func (_m *MergeRequestsServiceInterface) GetMergeRequestApprovals(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc) (*gitlab.MergeRequestApprovals, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMergeRequestApprovals")
	}

	var r0 *gitlab.MergeRequestApprovals
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequestApprovals, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.MergeRequestApprovals); ok {
		r0 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.MergeRequestApprovals)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_GetMergeRequestApprovals_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMergeRequestApprovals'
type MergeRequestsServiceInterface_GetMergeRequestApprovals_Call struct {
	*mock.Call
}

// GetMergeRequestApprovals is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) GetMergeRequestApprovals(pid interface{}, mergeRequest interface{}, options ...interface{}) *MergeRequestsServiceInterface_GetMergeRequestApprovals_Call {
	return &MergeRequestsServiceInterface_GetMergeRequestApprovals_Call{Call: _e.mock.On("GetMergeRequestApprovals",
		append([]interface{}{pid, mergeRequest}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_GetMergeRequestApprovals_Call) Run(run func(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_GetMergeRequestApprovals_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_GetMergeRequestApprovals_Call) Return(_a0 *gitlab.MergeRequestApprovals, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_GetMergeRequestApprovals_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_GetMergeRequestApprovals_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequestApprovals, *gitlab.Response, error)) *MergeRequestsServiceInterface_GetMergeRequestApprovals_Call {
	_c.Call.Return(run)
	return _c
}

// GetMergeRequestChanges provides a mock function with given fields: pid, mergeRequest, opt, options
func (_m *MergeRequestsServiceInterface) GetMergeRequestChanges(pid interface{}, mergeRequest int, opt *gitlab.GetMergeRequestChangesOptions, options ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMergeRequestChanges")
	}

	var r0 *gitlab.MergeRequest
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.GetMergeRequestChangesOptions, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.GetMergeRequestChangesOptions, ...gitlab.RequestOptionFunc) *gitlab.MergeRequest); ok {
		r0 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.MergeRequest)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.GetMergeRequestChangesOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.GetMergeRequestChangesOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_GetMergeRequestChanges_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMergeRequestChanges'
type MergeRequestsServiceInterface_GetMergeRequestChanges_Call struct {
	*mock.Call
}

// GetMergeRequestChanges is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - opt *gitlab.GetMergeRequestChangesOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) GetMergeRequestChanges(pid interface{}, mergeRequest interface{}, opt interface{}, options ...interface{}) *MergeRequestsServiceInterface_GetMergeRequestChanges_Call {
	return &MergeRequestsServiceInterface_GetMergeRequestChanges_Call{Call: _e.mock.On("GetMergeRequestChanges",
		append([]interface{}{pid, mergeRequest, opt}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_GetMergeRequestChanges_Call) Run(run func(pid interface{}, mergeRequest int, opt *gitlab.GetMergeRequestChangesOptions, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_GetMergeRequestChanges_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.GetMergeRequestChangesOptions), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_GetMergeRequestChanges_Call) Return(_a0 *gitlab.MergeRequest, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_GetMergeRequestChanges_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_GetMergeRequestChanges_Call) RunAndReturn(run func(interface{}, int, *gitlab.GetMergeRequestChangesOptions, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error)) *MergeRequestsServiceInterface_GetMergeRequestChanges_Call {
	_c.Call.Return(run)
	return _c
}

// GetMergeRequestCommits provides a mock function with given fields: pid, mergeRequest, opt, options
func (_m *MergeRequestsServiceInterface) GetMergeRequestCommits(pid interface{}, mergeRequest int, opt *gitlab.GetMergeRequestCommitsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Commit, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMergeRequestCommits")
	}

	var r0 []*gitlab.Commit
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.GetMergeRequestCommitsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Commit, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.GetMergeRequestCommitsOptions, ...gitlab.RequestOptionFunc) []*gitlab.Commit); ok {
		r0 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Commit)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.GetMergeRequestCommitsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.GetMergeRequestCommitsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_GetMergeRequestCommits_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMergeRequestCommits'
type MergeRequestsServiceInterface_GetMergeRequestCommits_Call struct {
	*mock.Call
}

// GetMergeRequestCommits is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - opt *gitlab.GetMergeRequestCommitsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) GetMergeRequestCommits(pid interface{}, mergeRequest interface{}, opt interface{}, options ...interface{}) *MergeRequestsServiceInterface_GetMergeRequestCommits_Call {
	return &MergeRequestsServiceInterface_GetMergeRequestCommits_Call{Call: _e.mock.On("GetMergeRequestCommits",
		append([]interface{}{pid, mergeRequest, opt}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_GetMergeRequestCommits_Call) Run(run func(pid interface{}, mergeRequest int, opt *gitlab.GetMergeRequestCommitsOptions, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_GetMergeRequestCommits_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.GetMergeRequestCommitsOptions), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_GetMergeRequestCommits_Call) Return(_a0 []*gitlab.Commit, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_GetMergeRequestCommits_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_GetMergeRequestCommits_Call) RunAndReturn(run func(interface{}, int, *gitlab.GetMergeRequestCommitsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Commit, *gitlab.Response, error)) *MergeRequestsServiceInterface_GetMergeRequestCommits_Call {
	_c.Call.Return(run)
	return _c
}

// GetMergeRequestDependencies provides a mock function with given fields: pid, mergeRequest, options
func (_m *MergeRequestsServiceInterface) GetMergeRequestDependencies(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc) ([]gitlab.MergeRequestDependency, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMergeRequestDependencies")
	}

	var r0 []gitlab.MergeRequestDependency
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) ([]gitlab.MergeRequestDependency, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) []gitlab.MergeRequestDependency); ok {
		r0 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]gitlab.MergeRequestDependency)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_GetMergeRequestDependencies_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMergeRequestDependencies'
type MergeRequestsServiceInterface_GetMergeRequestDependencies_Call struct {
	*mock.Call
}

// GetMergeRequestDependencies is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) GetMergeRequestDependencies(pid interface{}, mergeRequest interface{}, options ...interface{}) *MergeRequestsServiceInterface_GetMergeRequestDependencies_Call {
	return &MergeRequestsServiceInterface_GetMergeRequestDependencies_Call{Call: _e.mock.On("GetMergeRequestDependencies",
		append([]interface{}{pid, mergeRequest}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_GetMergeRequestDependencies_Call) Run(run func(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_GetMergeRequestDependencies_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_GetMergeRequestDependencies_Call) Return(_a0 []gitlab.MergeRequestDependency, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_GetMergeRequestDependencies_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_GetMergeRequestDependencies_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) ([]gitlab.MergeRequestDependency, *gitlab.Response, error)) *MergeRequestsServiceInterface_GetMergeRequestDependencies_Call {
	_c.Call.Return(run)
	return _c
}

// GetMergeRequestDiffVersions provides a mock function with given fields: pid, mergeRequest, opt, options
func (_m *MergeRequestsServiceInterface) GetMergeRequestDiffVersions(pid interface{}, mergeRequest int, opt *gitlab.GetMergeRequestDiffVersionsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequestDiffVersion, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMergeRequestDiffVersions")
	}

	var r0 []*gitlab.MergeRequestDiffVersion
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.GetMergeRequestDiffVersionsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequestDiffVersion, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.GetMergeRequestDiffVersionsOptions, ...gitlab.RequestOptionFunc) []*gitlab.MergeRequestDiffVersion); ok {
		r0 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.MergeRequestDiffVersion)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.GetMergeRequestDiffVersionsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.GetMergeRequestDiffVersionsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_GetMergeRequestDiffVersions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMergeRequestDiffVersions'
type MergeRequestsServiceInterface_GetMergeRequestDiffVersions_Call struct {
	*mock.Call
}

// GetMergeRequestDiffVersions is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - opt *gitlab.GetMergeRequestDiffVersionsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) GetMergeRequestDiffVersions(pid interface{}, mergeRequest interface{}, opt interface{}, options ...interface{}) *MergeRequestsServiceInterface_GetMergeRequestDiffVersions_Call {
	return &MergeRequestsServiceInterface_GetMergeRequestDiffVersions_Call{Call: _e.mock.On("GetMergeRequestDiffVersions",
		append([]interface{}{pid, mergeRequest, opt}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_GetMergeRequestDiffVersions_Call) Run(run func(pid interface{}, mergeRequest int, opt *gitlab.GetMergeRequestDiffVersionsOptions, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_GetMergeRequestDiffVersions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.GetMergeRequestDiffVersionsOptions), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_GetMergeRequestDiffVersions_Call) Return(_a0 []*gitlab.MergeRequestDiffVersion, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_GetMergeRequestDiffVersions_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_GetMergeRequestDiffVersions_Call) RunAndReturn(run func(interface{}, int, *gitlab.GetMergeRequestDiffVersionsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequestDiffVersion, *gitlab.Response, error)) *MergeRequestsServiceInterface_GetMergeRequestDiffVersions_Call {
	_c.Call.Return(run)
	return _c
}

// GetMergeRequestParticipants provides a mock function with given fields: pid, mergeRequest, options
func (_m *MergeRequestsServiceInterface) GetMergeRequestParticipants(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc) ([]*gitlab.BasicUser, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMergeRequestParticipants")
	}

	var r0 []*gitlab.BasicUser
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) ([]*gitlab.BasicUser, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) []*gitlab.BasicUser); ok {
		r0 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.BasicUser)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_GetMergeRequestParticipants_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMergeRequestParticipants'
type MergeRequestsServiceInterface_GetMergeRequestParticipants_Call struct {
	*mock.Call
}

// GetMergeRequestParticipants is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) GetMergeRequestParticipants(pid interface{}, mergeRequest interface{}, options ...interface{}) *MergeRequestsServiceInterface_GetMergeRequestParticipants_Call {
	return &MergeRequestsServiceInterface_GetMergeRequestParticipants_Call{Call: _e.mock.On("GetMergeRequestParticipants",
		append([]interface{}{pid, mergeRequest}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_GetMergeRequestParticipants_Call) Run(run func(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_GetMergeRequestParticipants_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_GetMergeRequestParticipants_Call) Return(_a0 []*gitlab.BasicUser, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_GetMergeRequestParticipants_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_GetMergeRequestParticipants_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) ([]*gitlab.BasicUser, *gitlab.Response, error)) *MergeRequestsServiceInterface_GetMergeRequestParticipants_Call {
	_c.Call.Return(run)
	return _c
}

// GetMergeRequestReviewers provides a mock function with given fields: pid, mergeRequest, options
func (_m *MergeRequestsServiceInterface) GetMergeRequestReviewers(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequestReviewer, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMergeRequestReviewers")
	}

	var r0 []*gitlab.MergeRequestReviewer
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequestReviewer, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) []*gitlab.MergeRequestReviewer); ok {
		r0 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.MergeRequestReviewer)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_GetMergeRequestReviewers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMergeRequestReviewers'
type MergeRequestsServiceInterface_GetMergeRequestReviewers_Call struct {
	*mock.Call
}

// GetMergeRequestReviewers is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) GetMergeRequestReviewers(pid interface{}, mergeRequest interface{}, options ...interface{}) *MergeRequestsServiceInterface_GetMergeRequestReviewers_Call {
	return &MergeRequestsServiceInterface_GetMergeRequestReviewers_Call{Call: _e.mock.On("GetMergeRequestReviewers",
		append([]interface{}{pid, mergeRequest}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_GetMergeRequestReviewers_Call) Run(run func(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_GetMergeRequestReviewers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_GetMergeRequestReviewers_Call) Return(_a0 []*gitlab.MergeRequestReviewer, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_GetMergeRequestReviewers_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_GetMergeRequestReviewers_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequestReviewer, *gitlab.Response, error)) *MergeRequestsServiceInterface_GetMergeRequestReviewers_Call {
	_c.Call.Return(run)
	return _c
}

// GetSingleMergeRequestDiffVersion provides a mock function with given fields: pid, mergeRequest, version, opt, options
func (_m *MergeRequestsServiceInterface) GetSingleMergeRequestDiffVersion(pid interface{}, mergeRequest int, version int, opt *gitlab.GetSingleMergeRequestDiffVersionOptions, options ...gitlab.RequestOptionFunc) (*gitlab.MergeRequestDiffVersion, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, version, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSingleMergeRequestDiffVersion")
	}

	var r0 *gitlab.MergeRequestDiffVersion
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, *gitlab.GetSingleMergeRequestDiffVersionOptions, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequestDiffVersion, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, version, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, *gitlab.GetSingleMergeRequestDiffVersionOptions, ...gitlab.RequestOptionFunc) *gitlab.MergeRequestDiffVersion); ok {
		r0 = rf(pid, mergeRequest, version, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.MergeRequestDiffVersion)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, *gitlab.GetSingleMergeRequestDiffVersionOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, version, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, int, *gitlab.GetSingleMergeRequestDiffVersionOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, version, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_GetSingleMergeRequestDiffVersion_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSingleMergeRequestDiffVersion'
type MergeRequestsServiceInterface_GetSingleMergeRequestDiffVersion_Call struct {
	*mock.Call
}

// GetSingleMergeRequestDiffVersion is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - version int
//   - opt *gitlab.GetSingleMergeRequestDiffVersionOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) GetSingleMergeRequestDiffVersion(pid interface{}, mergeRequest interface{}, version interface{}, opt interface{}, options ...interface{}) *MergeRequestsServiceInterface_GetSingleMergeRequestDiffVersion_Call {
	return &MergeRequestsServiceInterface_GetSingleMergeRequestDiffVersion_Call{Call: _e.mock.On("GetSingleMergeRequestDiffVersion",
		append([]interface{}{pid, mergeRequest, version, opt}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_GetSingleMergeRequestDiffVersion_Call) Run(run func(pid interface{}, mergeRequest int, version int, opt *gitlab.GetSingleMergeRequestDiffVersionOptions, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_GetSingleMergeRequestDiffVersion_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), args[3].(*gitlab.GetSingleMergeRequestDiffVersionOptions), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_GetSingleMergeRequestDiffVersion_Call) Return(_a0 *gitlab.MergeRequestDiffVersion, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_GetSingleMergeRequestDiffVersion_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_GetSingleMergeRequestDiffVersion_Call) RunAndReturn(run func(interface{}, int, int, *gitlab.GetSingleMergeRequestDiffVersionOptions, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequestDiffVersion, *gitlab.Response, error)) *MergeRequestsServiceInterface_GetSingleMergeRequestDiffVersion_Call {
	_c.Call.Return(run)
	return _c
}

// GetTimeSpent provides a mock function with given fields: pid, mergeRequest, options
func (_m *MergeRequestsServiceInterface) GetTimeSpent(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetTimeSpent")
	}

	var r0 *gitlab.TimeStats
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.TimeStats); ok {
		r0 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.TimeStats)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_GetTimeSpent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTimeSpent'
type MergeRequestsServiceInterface_GetTimeSpent_Call struct {
	*mock.Call
}

// GetTimeSpent is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) GetTimeSpent(pid interface{}, mergeRequest interface{}, options ...interface{}) *MergeRequestsServiceInterface_GetTimeSpent_Call {
	return &MergeRequestsServiceInterface_GetTimeSpent_Call{Call: _e.mock.On("GetTimeSpent",
		append([]interface{}{pid, mergeRequest}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_GetTimeSpent_Call) Run(run func(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_GetTimeSpent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_GetTimeSpent_Call) Return(_a0 *gitlab.TimeStats, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_GetTimeSpent_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_GetTimeSpent_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)) *MergeRequestsServiceInterface_GetTimeSpent_Call {
	_c.Call.Return(run)
	return _c
}

// ListGroupMergeRequests provides a mock function with given fields: gid, opt, options
func (_m *MergeRequestsServiceInterface) ListGroupMergeRequests(gid interface{}, opt *gitlab.ListGroupMergeRequestsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.BasicMergeRequest, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListGroupMergeRequests")
	}

	var r0 []*gitlab.BasicMergeRequest
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListGroupMergeRequestsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.BasicMergeRequest, *gitlab.Response, error)); ok {
		return rf(gid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListGroupMergeRequestsOptions, ...gitlab.RequestOptionFunc) []*gitlab.BasicMergeRequest); ok {
		r0 = rf(gid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.BasicMergeRequest)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListGroupMergeRequestsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListGroupMergeRequestsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_ListGroupMergeRequests_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListGroupMergeRequests'
type MergeRequestsServiceInterface_ListGroupMergeRequests_Call struct {
	*mock.Call
}

// ListGroupMergeRequests is a helper method to define mock.On call
//   - gid interface{}
//   - opt *gitlab.ListGroupMergeRequestsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) ListGroupMergeRequests(gid interface{}, opt interface{}, options ...interface{}) *MergeRequestsServiceInterface_ListGroupMergeRequests_Call {
	return &MergeRequestsServiceInterface_ListGroupMergeRequests_Call{Call: _e.mock.On("ListGroupMergeRequests",
		append([]interface{}{gid, opt}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_ListGroupMergeRequests_Call) Run(run func(gid interface{}, opt *gitlab.ListGroupMergeRequestsOptions, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_ListGroupMergeRequests_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListGroupMergeRequestsOptions), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_ListGroupMergeRequests_Call) Return(_a0 []*gitlab.BasicMergeRequest, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_ListGroupMergeRequests_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_ListGroupMergeRequests_Call) RunAndReturn(run func(interface{}, *gitlab.ListGroupMergeRequestsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.BasicMergeRequest, *gitlab.Response, error)) *MergeRequestsServiceInterface_ListGroupMergeRequests_Call {
	_c.Call.Return(run)
	return _c
}

// ListMergeRequestDiffs provides a mock function with given fields: pid, mergeRequest, opt, options
func (_m *MergeRequestsServiceInterface) ListMergeRequestDiffs(pid interface{}, mergeRequest int, opt *gitlab.ListMergeRequestDiffsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequestDiff, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMergeRequestDiffs")
	}

	var r0 []*gitlab.MergeRequestDiff
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListMergeRequestDiffsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequestDiff, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListMergeRequestDiffsOptions, ...gitlab.RequestOptionFunc) []*gitlab.MergeRequestDiff); ok {
		r0 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.MergeRequestDiff)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.ListMergeRequestDiffsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.ListMergeRequestDiffsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_ListMergeRequestDiffs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMergeRequestDiffs'
type MergeRequestsServiceInterface_ListMergeRequestDiffs_Call struct {
	*mock.Call
}

// ListMergeRequestDiffs is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - opt *gitlab.ListMergeRequestDiffsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) ListMergeRequestDiffs(pid interface{}, mergeRequest interface{}, opt interface{}, options ...interface{}) *MergeRequestsServiceInterface_ListMergeRequestDiffs_Call {
	return &MergeRequestsServiceInterface_ListMergeRequestDiffs_Call{Call: _e.mock.On("ListMergeRequestDiffs",
		append([]interface{}{pid, mergeRequest, opt}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_ListMergeRequestDiffs_Call) Run(run func(pid interface{}, mergeRequest int, opt *gitlab.ListMergeRequestDiffsOptions, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_ListMergeRequestDiffs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.ListMergeRequestDiffsOptions), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_ListMergeRequestDiffs_Call) Return(_a0 []*gitlab.MergeRequestDiff, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_ListMergeRequestDiffs_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_ListMergeRequestDiffs_Call) RunAndReturn(run func(interface{}, int, *gitlab.ListMergeRequestDiffsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.MergeRequestDiff, *gitlab.Response, error)) *MergeRequestsServiceInterface_ListMergeRequestDiffs_Call {
	_c.Call.Return(run)
	return _c
}

// ListMergeRequestPipelines provides a mock function with given fields: pid, mergeRequest, options
func (_m *MergeRequestsServiceInterface) ListMergeRequestPipelines(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc) ([]*gitlab.PipelineInfo, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMergeRequestPipelines")
	}

	var r0 []*gitlab.PipelineInfo
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) ([]*gitlab.PipelineInfo, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) []*gitlab.PipelineInfo); ok {
		r0 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.PipelineInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_ListMergeRequestPipelines_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMergeRequestPipelines'
type MergeRequestsServiceInterface_ListMergeRequestPipelines_Call struct {
	*mock.Call
}

// ListMergeRequestPipelines is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) ListMergeRequestPipelines(pid interface{}, mergeRequest interface{}, options ...interface{}) *MergeRequestsServiceInterface_ListMergeRequestPipelines_Call {
	return &MergeRequestsServiceInterface_ListMergeRequestPipelines_Call{Call: _e.mock.On("ListMergeRequestPipelines",
		append([]interface{}{pid, mergeRequest}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_ListMergeRequestPipelines_Call) Run(run func(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_ListMergeRequestPipelines_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_ListMergeRequestPipelines_Call) Return(_a0 []*gitlab.PipelineInfo, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_ListMergeRequestPipelines_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_ListMergeRequestPipelines_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) ([]*gitlab.PipelineInfo, *gitlab.Response, error)) *MergeRequestsServiceInterface_ListMergeRequestPipelines_Call {
	_c.Call.Return(run)
	return _c
}

// ListMergeRequests provides a mock function with given fields: opt, options
func (_m *MergeRequestsServiceInterface) ListMergeRequests(opt *gitlab.ListMergeRequestsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.BasicMergeRequest, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMergeRequests")
	}

	var r0 []*gitlab.BasicMergeRequest
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(*gitlab.ListMergeRequestsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.BasicMergeRequest, *gitlab.Response, error)); ok {
		return rf(opt, options...)
	}
	if rf, ok := ret.Get(0).(func(*gitlab.ListMergeRequestsOptions, ...gitlab.RequestOptionFunc) []*gitlab.BasicMergeRequest); ok {
		r0 = rf(opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.BasicMergeRequest)
		}
	}

	if rf, ok := ret.Get(1).(func(*gitlab.ListMergeRequestsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(*gitlab.ListMergeRequestsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_ListMergeRequests_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMergeRequests'
type MergeRequestsServiceInterface_ListMergeRequests_Call struct {
	*mock.Call
}

// ListMergeRequests is a helper method to define mock.On call
//   - opt *gitlab.ListMergeRequestsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) ListMergeRequests(opt interface{}, options ...interface{}) *MergeRequestsServiceInterface_ListMergeRequests_Call {
	return &MergeRequestsServiceInterface_ListMergeRequests_Call{Call: _e.mock.On("ListMergeRequests",
		append([]interface{}{opt}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_ListMergeRequests_Call) Run(run func(opt *gitlab.ListMergeRequestsOptions, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_ListMergeRequests_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(*gitlab.ListMergeRequestsOptions), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_ListMergeRequests_Call) Return(_a0 []*gitlab.BasicMergeRequest, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_ListMergeRequests_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_ListMergeRequests_Call) RunAndReturn(run func(*gitlab.ListMergeRequestsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.BasicMergeRequest, *gitlab.Response, error)) *MergeRequestsServiceInterface_ListMergeRequests_Call {
	_c.Call.Return(run)
	return _c
}

// ListProjectMergeRequests provides a mock function with given fields: pid, opt, options
func (_m *MergeRequestsServiceInterface) ListProjectMergeRequests(pid interface{}, opt *gitlab.ListProjectMergeRequestsOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.BasicMergeRequest, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListProjectMergeRequests")
	}

	var r0 []*gitlab.BasicMergeRequest
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListProjectMergeRequestsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.BasicMergeRequest, *gitlab.Response, error)); ok {
		return rf(pid, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, *gitlab.ListProjectMergeRequestsOptions, ...gitlab.RequestOptionFunc) []*gitlab.BasicMergeRequest); ok {
		r0 = rf(pid, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.BasicMergeRequest)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, *gitlab.ListProjectMergeRequestsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, *gitlab.ListProjectMergeRequestsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_ListProjectMergeRequests_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListProjectMergeRequests'
type MergeRequestsServiceInterface_ListProjectMergeRequests_Call struct {
	*mock.Call
}

// ListProjectMergeRequests is a helper method to define mock.On call
//   - pid interface{}
//   - opt *gitlab.ListProjectMergeRequestsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) ListProjectMergeRequests(pid interface{}, opt interface{}, options ...interface{}) *MergeRequestsServiceInterface_ListProjectMergeRequests_Call {
	return &MergeRequestsServiceInterface_ListProjectMergeRequests_Call{Call: _e.mock.On("ListProjectMergeRequests",
		append([]interface{}{pid, opt}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_ListProjectMergeRequests_Call) Run(run func(pid interface{}, opt *gitlab.ListProjectMergeRequestsOptions, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_ListProjectMergeRequests_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(*gitlab.ListProjectMergeRequestsOptions), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_ListProjectMergeRequests_Call) Return(_a0 []*gitlab.BasicMergeRequest, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_ListProjectMergeRequests_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_ListProjectMergeRequests_Call) RunAndReturn(run func(interface{}, *gitlab.ListProjectMergeRequestsOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.BasicMergeRequest, *gitlab.Response, error)) *MergeRequestsServiceInterface_ListProjectMergeRequests_Call {
	_c.Call.Return(run)
	return _c
}

// RebaseMergeRequest provides a mock function with given fields: pid, mergeRequest, opt, options
func (_m *MergeRequestsServiceInterface) RebaseMergeRequest(pid interface{}, mergeRequest int, opt *gitlab.RebaseMergeRequestOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for RebaseMergeRequest")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.RebaseMergeRequestOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.RebaseMergeRequestOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.RebaseMergeRequestOptions, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, mergeRequest, opt, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MergeRequestsServiceInterface_RebaseMergeRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RebaseMergeRequest'
type MergeRequestsServiceInterface_RebaseMergeRequest_Call struct {
	*mock.Call
}

// RebaseMergeRequest is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - opt *gitlab.RebaseMergeRequestOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) RebaseMergeRequest(pid interface{}, mergeRequest interface{}, opt interface{}, options ...interface{}) *MergeRequestsServiceInterface_RebaseMergeRequest_Call {
	return &MergeRequestsServiceInterface_RebaseMergeRequest_Call{Call: _e.mock.On("RebaseMergeRequest",
		append([]interface{}{pid, mergeRequest, opt}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_RebaseMergeRequest_Call) Run(run func(pid interface{}, mergeRequest int, opt *gitlab.RebaseMergeRequestOptions, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_RebaseMergeRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.RebaseMergeRequestOptions), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_RebaseMergeRequest_Call) Return(_a0 *gitlab.Response, _a1 error) *MergeRequestsServiceInterface_RebaseMergeRequest_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MergeRequestsServiceInterface_RebaseMergeRequest_Call) RunAndReturn(run func(interface{}, int, *gitlab.RebaseMergeRequestOptions, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *MergeRequestsServiceInterface_RebaseMergeRequest_Call {
	_c.Call.Return(run)
	return _c
}

// ResetSpentTime provides a mock function with given fields: pid, mergeRequest, options
func (_m *MergeRequestsServiceInterface) ResetSpentTime(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetSpentTime")
	}

	var r0 *gitlab.TimeStats
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.TimeStats); ok {
		r0 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.TimeStats)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_ResetSpentTime_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResetSpentTime'
type MergeRequestsServiceInterface_ResetSpentTime_Call struct {
	*mock.Call
}

// ResetSpentTime is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) ResetSpentTime(pid interface{}, mergeRequest interface{}, options ...interface{}) *MergeRequestsServiceInterface_ResetSpentTime_Call {
	return &MergeRequestsServiceInterface_ResetSpentTime_Call{Call: _e.mock.On("ResetSpentTime",
		append([]interface{}{pid, mergeRequest}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_ResetSpentTime_Call) Run(run func(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_ResetSpentTime_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_ResetSpentTime_Call) Return(_a0 *gitlab.TimeStats, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_ResetSpentTime_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_ResetSpentTime_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)) *MergeRequestsServiceInterface_ResetSpentTime_Call {
	_c.Call.Return(run)
	return _c
}

// ResetTimeEstimate provides a mock function with given fields: pid, mergeRequest, options
func (_m *MergeRequestsServiceInterface) ResetTimeEstimate(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ResetTimeEstimate")
	}

	var r0 *gitlab.TimeStats
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.TimeStats); ok {
		r0 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.TimeStats)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_ResetTimeEstimate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResetTimeEstimate'
type MergeRequestsServiceInterface_ResetTimeEstimate_Call struct {
	*mock.Call
}

// ResetTimeEstimate is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) ResetTimeEstimate(pid interface{}, mergeRequest interface{}, options ...interface{}) *MergeRequestsServiceInterface_ResetTimeEstimate_Call {
	return &MergeRequestsServiceInterface_ResetTimeEstimate_Call{Call: _e.mock.On("ResetTimeEstimate",
		append([]interface{}{pid, mergeRequest}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_ResetTimeEstimate_Call) Run(run func(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_ResetTimeEstimate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_ResetTimeEstimate_Call) Return(_a0 *gitlab.TimeStats, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_ResetTimeEstimate_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_ResetTimeEstimate_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)) *MergeRequestsServiceInterface_ResetTimeEstimate_Call {
	_c.Call.Return(run)
	return _c
}

// SetTimeEstimate provides a mock function with given fields: pid, mergeRequest, opt, options
func (_m *MergeRequestsServiceInterface) SetTimeEstimate(pid interface{}, mergeRequest int, opt *gitlab.SetTimeEstimateOptions, options ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SetTimeEstimate")
	}

	var r0 *gitlab.TimeStats
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.SetTimeEstimateOptions, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.SetTimeEstimateOptions, ...gitlab.RequestOptionFunc) *gitlab.TimeStats); ok {
		r0 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.TimeStats)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.SetTimeEstimateOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.SetTimeEstimateOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_SetTimeEstimate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetTimeEstimate'
type MergeRequestsServiceInterface_SetTimeEstimate_Call struct {
	*mock.Call
}

// SetTimeEstimate is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - opt *gitlab.SetTimeEstimateOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) SetTimeEstimate(pid interface{}, mergeRequest interface{}, opt interface{}, options ...interface{}) *MergeRequestsServiceInterface_SetTimeEstimate_Call {
	return &MergeRequestsServiceInterface_SetTimeEstimate_Call{Call: _e.mock.On("SetTimeEstimate",
		append([]interface{}{pid, mergeRequest, opt}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_SetTimeEstimate_Call) Run(run func(pid interface{}, mergeRequest int, opt *gitlab.SetTimeEstimateOptions, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_SetTimeEstimate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.SetTimeEstimateOptions), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_SetTimeEstimate_Call) Return(_a0 *gitlab.TimeStats, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_SetTimeEstimate_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_SetTimeEstimate_Call) RunAndReturn(run func(interface{}, int, *gitlab.SetTimeEstimateOptions, ...gitlab.RequestOptionFunc) (*gitlab.TimeStats, *gitlab.Response, error)) *MergeRequestsServiceInterface_SetTimeEstimate_Call {
	_c.Call.Return(run)
	return _c
}

// ShowMergeRequestRawDiffs provides a mock function with given fields: pid, mergeRequest, opt, options
func (_m *MergeRequestsServiceInterface) ShowMergeRequestRawDiffs(pid interface{}, mergeRequest int, opt *gitlab.ShowMergeRequestRawDiffsOptions, options ...gitlab.RequestOptionFunc) ([]byte, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ShowMergeRequestRawDiffs")
	}

	var r0 []byte
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ShowMergeRequestRawDiffsOptions, ...gitlab.RequestOptionFunc) ([]byte, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ShowMergeRequestRawDiffsOptions, ...gitlab.RequestOptionFunc) []byte); ok {
		r0 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.ShowMergeRequestRawDiffsOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.ShowMergeRequestRawDiffsOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_ShowMergeRequestRawDiffs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ShowMergeRequestRawDiffs'
type MergeRequestsServiceInterface_ShowMergeRequestRawDiffs_Call struct {
	*mock.Call
}

// ShowMergeRequestRawDiffs is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - opt *gitlab.ShowMergeRequestRawDiffsOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) ShowMergeRequestRawDiffs(pid interface{}, mergeRequest interface{}, opt interface{}, options ...interface{}) *MergeRequestsServiceInterface_ShowMergeRequestRawDiffs_Call {
	return &MergeRequestsServiceInterface_ShowMergeRequestRawDiffs_Call{Call: _e.mock.On("ShowMergeRequestRawDiffs",
		append([]interface{}{pid, mergeRequest, opt}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_ShowMergeRequestRawDiffs_Call) Run(run func(pid interface{}, mergeRequest int, opt *gitlab.ShowMergeRequestRawDiffsOptions, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_ShowMergeRequestRawDiffs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.ShowMergeRequestRawDiffsOptions), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_ShowMergeRequestRawDiffs_Call) Return(_a0 []byte, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_ShowMergeRequestRawDiffs_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_ShowMergeRequestRawDiffs_Call) RunAndReturn(run func(interface{}, int, *gitlab.ShowMergeRequestRawDiffsOptions, ...gitlab.RequestOptionFunc) ([]byte, *gitlab.Response, error)) *MergeRequestsServiceInterface_ShowMergeRequestRawDiffs_Call {
	_c.Call.Return(run)
	return _c
}

// SubscribeToMergeRequest provides a mock function with given fields: pid, mergeRequest, options
func (_m *MergeRequestsServiceInterface) SubscribeToMergeRequest(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for SubscribeToMergeRequest")
	}

	var r0 *gitlab.MergeRequest
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.MergeRequest); ok {
		r0 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.MergeRequest)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_SubscribeToMergeRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SubscribeToMergeRequest'
type MergeRequestsServiceInterface_SubscribeToMergeRequest_Call struct {
	*mock.Call
}

// SubscribeToMergeRequest is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) SubscribeToMergeRequest(pid interface{}, mergeRequest interface{}, options ...interface{}) *MergeRequestsServiceInterface_SubscribeToMergeRequest_Call {
	return &MergeRequestsServiceInterface_SubscribeToMergeRequest_Call{Call: _e.mock.On("SubscribeToMergeRequest",
		append([]interface{}{pid, mergeRequest}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_SubscribeToMergeRequest_Call) Run(run func(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_SubscribeToMergeRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_SubscribeToMergeRequest_Call) Return(_a0 *gitlab.MergeRequest, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_SubscribeToMergeRequest_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_SubscribeToMergeRequest_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error)) *MergeRequestsServiceInterface_SubscribeToMergeRequest_Call {
	_c.Call.Return(run)
	return _c
}

// UnsubscribeFromMergeRequest provides a mock function with given fields: pid, mergeRequest, options
func (_m *MergeRequestsServiceInterface) UnsubscribeFromMergeRequest(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UnsubscribeFromMergeRequest")
	}

	var r0 *gitlab.MergeRequest
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.MergeRequest); ok {
		r0 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.MergeRequest)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_UnsubscribeFromMergeRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsubscribeFromMergeRequest'
type MergeRequestsServiceInterface_UnsubscribeFromMergeRequest_Call struct {
	*mock.Call
}

// UnsubscribeFromMergeRequest is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) UnsubscribeFromMergeRequest(pid interface{}, mergeRequest interface{}, options ...interface{}) *MergeRequestsServiceInterface_UnsubscribeFromMergeRequest_Call {
	return &MergeRequestsServiceInterface_UnsubscribeFromMergeRequest_Call{Call: _e.mock.On("UnsubscribeFromMergeRequest",
		append([]interface{}{pid, mergeRequest}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_UnsubscribeFromMergeRequest_Call) Run(run func(pid interface{}, mergeRequest int, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_UnsubscribeFromMergeRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_UnsubscribeFromMergeRequest_Call) Return(_a0 *gitlab.MergeRequest, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_UnsubscribeFromMergeRequest_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_UnsubscribeFromMergeRequest_Call) RunAndReturn(run func(interface{}, int, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error)) *MergeRequestsServiceInterface_UnsubscribeFromMergeRequest_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateMergeRequest provides a mock function with given fields: pid, mergeRequest, opt, options
func (_m *MergeRequestsServiceInterface) UpdateMergeRequest(pid interface{}, mergeRequest int, opt *gitlab.UpdateMergeRequestOptions, options ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMergeRequest")
	}

	var r0 *gitlab.MergeRequest
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.UpdateMergeRequestOptions, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.UpdateMergeRequestOptions, ...gitlab.RequestOptionFunc) *gitlab.MergeRequest); ok {
		r0 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.MergeRequest)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.UpdateMergeRequestOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.UpdateMergeRequestOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MergeRequestsServiceInterface_UpdateMergeRequest_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateMergeRequest'
type MergeRequestsServiceInterface_UpdateMergeRequest_Call struct {
	*mock.Call
}

// UpdateMergeRequest is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - opt *gitlab.UpdateMergeRequestOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *MergeRequestsServiceInterface_Expecter) UpdateMergeRequest(pid interface{}, mergeRequest interface{}, opt interface{}, options ...interface{}) *MergeRequestsServiceInterface_UpdateMergeRequest_Call {
	return &MergeRequestsServiceInterface_UpdateMergeRequest_Call{Call: _e.mock.On("UpdateMergeRequest",
		append([]interface{}{pid, mergeRequest, opt}, options...)...)}
}

func (_c *MergeRequestsServiceInterface_UpdateMergeRequest_Call) Run(run func(pid interface{}, mergeRequest int, opt *gitlab.UpdateMergeRequestOptions, options ...gitlab.RequestOptionFunc)) *MergeRequestsServiceInterface_UpdateMergeRequest_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.UpdateMergeRequestOptions), variadicArgs...)
	})
	return _c
}

func (_c *MergeRequestsServiceInterface_UpdateMergeRequest_Call) Return(_a0 *gitlab.MergeRequest, _a1 *gitlab.Response, _a2 error) *MergeRequestsServiceInterface_UpdateMergeRequest_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MergeRequestsServiceInterface_UpdateMergeRequest_Call) RunAndReturn(run func(interface{}, int, *gitlab.UpdateMergeRequestOptions, ...gitlab.RequestOptionFunc) (*gitlab.MergeRequest, *gitlab.Response, error)) *MergeRequestsServiceInterface_UpdateMergeRequest_Call {
	_c.Call.Return(run)
	return _c
}

// NewMergeRequestsServiceInterface creates a new instance of MergeRequestsServiceInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMergeRequestsServiceInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *MergeRequestsServiceInterface {
	mock := &MergeRequestsServiceInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

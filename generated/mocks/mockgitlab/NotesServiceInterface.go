// Code generated by mockery v2.53.3. DO NOT EDIT.

package mocks

import (
	mock "github.com/stretchr/testify/mock"
	gitlab "gitlab.com/gitlab-org/api/client-go"
)

// NotesServiceInterface is an autogenerated mock type for the NotesServiceInterface type
type NotesServiceInterface struct {
	mock.Mock
}

type NotesServiceInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *NotesServiceInterface) EXPECT() *NotesServiceInterface_Expecter {
	return &NotesServiceInterface_Expecter{mock: &_m.Mock}
}

// CreateEpicNote provides a mock function with given fields: gid, epic, opt, options
func (_m *NotesServiceInterface) CreateEpicNote(gid interface{}, epic int, opt *gitlab.CreateEpicNoteOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, epic, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateEpicNote")
	}

	var r0 *gitlab.Note
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.CreateEpicNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)); ok {
		return rf(gid, epic, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.CreateEpicNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Note); ok {
		r0 = rf(gid, epic, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Note)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.CreateEpicNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, epic, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.CreateEpicNoteOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, epic, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NotesServiceInterface_CreateEpicNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateEpicNote'
type NotesServiceInterface_CreateEpicNote_Call struct {
	*mock.Call
}

// CreateEpicNote is a helper method to define mock.On call
//   - gid interface{}
//   - epic int
//   - opt *gitlab.CreateEpicNoteOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *NotesServiceInterface_Expecter) CreateEpicNote(gid interface{}, epic interface{}, opt interface{}, options ...interface{}) *NotesServiceInterface_CreateEpicNote_Call {
	return &NotesServiceInterface_CreateEpicNote_Call{Call: _e.mock.On("CreateEpicNote",
		append([]interface{}{gid, epic, opt}, options...)...)}
}

func (_c *NotesServiceInterface_CreateEpicNote_Call) Run(run func(gid interface{}, epic int, opt *gitlab.CreateEpicNoteOptions, options ...gitlab.RequestOptionFunc)) *NotesServiceInterface_CreateEpicNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.CreateEpicNoteOptions), variadicArgs...)
	})
	return _c
}

func (_c *NotesServiceInterface_CreateEpicNote_Call) Return(_a0 *gitlab.Note, _a1 *gitlab.Response, _a2 error) *NotesServiceInterface_CreateEpicNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *NotesServiceInterface_CreateEpicNote_Call) RunAndReturn(run func(interface{}, int, *gitlab.CreateEpicNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *NotesServiceInterface_CreateEpicNote_Call {
	_c.Call.Return(run)
	return _c
}

// CreateIssueNote provides a mock function with given fields: pid, issue, opt, options
func (_m *NotesServiceInterface) CreateIssueNote(pid interface{}, issue int, opt *gitlab.CreateIssueNoteOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issue, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateIssueNote")
	}

	var r0 *gitlab.Note
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.CreateIssueNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)); ok {
		return rf(pid, issue, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.CreateIssueNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Note); ok {
		r0 = rf(pid, issue, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Note)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.CreateIssueNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issue, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.CreateIssueNoteOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issue, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NotesServiceInterface_CreateIssueNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateIssueNote'
type NotesServiceInterface_CreateIssueNote_Call struct {
	*mock.Call
}

// CreateIssueNote is a helper method to define mock.On call
//   - pid interface{}
//   - issue int
//   - opt *gitlab.CreateIssueNoteOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *NotesServiceInterface_Expecter) CreateIssueNote(pid interface{}, issue interface{}, opt interface{}, options ...interface{}) *NotesServiceInterface_CreateIssueNote_Call {
	return &NotesServiceInterface_CreateIssueNote_Call{Call: _e.mock.On("CreateIssueNote",
		append([]interface{}{pid, issue, opt}, options...)...)}
}

func (_c *NotesServiceInterface_CreateIssueNote_Call) Run(run func(pid interface{}, issue int, opt *gitlab.CreateIssueNoteOptions, options ...gitlab.RequestOptionFunc)) *NotesServiceInterface_CreateIssueNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.CreateIssueNoteOptions), variadicArgs...)
	})
	return _c
}

func (_c *NotesServiceInterface_CreateIssueNote_Call) Return(_a0 *gitlab.Note, _a1 *gitlab.Response, _a2 error) *NotesServiceInterface_CreateIssueNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *NotesServiceInterface_CreateIssueNote_Call) RunAndReturn(run func(interface{}, int, *gitlab.CreateIssueNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *NotesServiceInterface_CreateIssueNote_Call {
	_c.Call.Return(run)
	return _c
}

// CreateMergeRequestNote provides a mock function with given fields: pid, mergeRequest, opt, options
func (_m *NotesServiceInterface) CreateMergeRequestNote(pid interface{}, mergeRequest int, opt *gitlab.CreateMergeRequestNoteOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateMergeRequestNote")
	}

	var r0 *gitlab.Note
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.CreateMergeRequestNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.CreateMergeRequestNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Note); ok {
		r0 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Note)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.CreateMergeRequestNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.CreateMergeRequestNoteOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NotesServiceInterface_CreateMergeRequestNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMergeRequestNote'
type NotesServiceInterface_CreateMergeRequestNote_Call struct {
	*mock.Call
}

// CreateMergeRequestNote is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - opt *gitlab.CreateMergeRequestNoteOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *NotesServiceInterface_Expecter) CreateMergeRequestNote(pid interface{}, mergeRequest interface{}, opt interface{}, options ...interface{}) *NotesServiceInterface_CreateMergeRequestNote_Call {
	return &NotesServiceInterface_CreateMergeRequestNote_Call{Call: _e.mock.On("CreateMergeRequestNote",
		append([]interface{}{pid, mergeRequest, opt}, options...)...)}
}

func (_c *NotesServiceInterface_CreateMergeRequestNote_Call) Run(run func(pid interface{}, mergeRequest int, opt *gitlab.CreateMergeRequestNoteOptions, options ...gitlab.RequestOptionFunc)) *NotesServiceInterface_CreateMergeRequestNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.CreateMergeRequestNoteOptions), variadicArgs...)
	})
	return _c
}

func (_c *NotesServiceInterface_CreateMergeRequestNote_Call) Return(_a0 *gitlab.Note, _a1 *gitlab.Response, _a2 error) *NotesServiceInterface_CreateMergeRequestNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *NotesServiceInterface_CreateMergeRequestNote_Call) RunAndReturn(run func(interface{}, int, *gitlab.CreateMergeRequestNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *NotesServiceInterface_CreateMergeRequestNote_Call {
	_c.Call.Return(run)
	return _c
}

// CreateSnippetNote provides a mock function with given fields: pid, snippet, opt, options
func (_m *NotesServiceInterface) CreateSnippetNote(pid interface{}, snippet int, opt *gitlab.CreateSnippetNoteOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, snippet, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateSnippetNote")
	}

	var r0 *gitlab.Note
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.CreateSnippetNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)); ok {
		return rf(pid, snippet, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.CreateSnippetNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Note); ok {
		r0 = rf(pid, snippet, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Note)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.CreateSnippetNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, snippet, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.CreateSnippetNoteOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, snippet, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NotesServiceInterface_CreateSnippetNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateSnippetNote'
type NotesServiceInterface_CreateSnippetNote_Call struct {
	*mock.Call
}

// CreateSnippetNote is a helper method to define mock.On call
//   - pid interface{}
//   - snippet int
//   - opt *gitlab.CreateSnippetNoteOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *NotesServiceInterface_Expecter) CreateSnippetNote(pid interface{}, snippet interface{}, opt interface{}, options ...interface{}) *NotesServiceInterface_CreateSnippetNote_Call {
	return &NotesServiceInterface_CreateSnippetNote_Call{Call: _e.mock.On("CreateSnippetNote",
		append([]interface{}{pid, snippet, opt}, options...)...)}
}

func (_c *NotesServiceInterface_CreateSnippetNote_Call) Run(run func(pid interface{}, snippet int, opt *gitlab.CreateSnippetNoteOptions, options ...gitlab.RequestOptionFunc)) *NotesServiceInterface_CreateSnippetNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.CreateSnippetNoteOptions), variadicArgs...)
	})
	return _c
}

func (_c *NotesServiceInterface_CreateSnippetNote_Call) Return(_a0 *gitlab.Note, _a1 *gitlab.Response, _a2 error) *NotesServiceInterface_CreateSnippetNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *NotesServiceInterface_CreateSnippetNote_Call) RunAndReturn(run func(interface{}, int, *gitlab.CreateSnippetNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *NotesServiceInterface_CreateSnippetNote_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteEpicNote provides a mock function with given fields: gid, epic, note, options
func (_m *NotesServiceInterface) DeleteEpicNote(gid interface{}, epic int, note int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, epic, note)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEpicNote")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(gid, epic, note, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(gid, epic, note, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(gid, epic, note, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NotesServiceInterface_DeleteEpicNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteEpicNote'
type NotesServiceInterface_DeleteEpicNote_Call struct {
	*mock.Call
}

// DeleteEpicNote is a helper method to define mock.On call
//   - gid interface{}
//   - epic int
//   - note int
//   - options ...gitlab.RequestOptionFunc
func (_e *NotesServiceInterface_Expecter) DeleteEpicNote(gid interface{}, epic interface{}, note interface{}, options ...interface{}) *NotesServiceInterface_DeleteEpicNote_Call {
	return &NotesServiceInterface_DeleteEpicNote_Call{Call: _e.mock.On("DeleteEpicNote",
		append([]interface{}{gid, epic, note}, options...)...)}
}

func (_c *NotesServiceInterface_DeleteEpicNote_Call) Run(run func(gid interface{}, epic int, note int, options ...gitlab.RequestOptionFunc)) *NotesServiceInterface_DeleteEpicNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), variadicArgs...)
	})
	return _c
}

func (_c *NotesServiceInterface_DeleteEpicNote_Call) Return(_a0 *gitlab.Response, _a1 error) *NotesServiceInterface_DeleteEpicNote_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NotesServiceInterface_DeleteEpicNote_Call) RunAndReturn(run func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *NotesServiceInterface_DeleteEpicNote_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteIssueNote provides a mock function with given fields: pid, issue, note, options
func (_m *NotesServiceInterface) DeleteIssueNote(pid interface{}, issue int, note int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issue, note)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteIssueNote")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, issue, note, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, issue, note, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, issue, note, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NotesServiceInterface_DeleteIssueNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteIssueNote'
type NotesServiceInterface_DeleteIssueNote_Call struct {
	*mock.Call
}

// DeleteIssueNote is a helper method to define mock.On call
//   - pid interface{}
//   - issue int
//   - note int
//   - options ...gitlab.RequestOptionFunc
func (_e *NotesServiceInterface_Expecter) DeleteIssueNote(pid interface{}, issue interface{}, note interface{}, options ...interface{}) *NotesServiceInterface_DeleteIssueNote_Call {
	return &NotesServiceInterface_DeleteIssueNote_Call{Call: _e.mock.On("DeleteIssueNote",
		append([]interface{}{pid, issue, note}, options...)...)}
}

func (_c *NotesServiceInterface_DeleteIssueNote_Call) Run(run func(pid interface{}, issue int, note int, options ...gitlab.RequestOptionFunc)) *NotesServiceInterface_DeleteIssueNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), variadicArgs...)
	})
	return _c
}

func (_c *NotesServiceInterface_DeleteIssueNote_Call) Return(_a0 *gitlab.Response, _a1 error) *NotesServiceInterface_DeleteIssueNote_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NotesServiceInterface_DeleteIssueNote_Call) RunAndReturn(run func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *NotesServiceInterface_DeleteIssueNote_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteMergeRequestNote provides a mock function with given fields: pid, mergeRequest, note, options
func (_m *NotesServiceInterface) DeleteMergeRequestNote(pid interface{}, mergeRequest int, note int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, note)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteMergeRequestNote")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, note, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, mergeRequest, note, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, mergeRequest, note, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NotesServiceInterface_DeleteMergeRequestNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteMergeRequestNote'
type NotesServiceInterface_DeleteMergeRequestNote_Call struct {
	*mock.Call
}

// DeleteMergeRequestNote is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - note int
//   - options ...gitlab.RequestOptionFunc
func (_e *NotesServiceInterface_Expecter) DeleteMergeRequestNote(pid interface{}, mergeRequest interface{}, note interface{}, options ...interface{}) *NotesServiceInterface_DeleteMergeRequestNote_Call {
	return &NotesServiceInterface_DeleteMergeRequestNote_Call{Call: _e.mock.On("DeleteMergeRequestNote",
		append([]interface{}{pid, mergeRequest, note}, options...)...)}
}

func (_c *NotesServiceInterface_DeleteMergeRequestNote_Call) Run(run func(pid interface{}, mergeRequest int, note int, options ...gitlab.RequestOptionFunc)) *NotesServiceInterface_DeleteMergeRequestNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), variadicArgs...)
	})
	return _c
}

func (_c *NotesServiceInterface_DeleteMergeRequestNote_Call) Return(_a0 *gitlab.Response, _a1 error) *NotesServiceInterface_DeleteMergeRequestNote_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NotesServiceInterface_DeleteMergeRequestNote_Call) RunAndReturn(run func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *NotesServiceInterface_DeleteMergeRequestNote_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteSnippetNote provides a mock function with given fields: pid, snippet, note, options
func (_m *NotesServiceInterface) DeleteSnippetNote(pid interface{}, snippet int, note int, options ...gitlab.RequestOptionFunc) (*gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, snippet, note)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteSnippetNote")
	}

	var r0 *gitlab.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)); ok {
		return rf(pid, snippet, note, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r0 = rf(pid, snippet, note, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) error); ok {
		r1 = rf(pid, snippet, note, options...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NotesServiceInterface_DeleteSnippetNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteSnippetNote'
type NotesServiceInterface_DeleteSnippetNote_Call struct {
	*mock.Call
}

// DeleteSnippetNote is a helper method to define mock.On call
//   - pid interface{}
//   - snippet int
//   - note int
//   - options ...gitlab.RequestOptionFunc
func (_e *NotesServiceInterface_Expecter) DeleteSnippetNote(pid interface{}, snippet interface{}, note interface{}, options ...interface{}) *NotesServiceInterface_DeleteSnippetNote_Call {
	return &NotesServiceInterface_DeleteSnippetNote_Call{Call: _e.mock.On("DeleteSnippetNote",
		append([]interface{}{pid, snippet, note}, options...)...)}
}

func (_c *NotesServiceInterface_DeleteSnippetNote_Call) Run(run func(pid interface{}, snippet int, note int, options ...gitlab.RequestOptionFunc)) *NotesServiceInterface_DeleteSnippetNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), variadicArgs...)
	})
	return _c
}

func (_c *NotesServiceInterface_DeleteSnippetNote_Call) Return(_a0 *gitlab.Response, _a1 error) *NotesServiceInterface_DeleteSnippetNote_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NotesServiceInterface_DeleteSnippetNote_Call) RunAndReturn(run func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Response, error)) *NotesServiceInterface_DeleteSnippetNote_Call {
	_c.Call.Return(run)
	return _c
}

// GetEpicNote provides a mock function with given fields: gid, epic, note, options
func (_m *NotesServiceInterface) GetEpicNote(gid interface{}, epic int, note int, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, epic, note)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetEpicNote")
	}

	var r0 *gitlab.Note
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)); ok {
		return rf(gid, epic, note, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) *gitlab.Note); ok {
		r0 = rf(gid, epic, note, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Note)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, epic, note, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, epic, note, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NotesServiceInterface_GetEpicNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEpicNote'
type NotesServiceInterface_GetEpicNote_Call struct {
	*mock.Call
}

// GetEpicNote is a helper method to define mock.On call
//   - gid interface{}
//   - epic int
//   - note int
//   - options ...gitlab.RequestOptionFunc
func (_e *NotesServiceInterface_Expecter) GetEpicNote(gid interface{}, epic interface{}, note interface{}, options ...interface{}) *NotesServiceInterface_GetEpicNote_Call {
	return &NotesServiceInterface_GetEpicNote_Call{Call: _e.mock.On("GetEpicNote",
		append([]interface{}{gid, epic, note}, options...)...)}
}

func (_c *NotesServiceInterface_GetEpicNote_Call) Run(run func(gid interface{}, epic int, note int, options ...gitlab.RequestOptionFunc)) *NotesServiceInterface_GetEpicNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), variadicArgs...)
	})
	return _c
}

func (_c *NotesServiceInterface_GetEpicNote_Call) Return(_a0 *gitlab.Note, _a1 *gitlab.Response, _a2 error) *NotesServiceInterface_GetEpicNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *NotesServiceInterface_GetEpicNote_Call) RunAndReturn(run func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *NotesServiceInterface_GetEpicNote_Call {
	_c.Call.Return(run)
	return _c
}

// GetIssueNote provides a mock function with given fields: pid, issue, note, options
func (_m *NotesServiceInterface) GetIssueNote(pid interface{}, issue int, note int, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issue, note)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetIssueNote")
	}

	var r0 *gitlab.Note
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)); ok {
		return rf(pid, issue, note, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) *gitlab.Note); ok {
		r0 = rf(pid, issue, note, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Note)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issue, note, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issue, note, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NotesServiceInterface_GetIssueNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIssueNote'
type NotesServiceInterface_GetIssueNote_Call struct {
	*mock.Call
}

// GetIssueNote is a helper method to define mock.On call
//   - pid interface{}
//   - issue int
//   - note int
//   - options ...gitlab.RequestOptionFunc
func (_e *NotesServiceInterface_Expecter) GetIssueNote(pid interface{}, issue interface{}, note interface{}, options ...interface{}) *NotesServiceInterface_GetIssueNote_Call {
	return &NotesServiceInterface_GetIssueNote_Call{Call: _e.mock.On("GetIssueNote",
		append([]interface{}{pid, issue, note}, options...)...)}
}

func (_c *NotesServiceInterface_GetIssueNote_Call) Run(run func(pid interface{}, issue int, note int, options ...gitlab.RequestOptionFunc)) *NotesServiceInterface_GetIssueNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), variadicArgs...)
	})
	return _c
}

func (_c *NotesServiceInterface_GetIssueNote_Call) Return(_a0 *gitlab.Note, _a1 *gitlab.Response, _a2 error) *NotesServiceInterface_GetIssueNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *NotesServiceInterface_GetIssueNote_Call) RunAndReturn(run func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *NotesServiceInterface_GetIssueNote_Call {
	_c.Call.Return(run)
	return _c
}

// GetMergeRequestNote provides a mock function with given fields: pid, mergeRequest, note, options
func (_m *NotesServiceInterface) GetMergeRequestNote(pid interface{}, mergeRequest int, note int, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, note)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetMergeRequestNote")
	}

	var r0 *gitlab.Note
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, note, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) *gitlab.Note); ok {
		r0 = rf(pid, mergeRequest, note, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Note)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, note, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, note, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NotesServiceInterface_GetMergeRequestNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMergeRequestNote'
type NotesServiceInterface_GetMergeRequestNote_Call struct {
	*mock.Call
}

// GetMergeRequestNote is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - note int
//   - options ...gitlab.RequestOptionFunc
func (_e *NotesServiceInterface_Expecter) GetMergeRequestNote(pid interface{}, mergeRequest interface{}, note interface{}, options ...interface{}) *NotesServiceInterface_GetMergeRequestNote_Call {
	return &NotesServiceInterface_GetMergeRequestNote_Call{Call: _e.mock.On("GetMergeRequestNote",
		append([]interface{}{pid, mergeRequest, note}, options...)...)}
}

func (_c *NotesServiceInterface_GetMergeRequestNote_Call) Run(run func(pid interface{}, mergeRequest int, note int, options ...gitlab.RequestOptionFunc)) *NotesServiceInterface_GetMergeRequestNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), variadicArgs...)
	})
	return _c
}

func (_c *NotesServiceInterface_GetMergeRequestNote_Call) Return(_a0 *gitlab.Note, _a1 *gitlab.Response, _a2 error) *NotesServiceInterface_GetMergeRequestNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *NotesServiceInterface_GetMergeRequestNote_Call) RunAndReturn(run func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *NotesServiceInterface_GetMergeRequestNote_Call {
	_c.Call.Return(run)
	return _c
}

// GetSnippetNote provides a mock function with given fields: pid, snippet, note, options
func (_m *NotesServiceInterface) GetSnippetNote(pid interface{}, snippet int, note int, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, snippet, note)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetSnippetNote")
	}

	var r0 *gitlab.Note
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)); ok {
		return rf(pid, snippet, note, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) *gitlab.Note); ok {
		r0 = rf(pid, snippet, note, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Note)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, snippet, note, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, int, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, snippet, note, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NotesServiceInterface_GetSnippetNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSnippetNote'
type NotesServiceInterface_GetSnippetNote_Call struct {
	*mock.Call
}

// GetSnippetNote is a helper method to define mock.On call
//   - pid interface{}
//   - snippet int
//   - note int
//   - options ...gitlab.RequestOptionFunc
func (_e *NotesServiceInterface_Expecter) GetSnippetNote(pid interface{}, snippet interface{}, note interface{}, options ...interface{}) *NotesServiceInterface_GetSnippetNote_Call {
	return &NotesServiceInterface_GetSnippetNote_Call{Call: _e.mock.On("GetSnippetNote",
		append([]interface{}{pid, snippet, note}, options...)...)}
}

func (_c *NotesServiceInterface_GetSnippetNote_Call) Run(run func(pid interface{}, snippet int, note int, options ...gitlab.RequestOptionFunc)) *NotesServiceInterface_GetSnippetNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), variadicArgs...)
	})
	return _c
}

func (_c *NotesServiceInterface_GetSnippetNote_Call) Return(_a0 *gitlab.Note, _a1 *gitlab.Response, _a2 error) *NotesServiceInterface_GetSnippetNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *NotesServiceInterface_GetSnippetNote_Call) RunAndReturn(run func(interface{}, int, int, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *NotesServiceInterface_GetSnippetNote_Call {
	_c.Call.Return(run)
	return _c
}

// ListEpicNotes provides a mock function with given fields: gid, epic, opt, options
func (_m *NotesServiceInterface) ListEpicNotes(gid interface{}, epic int, opt *gitlab.ListEpicNotesOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, epic, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListEpicNotes")
	}

	var r0 []*gitlab.Note
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListEpicNotesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error)); ok {
		return rf(gid, epic, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListEpicNotesOptions, ...gitlab.RequestOptionFunc) []*gitlab.Note); ok {
		r0 = rf(gid, epic, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Note)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.ListEpicNotesOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, epic, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.ListEpicNotesOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, epic, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NotesServiceInterface_ListEpicNotes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListEpicNotes'
type NotesServiceInterface_ListEpicNotes_Call struct {
	*mock.Call
}

// ListEpicNotes is a helper method to define mock.On call
//   - gid interface{}
//   - epic int
//   - opt *gitlab.ListEpicNotesOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *NotesServiceInterface_Expecter) ListEpicNotes(gid interface{}, epic interface{}, opt interface{}, options ...interface{}) *NotesServiceInterface_ListEpicNotes_Call {
	return &NotesServiceInterface_ListEpicNotes_Call{Call: _e.mock.On("ListEpicNotes",
		append([]interface{}{gid, epic, opt}, options...)...)}
}

func (_c *NotesServiceInterface_ListEpicNotes_Call) Run(run func(gid interface{}, epic int, opt *gitlab.ListEpicNotesOptions, options ...gitlab.RequestOptionFunc)) *NotesServiceInterface_ListEpicNotes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.ListEpicNotesOptions), variadicArgs...)
	})
	return _c
}

func (_c *NotesServiceInterface_ListEpicNotes_Call) Return(_a0 []*gitlab.Note, _a1 *gitlab.Response, _a2 error) *NotesServiceInterface_ListEpicNotes_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *NotesServiceInterface_ListEpicNotes_Call) RunAndReturn(run func(interface{}, int, *gitlab.ListEpicNotesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error)) *NotesServiceInterface_ListEpicNotes_Call {
	_c.Call.Return(run)
	return _c
}

// ListIssueNotes provides a mock function with given fields: pid, issue, opt, options
func (_m *NotesServiceInterface) ListIssueNotes(pid interface{}, issue int, opt *gitlab.ListIssueNotesOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issue, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListIssueNotes")
	}

	var r0 []*gitlab.Note
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListIssueNotesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error)); ok {
		return rf(pid, issue, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListIssueNotesOptions, ...gitlab.RequestOptionFunc) []*gitlab.Note); ok {
		r0 = rf(pid, issue, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Note)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.ListIssueNotesOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issue, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.ListIssueNotesOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issue, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NotesServiceInterface_ListIssueNotes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListIssueNotes'
type NotesServiceInterface_ListIssueNotes_Call struct {
	*mock.Call
}

// ListIssueNotes is a helper method to define mock.On call
//   - pid interface{}
//   - issue int
//   - opt *gitlab.ListIssueNotesOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *NotesServiceInterface_Expecter) ListIssueNotes(pid interface{}, issue interface{}, opt interface{}, options ...interface{}) *NotesServiceInterface_ListIssueNotes_Call {
	return &NotesServiceInterface_ListIssueNotes_Call{Call: _e.mock.On("ListIssueNotes",
		append([]interface{}{pid, issue, opt}, options...)...)}
}

func (_c *NotesServiceInterface_ListIssueNotes_Call) Run(run func(pid interface{}, issue int, opt *gitlab.ListIssueNotesOptions, options ...gitlab.RequestOptionFunc)) *NotesServiceInterface_ListIssueNotes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.ListIssueNotesOptions), variadicArgs...)
	})
	return _c
}

func (_c *NotesServiceInterface_ListIssueNotes_Call) Return(_a0 []*gitlab.Note, _a1 *gitlab.Response, _a2 error) *NotesServiceInterface_ListIssueNotes_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *NotesServiceInterface_ListIssueNotes_Call) RunAndReturn(run func(interface{}, int, *gitlab.ListIssueNotesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error)) *NotesServiceInterface_ListIssueNotes_Call {
	_c.Call.Return(run)
	return _c
}

// ListMergeRequestNotes provides a mock function with given fields: pid, mergeRequest, opt, options
func (_m *NotesServiceInterface) ListMergeRequestNotes(pid interface{}, mergeRequest int, opt *gitlab.ListMergeRequestNotesOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListMergeRequestNotes")
	}

	var r0 []*gitlab.Note
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListMergeRequestNotesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListMergeRequestNotesOptions, ...gitlab.RequestOptionFunc) []*gitlab.Note); ok {
		r0 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Note)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.ListMergeRequestNotesOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.ListMergeRequestNotesOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NotesServiceInterface_ListMergeRequestNotes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListMergeRequestNotes'
type NotesServiceInterface_ListMergeRequestNotes_Call struct {
	*mock.Call
}

// ListMergeRequestNotes is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - opt *gitlab.ListMergeRequestNotesOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *NotesServiceInterface_Expecter) ListMergeRequestNotes(pid interface{}, mergeRequest interface{}, opt interface{}, options ...interface{}) *NotesServiceInterface_ListMergeRequestNotes_Call {
	return &NotesServiceInterface_ListMergeRequestNotes_Call{Call: _e.mock.On("ListMergeRequestNotes",
		append([]interface{}{pid, mergeRequest, opt}, options...)...)}
}

func (_c *NotesServiceInterface_ListMergeRequestNotes_Call) Run(run func(pid interface{}, mergeRequest int, opt *gitlab.ListMergeRequestNotesOptions, options ...gitlab.RequestOptionFunc)) *NotesServiceInterface_ListMergeRequestNotes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.ListMergeRequestNotesOptions), variadicArgs...)
	})
	return _c
}

func (_c *NotesServiceInterface_ListMergeRequestNotes_Call) Return(_a0 []*gitlab.Note, _a1 *gitlab.Response, _a2 error) *NotesServiceInterface_ListMergeRequestNotes_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *NotesServiceInterface_ListMergeRequestNotes_Call) RunAndReturn(run func(interface{}, int, *gitlab.ListMergeRequestNotesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error)) *NotesServiceInterface_ListMergeRequestNotes_Call {
	_c.Call.Return(run)
	return _c
}

// ListSnippetNotes provides a mock function with given fields: pid, snippet, opt, options
func (_m *NotesServiceInterface) ListSnippetNotes(pid interface{}, snippet int, opt *gitlab.ListSnippetNotesOptions, options ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, snippet, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ListSnippetNotes")
	}

	var r0 []*gitlab.Note
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListSnippetNotesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error)); ok {
		return rf(pid, snippet, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, *gitlab.ListSnippetNotesOptions, ...gitlab.RequestOptionFunc) []*gitlab.Note); ok {
		r0 = rf(pid, snippet, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*gitlab.Note)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, *gitlab.ListSnippetNotesOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, snippet, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, *gitlab.ListSnippetNotesOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, snippet, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NotesServiceInterface_ListSnippetNotes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListSnippetNotes'
type NotesServiceInterface_ListSnippetNotes_Call struct {
	*mock.Call
}

// ListSnippetNotes is a helper method to define mock.On call
//   - pid interface{}
//   - snippet int
//   - opt *gitlab.ListSnippetNotesOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *NotesServiceInterface_Expecter) ListSnippetNotes(pid interface{}, snippet interface{}, opt interface{}, options ...interface{}) *NotesServiceInterface_ListSnippetNotes_Call {
	return &NotesServiceInterface_ListSnippetNotes_Call{Call: _e.mock.On("ListSnippetNotes",
		append([]interface{}{pid, snippet, opt}, options...)...)}
}

func (_c *NotesServiceInterface_ListSnippetNotes_Call) Run(run func(pid interface{}, snippet int, opt *gitlab.ListSnippetNotesOptions, options ...gitlab.RequestOptionFunc)) *NotesServiceInterface_ListSnippetNotes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(*gitlab.ListSnippetNotesOptions), variadicArgs...)
	})
	return _c
}

func (_c *NotesServiceInterface_ListSnippetNotes_Call) Return(_a0 []*gitlab.Note, _a1 *gitlab.Response, _a2 error) *NotesServiceInterface_ListSnippetNotes_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *NotesServiceInterface_ListSnippetNotes_Call) RunAndReturn(run func(interface{}, int, *gitlab.ListSnippetNotesOptions, ...gitlab.RequestOptionFunc) ([]*gitlab.Note, *gitlab.Response, error)) *NotesServiceInterface_ListSnippetNotes_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateEpicNote provides a mock function with given fields: gid, epic, note, opt, options
func (_m *NotesServiceInterface) UpdateEpicNote(gid interface{}, epic int, note int, opt *gitlab.UpdateEpicNoteOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, gid, epic, note, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEpicNote")
	}

	var r0 *gitlab.Note
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, *gitlab.UpdateEpicNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)); ok {
		return rf(gid, epic, note, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, *gitlab.UpdateEpicNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Note); ok {
		r0 = rf(gid, epic, note, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Note)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, *gitlab.UpdateEpicNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(gid, epic, note, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, int, *gitlab.UpdateEpicNoteOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(gid, epic, note, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NotesServiceInterface_UpdateEpicNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateEpicNote'
type NotesServiceInterface_UpdateEpicNote_Call struct {
	*mock.Call
}

// UpdateEpicNote is a helper method to define mock.On call
//   - gid interface{}
//   - epic int
//   - note int
//   - opt *gitlab.UpdateEpicNoteOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *NotesServiceInterface_Expecter) UpdateEpicNote(gid interface{}, epic interface{}, note interface{}, opt interface{}, options ...interface{}) *NotesServiceInterface_UpdateEpicNote_Call {
	return &NotesServiceInterface_UpdateEpicNote_Call{Call: _e.mock.On("UpdateEpicNote",
		append([]interface{}{gid, epic, note, opt}, options...)...)}
}

func (_c *NotesServiceInterface_UpdateEpicNote_Call) Run(run func(gid interface{}, epic int, note int, opt *gitlab.UpdateEpicNoteOptions, options ...gitlab.RequestOptionFunc)) *NotesServiceInterface_UpdateEpicNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), args[3].(*gitlab.UpdateEpicNoteOptions), variadicArgs...)
	})
	return _c
}

func (_c *NotesServiceInterface_UpdateEpicNote_Call) Return(_a0 *gitlab.Note, _a1 *gitlab.Response, _a2 error) *NotesServiceInterface_UpdateEpicNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *NotesServiceInterface_UpdateEpicNote_Call) RunAndReturn(run func(interface{}, int, int, *gitlab.UpdateEpicNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *NotesServiceInterface_UpdateEpicNote_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateIssueNote provides a mock function with given fields: pid, issue, note, opt, options
func (_m *NotesServiceInterface) UpdateIssueNote(pid interface{}, issue int, note int, opt *gitlab.UpdateIssueNoteOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, issue, note, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateIssueNote")
	}

	var r0 *gitlab.Note
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, *gitlab.UpdateIssueNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)); ok {
		return rf(pid, issue, note, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, *gitlab.UpdateIssueNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Note); ok {
		r0 = rf(pid, issue, note, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Note)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, *gitlab.UpdateIssueNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, issue, note, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, int, *gitlab.UpdateIssueNoteOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, issue, note, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NotesServiceInterface_UpdateIssueNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateIssueNote'
type NotesServiceInterface_UpdateIssueNote_Call struct {
	*mock.Call
}

// UpdateIssueNote is a helper method to define mock.On call
//   - pid interface{}
//   - issue int
//   - note int
//   - opt *gitlab.UpdateIssueNoteOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *NotesServiceInterface_Expecter) UpdateIssueNote(pid interface{}, issue interface{}, note interface{}, opt interface{}, options ...interface{}) *NotesServiceInterface_UpdateIssueNote_Call {
	return &NotesServiceInterface_UpdateIssueNote_Call{Call: _e.mock.On("UpdateIssueNote",
		append([]interface{}{pid, issue, note, opt}, options...)...)}
}

func (_c *NotesServiceInterface_UpdateIssueNote_Call) Run(run func(pid interface{}, issue int, note int, opt *gitlab.UpdateIssueNoteOptions, options ...gitlab.RequestOptionFunc)) *NotesServiceInterface_UpdateIssueNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), args[3].(*gitlab.UpdateIssueNoteOptions), variadicArgs...)
	})
	return _c
}

func (_c *NotesServiceInterface_UpdateIssueNote_Call) Return(_a0 *gitlab.Note, _a1 *gitlab.Response, _a2 error) *NotesServiceInterface_UpdateIssueNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *NotesServiceInterface_UpdateIssueNote_Call) RunAndReturn(run func(interface{}, int, int, *gitlab.UpdateIssueNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *NotesServiceInterface_UpdateIssueNote_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateMergeRequestNote provides a mock function with given fields: pid, mergeRequest, note, opt, options
func (_m *NotesServiceInterface) UpdateMergeRequestNote(pid interface{}, mergeRequest int, note int, opt *gitlab.UpdateMergeRequestNoteOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, mergeRequest, note, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMergeRequestNote")
	}

	var r0 *gitlab.Note
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, *gitlab.UpdateMergeRequestNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)); ok {
		return rf(pid, mergeRequest, note, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, *gitlab.UpdateMergeRequestNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Note); ok {
		r0 = rf(pid, mergeRequest, note, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Note)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, *gitlab.UpdateMergeRequestNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, mergeRequest, note, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, int, *gitlab.UpdateMergeRequestNoteOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, mergeRequest, note, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NotesServiceInterface_UpdateMergeRequestNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateMergeRequestNote'
type NotesServiceInterface_UpdateMergeRequestNote_Call struct {
	*mock.Call
}

// UpdateMergeRequestNote is a helper method to define mock.On call
//   - pid interface{}
//   - mergeRequest int
//   - note int
//   - opt *gitlab.UpdateMergeRequestNoteOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *NotesServiceInterface_Expecter) UpdateMergeRequestNote(pid interface{}, mergeRequest interface{}, note interface{}, opt interface{}, options ...interface{}) *NotesServiceInterface_UpdateMergeRequestNote_Call {
	return &NotesServiceInterface_UpdateMergeRequestNote_Call{Call: _e.mock.On("UpdateMergeRequestNote",
		append([]interface{}{pid, mergeRequest, note, opt}, options...)...)}
}

func (_c *NotesServiceInterface_UpdateMergeRequestNote_Call) Run(run func(pid interface{}, mergeRequest int, note int, opt *gitlab.UpdateMergeRequestNoteOptions, options ...gitlab.RequestOptionFunc)) *NotesServiceInterface_UpdateMergeRequestNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), args[3].(*gitlab.UpdateMergeRequestNoteOptions), variadicArgs...)
	})
	return _c
}

func (_c *NotesServiceInterface_UpdateMergeRequestNote_Call) Return(_a0 *gitlab.Note, _a1 *gitlab.Response, _a2 error) *NotesServiceInterface_UpdateMergeRequestNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *NotesServiceInterface_UpdateMergeRequestNote_Call) RunAndReturn(run func(interface{}, int, int, *gitlab.UpdateMergeRequestNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *NotesServiceInterface_UpdateMergeRequestNote_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateSnippetNote provides a mock function with given fields: pid, snippet, note, opt, options
func (_m *NotesServiceInterface) UpdateSnippetNote(pid interface{}, snippet int, note int, opt *gitlab.UpdateSnippetNoteOptions, options ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error) {
	_va := make([]interface{}, len(options))
	for _i := range options {
		_va[_i] = options[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, pid, snippet, note, opt)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateSnippetNote")
	}

	var r0 *gitlab.Note
	var r1 *gitlab.Response
	var r2 error
	if rf, ok := ret.Get(0).(func(interface{}, int, int, *gitlab.UpdateSnippetNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)); ok {
		return rf(pid, snippet, note, opt, options...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, int, int, *gitlab.UpdateSnippetNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Note); ok {
		r0 = rf(pid, snippet, note, opt, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gitlab.Note)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, int, int, *gitlab.UpdateSnippetNoteOptions, ...gitlab.RequestOptionFunc) *gitlab.Response); ok {
		r1 = rf(pid, snippet, note, opt, options...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(*gitlab.Response)
		}
	}

	if rf, ok := ret.Get(2).(func(interface{}, int, int, *gitlab.UpdateSnippetNoteOptions, ...gitlab.RequestOptionFunc) error); ok {
		r2 = rf(pid, snippet, note, opt, options...)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// NotesServiceInterface_UpdateSnippetNote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateSnippetNote'
type NotesServiceInterface_UpdateSnippetNote_Call struct {
	*mock.Call
}

// UpdateSnippetNote is a helper method to define mock.On call
//   - pid interface{}
//   - snippet int
//   - note int
//   - opt *gitlab.UpdateSnippetNoteOptions
//   - options ...gitlab.RequestOptionFunc
func (_e *NotesServiceInterface_Expecter) UpdateSnippetNote(pid interface{}, snippet interface{}, note interface{}, opt interface{}, options ...interface{}) *NotesServiceInterface_UpdateSnippetNote_Call {
	return &NotesServiceInterface_UpdateSnippetNote_Call{Call: _e.mock.On("UpdateSnippetNote",
		append([]interface{}{pid, snippet, note, opt}, options...)...)}
}

func (_c *NotesServiceInterface_UpdateSnippetNote_Call) Run(run func(pid interface{}, snippet int, note int, opt *gitlab.UpdateSnippetNoteOptions, options ...gitlab.RequestOptionFunc)) *NotesServiceInterface_UpdateSnippetNote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]gitlab.RequestOptionFunc, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(gitlab.RequestOptionFunc)
			}
		}
		run(args[0].(interface{}), args[1].(int), args[2].(int), args[3].(*gitlab.UpdateSnippetNoteOptions), variadicArgs...)
	})
	return _c
}

func (_c *NotesServiceInterface_UpdateSnippetNote_Call) Return(_a0 *gitlab.Note, _a1 *gitlab.Response, _a2 error) *NotesServiceInterface_UpdateSnippetNote_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *NotesServiceInterface_UpdateSnippetNote_Call) RunAndReturn(run func(interface{}, int, int, *gitlab.UpdateSnippetNoteOptions, ...gitlab.RequestOptionFunc) (*gitlab.Note, *gitlab.Response, error)) *NotesServiceInterface_UpdateSnippetNote_Call {
	_c.Call.Return(run)
	return _c
}

// NewNotesServiceInterface creates a new instance of NotesServiceInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewNotesServiceInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *NotesServiceInterface {
	mock := &NotesServiceInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
